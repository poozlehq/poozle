// @ts-nocheck
import { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { findAndParseConfig } from '@graphql-mesh/cli';
import { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';
import { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';
import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';
import { path as pathModule } from '@graphql-mesh/cross-helpers';
import { ImportFn } from '@graphql-mesh/types';
import type { AwsLambdaTypes } from './sources/AWS Lambda/types';
import type { GithubTypes } from './sources/Github/types';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };



/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  JSON: any;
  Github_Base64String: any;
  Date: any;
  DateTime: any;
  Github_GitObjectID: any;
  Github_GitRefname: any;
  Github_GitSSHRemote: any;
  Github_GitTimestamp: any;
  Github_HTML: any;
  Github_PreciseDateTime: any;
  Github_URI: any;
  Github_X509Certificate: any;
};

/** The query root of GitHub's GraphQL interface. */
export type Query = {
  aws_lambda_1: aws_lambda_1Query;
  github_1: github_1Query;
};

export type AWSLambda_ListFunctionsResponse = {
  functions?: Maybe<Array<Maybe<AWSLambda_FunctionsListItem>>>;
  /** The pagination token that's included if more results are available. */
  nextMarker?: Maybe<Scalars['String']>;
};

export type AWSLambda_FunctionsListItem = {
  /** The SHA256 hash of the function's deployment package. */
  codeSha256?: Maybe<Scalars['String']>;
  /** The size of the function's deployment package, in bytes. */
  codeSize?: Maybe<Scalars['Int']>;
  /** The function's dead letter queue. */
  deadLetterConfig?: Maybe<AWSLambda_DeadLetterConfig>;
  /** The function's description. */
  description?: Maybe<Scalars['String']>;
  /** The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables</a>. */
  environment?: Maybe<AWSLambda_Environment>;
  /** Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system</a>. */
  fileSystemConfigs?: Maybe<Array<Maybe<AWSLambda_FileSystemConfigsListItem>>>;
  /** The function's Amazon Resource Name (ARN). */
  functionArn?: Maybe<Scalars['String']>;
  /** The name of the function. */
  functionName?: Maybe<Scalars['String']>;
  /** The function that Lambda calls to begin executing your function. */
  handler?: Maybe<Scalars['String']>;
  /** The function's image configuration values. */
  imageConfigResponse?: Maybe<AWSLambda_ImageConfigResponse>;
  /** The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed CMK. */
  kMSKeyArn?: Maybe<Scalars['String']>;
  /** The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD). */
  lastModified?: Maybe<Scalars['String']>;
  /** The status of the last update that was performed on the function. This is first set to <code>Successful</code> after function creation completes. */
  lastUpdateStatus?: Maybe<AWSLambda_LastUpdateStatus>;
  /** The reason for the last update that was performed on the function. */
  lastUpdateStatusReason?: Maybe<Scalars['String']>;
  /** The reason code for the last update that was performed on the function. */
  lastUpdateStatusReasonCode?: Maybe<AWSLambda_LastUpdateStatusReasonCode>;
  /** The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html"> layers</a>. */
  layers?: Maybe<Array<Maybe<AWSLambda_LayersListItem>>>;
  /** For Lambda@Edge functions, the ARN of the master function */
  masterArn?: Maybe<Scalars['String']>;
  /** The amount of memory available to the function at runtime.  */
  memorySize?: Maybe<Scalars['Int']>;
  /** The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive. */
  packageType?: Maybe<AWSLambda_PackageType>;
  /** The latest updated revision of the function or alias. */
  revisionId?: Maybe<Scalars['String']>;
  /** The function's execution role. */
  role?: Maybe<Scalars['String']>;
  /** The runtime environment for the Lambda function. */
  runtime?: Maybe<AWSLambda_Runtime>;
  /** The ARN of the signing job. */
  signingJobArn?: Maybe<Scalars['String']>;
  /** The ARN of the signing profile version. */
  signingProfileVersionArn?: Maybe<Scalars['String']>;
  /** The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by invoking it. */
  state?: Maybe<AWSLambda_State>;
  /** The reason for the function's current state. */
  stateReason?: Maybe<Scalars['String']>;
  /** The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or modify the function. */
  stateReasonCode?: Maybe<AWSLambda_StateReasonCode>;
  /** The amount of time in seconds that Lambda allows a function to run before stopping it. */
  timeout?: Maybe<Scalars['Int']>;
  /** The function's X-Ray tracing configuration. */
  tracingConfig?: Maybe<AWSLambda_TracingConfig>;
  /** The version of the Lambda function. */
  version?: Maybe<Scalars['String']>;
  /** The function's networking configuration. */
  vpcConfig?: Maybe<AWSLambda_VpcConfig>;
};

/** The function's dead letter queue. */
export type AWSLambda_DeadLetterConfig = {
  /** The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic. */
  targetArn?: Maybe<Scalars['String']>;
};

/** The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables</a>. */
export type AWSLambda_Environment = {
  /** Error messages for environment variables that couldn't be applied. */
  error?: Maybe<AWSLambda_Error>;
  /** Environment variable key-value pairs. */
  variables?: Maybe<Scalars['JSON']>;
};

/** Error messages for environment variables that couldn't be applied. */
export type AWSLambda_Error = {
  /** The error code. */
  errorCode?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

export type AWSLambda_FileSystemConfigsListItem = {
  /** The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system. */
  arn: Scalars['String'];
  /** The path where the function can access the file system, starting with <code>/mnt/</code>. */
  localMountPath: Scalars['String'];
};

/** The function's image configuration values. */
export type AWSLambda_ImageConfigResponse = {
  /** Error response to GetFunctionConfiguration. */
  error?: Maybe<AWSLambda_Error2>;
  /** Configuration values that override the container image Dockerfile. */
  imageConfig?: Maybe<AWSLambda_ImageConfig>;
};

/** Error response to GetFunctionConfiguration. */
export type AWSLambda_Error2 = {
  /** Error code. */
  errorCode?: Maybe<Scalars['String']>;
  /** Error message. */
  message?: Maybe<Scalars['String']>;
};

/** Configuration values that override the container image Dockerfile. */
export type AWSLambda_ImageConfig = {
  /** Specifies parameters that you want to pass in with ENTRYPOINT.  */
  command?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Specifies the entry point to their application, which is typically the location of the runtime executable. */
  entryPoint?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Specifies the working directory. */
  workingDirectory?: Maybe<Scalars['String']>;
};

export type AWSLambda_LastUpdateStatus =
  | 'SUCCESSFUL'
  | 'FAILED'
  | 'INPROGRESS';

export type AWSLambda_LastUpdateStatusReasonCode =
  | 'ENILIMITEXCEEDED'
  | 'INSUFFICIENTROLEPERMISSIONS'
  | 'INVALIDCONFIGURATION'
  | 'INTERNALERROR'
  | 'SUBNETOUTOFIPADDRESSES'
  | 'INVALIDSUBNET'
  | 'INVALIDSECURITYGROUP'
  | 'IMAGEDELETED'
  | 'IMAGEACCESSDENIED'
  | 'INVALIDIMAGE';

export type AWSLambda_LayersListItem = {
  /** The Amazon Resource Name (ARN) of the function layer. */
  arn?: Maybe<Scalars['String']>;
  /** The size of the layer archive in bytes. */
  codeSize?: Maybe<Scalars['Int']>;
  /** The Amazon Resource Name (ARN) of a signing job. */
  signingJobArn?: Maybe<Scalars['String']>;
  /** The Amazon Resource Name (ARN) for a signing profile version. */
  signingProfileVersionArn?: Maybe<Scalars['String']>;
};

export type AWSLambda_PackageType =
  | 'ZIP'
  | 'IMAGE';

export type AWSLambda_Runtime =
  | 'NODEJS'
  | 'NODEJS4_3'
  | 'NODEJS6_10'
  | 'NODEJS8_10'
  | 'NODEJS10_X'
  | 'NODEJS12_X'
  | 'NODEJS14_X'
  | 'JAVA8'
  | 'JAVA8_AL2'
  | 'JAVA11'
  | 'PYTHON2_7'
  | 'PYTHON3_6'
  | 'PYTHON3_7'
  | 'PYTHON3_8'
  | 'PYTHON3_9'
  | 'DOTNETCORE1_0'
  | 'DOTNETCORE2_0'
  | 'DOTNETCORE2_1'
  | 'DOTNETCORE3_1'
  | 'NODEJS4_3_EDGE'
  | 'GO1_X'
  | 'RUBY2_5'
  | 'RUBY2_7'
  | 'PROVIDED'
  | 'PROVIDED_AL2';

export type AWSLambda_State =
  | 'PENDING'
  | 'ACTIVE'
  | 'INACTIVE'
  | 'FAILED';

export type AWSLambda_StateReasonCode =
  | 'IDLE'
  | 'CREATING'
  | 'RESTORING'
  | 'ENILIMITEXCEEDED'
  | 'INSUFFICIENTROLEPERMISSIONS'
  | 'INVALIDCONFIGURATION'
  | 'INTERNALERROR'
  | 'SUBNETOUTOFIPADDRESSES'
  | 'INVALIDSUBNET'
  | 'INVALIDSECURITYGROUP'
  | 'IMAGEDELETED'
  | 'IMAGEACCESSDENIED'
  | 'INVALIDIMAGE';

/** The function's X-Ray tracing configuration. */
export type AWSLambda_TracingConfig = {
  /** The tracing mode. */
  mode?: Maybe<AWSLambda_Mode>;
};

export type AWSLambda_Mode =
  | 'ACTIVE'
  | 'PASSTHROUGH';

/** The function's networking configuration. */
export type AWSLambda_VpcConfig = {
  /** A list of VPC security groups IDs. */
  securityGroupIds?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** A list of VPC subnet IDs. */
  subnetIds?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The ID of the VPC. */
  vpcId?: Maybe<Scalars['String']>;
};

export type AWSLambda_FunctionVersion =
  | 'ALL';

export type aws_lambda_1Query = {
  /**
   * <p>Returns a list of Lambda functions, with the version-specific configuration of each. Lambda returns up to 50 functions per call.</p> <p>Set <code>FunctionVersion</code> to <code>ALL</code> to include all published versions of each function in addition to the unpublished version. </p> <note> <p>The <code>ListFunctions</code> action returns a subset of the <a>FunctionConfiguration</a> fields. To get the additional fields (State, StateReasonCode, StateReason, LastUpdateStatus, LastUpdateStatusReason, LastUpdateStatusReasonCode) for a function or version, use <a>GetFunction</a>.</p> </note>
   *
   * Equivalent to GET /2015-03-31/functions/
   */
  listFunctionsResponse?: Maybe<AWSLambda_ListFunctionsResponse>;
};


export type aws_lambda_1QuerylistFunctionsResponseArgs = {
  functionVersion?: InputMaybe<AWSLambda_FunctionVersion>;
  marker?: InputMaybe<Scalars['String']>;
  masterRegion?: InputMaybe<Scalars['String']>;
  maxItems?: InputMaybe<Scalars['Int']>;
};

/** The root query for implementing GraphQL mutations. */
export type Mutation = {
  github_1: github_1Mutation;
};

/** Autogenerated input type of AbortQueuedMigrations */
export type Github_AbortQueuedMigrationsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization that is running the migrations. */
  ownerId: Scalars['ID'];
};

/** Autogenerated return type of AbortQueuedMigrations */
export type Github_AbortQueuedMigrationsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type Github_AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
export type Github_AcceptEnterpriseAdministratorInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The invitation that was accepted. */
  invitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type Github_AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type Github_AcceptTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The accepted topic. */
  topic?: Maybe<Github_Topic>;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Github_Actor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this actor. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this actor. */
  url: Scalars['Github_URI'];
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Github_ActoravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Location information for an actor */
export type Github_ActorLocation = {
  /** City */
  city?: Maybe<Scalars['String']>;
  /** Country name */
  country?: Maybe<Scalars['String']>;
  /** Country code */
  countryCode?: Maybe<Scalars['String']>;
  /** Region name */
  region?: Maybe<Scalars['String']>;
  /** Region or state code */
  regionCode?: Maybe<Scalars['String']>;
};

/** The actor's type. */
export type Github_ActorType =
  /** Indicates a team actor. */
  | 'TEAM'
  /** Indicates a user actor. */
  | 'USER';

/** Autogenerated input type of AddAssigneesToAssignable */
export type Github_AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AddAssigneesToAssignable */
export type Github_AddAssigneesToAssignablePayload = {
  /** The item that was assigned. */
  assignable?: Maybe<Github_Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AddComment */
export type Github_AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddComment */
export type Github_AddCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<Github_IssueCommentEdge>;
  /** The subject */
  subject?: Maybe<Github_Node>;
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<Github_IssueTimelineItemEdge>;
};

/** Autogenerated input type of AddDiscussionComment */
export type Github_AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars['ID'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of AddDiscussionComment */
export type Github_AddDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created discussion comment. */
  comment?: Maybe<Github_DiscussionComment>;
};

/** Autogenerated input type of AddDiscussionPollVote */
export type Github_AddDiscussionPollVoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion poll option to vote for. */
  pollOptionId: Scalars['ID'];
};

/** Autogenerated return type of AddDiscussionPollVote */
export type Github_AddDiscussionPollVotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The poll option that a vote was added to. */
  pollOption?: Maybe<Github_DiscussionPollOption>;
};

/** Autogenerated input type of AddEnterpriseOrganizationMember */
export type Github_AddEnterpriseOrganizationMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise which owns the organization. */
  enterpriseId: Scalars['ID'];
  /** The ID of the organization the users will be added to. */
  organizationId: Scalars['ID'];
  /** The role to assign the users in the organization */
  role?: InputMaybe<Github_OrganizationMemberRole>;
  /** The IDs of the enterprise members to add. */
  userIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of AddEnterpriseOrganizationMember */
export type Github_AddEnterpriseOrganizationMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The users who were added to the organization. */
  users?: Maybe<Array<Github_User>>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type Github_AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars['String'];
};

/** Autogenerated return type of AddEnterpriseSupportEntitlement */
export type Github_AddEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of adding the support entitlement. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AddLabelsToLabelable */
export type Github_AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of AddLabelsToLabelable */
export type Github_AddLabelsToLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was labeled. */
  labelable?: Maybe<Github_Labelable>;
};

/** Autogenerated input type of AddProjectCard */
export type Github_AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: InputMaybe<Scalars['ID']>;
  /** The note on the card. */
  note?: InputMaybe<Scalars['String']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectCard */
export type Github_AddProjectCardPayload = {
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<Github_ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ProjectColumn */
  projectColumn?: Maybe<Github_ProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
export type Github_AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the column. */
  name: Scalars['String'];
  /** The Node ID of the project. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectColumn */
export type Github_AddProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<Github_ProjectColumnEdge>;
  /** The project */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of AddProjectV2DraftIssue */
export type Github_AddProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Project to add the draft issue to. */
  projectId: Scalars['ID'];
  /**
   * The title of the draft issue. A project item can also be created by providing
   * the URL of an Issue or Pull Request if you have access.
   */
  title: Scalars['String'];
};

/** Autogenerated return type of AddProjectV2DraftIssue */
export type Github_AddProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The draft issue added to the project. */
  projectItem?: Maybe<Github_ProjectV2Item>;
};

/** Autogenerated input type of AddProjectV2ItemById */
export type Github_AddProjectV2ItemByIdInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the Issue or Pull Request to add. */
  contentId: Scalars['ID'];
  /** The ID of the Project to add the item to. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectV2ItemById */
export type Github_AddProjectV2ItemByIdPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item added to the project. */
  item?: Maybe<Github_ProjectV2Item>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type Github_AddPullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The SHA of the commit to comment on. */
  commitOID?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The comment id to reply to. */
  inReplyTo?: InputMaybe<Scalars['ID']>;
  /** The relative path of the file to comment on. */
  path?: InputMaybe<Scalars['String']>;
  /** The line index in the diff to comment on. */
  position?: InputMaybe<Scalars['Int']>;
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type Github_AddPullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<Github_PullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<Github_PullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
export type Github_AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The review line comments. */
  comments?: InputMaybe<Array<InputMaybe<Github_DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The event to perform on the pull request review. */
  event?: InputMaybe<Github_PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The review line comment threads. */
  threads?: InputMaybe<Array<InputMaybe<Github_DraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview */
export type Github_AddPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<Github_PullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type Github_AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<Github_DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<Github_DiffSide>;
};

/** Autogenerated return type of AddPullRequestReviewThread */
export type Github_AddPullRequestReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created thread. */
  thread?: Maybe<Github_PullRequestReviewThread>;
};

/** Autogenerated input type of AddReaction */
export type Github_AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the emoji to react with. */
  content: Github_ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddReaction */
export type Github_AddReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reaction object. */
  reaction?: Maybe<Github_Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<Github_Reactable>;
};

/** Autogenerated input type of AddStar */
export type Github_AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID'];
};

/** Autogenerated return type of AddStar */
export type Github_AddStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The starrable. */
  starrable?: Maybe<Github_Starrable>;
};

/** Autogenerated input type of AddUpvote */
export type Github_AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddUpvote */
export type Github_AddUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The votable subject. */
  subject?: Maybe<Github_Votable>;
};

/** Autogenerated input type of AddVerifiableDomain */
export type Github_AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The URL of the domain */
  domain: Scalars['Github_URI'];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars['ID'];
};

/** Autogenerated return type of AddVerifiableDomain */
export type Github_AddVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verifiable domain that was added. */
  domain?: Maybe<Github_VerifiableDomain>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type Github_AddedToProjectEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<Github_ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Represents an announcement banner. */
export type Github_AnnouncementBanner = {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']>;
};

/** A GitHub App. */
export type Github_App = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the app. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The IP addresses of the app. */
  ipAllowListEntries: Github_IpAllowListEntryConnection;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'];
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars['Github_URI'];
  /** The name of the app. */
  name: Scalars['String'];
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The URL to the app's homepage. */
  url: Scalars['Github_URI'];
};


/** A GitHub App. */
export type Github_AppipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IpAllowListEntryOrder>;
};


/** A GitHub App. */
export type Github_ApplogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of ApproveDeployments */
export type Github_ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Optional comment for approving deployments */
  comment?: InputMaybe<Scalars['String']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID'];
};

/** Autogenerated return type of ApproveDeployments */
export type Github_ApproveDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Github_Deployment>>;
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type Github_ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars['ID'];
};

/** Autogenerated return type of ApproveVerifiableDomain */
export type Github_ApproveVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verifiable domain that was approved. */
  domain?: Maybe<Github_VerifiableDomain>;
};

/** Autogenerated input type of ArchiveProjectV2Item */
export type Github_ArchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the ProjectV2Item to archive. */
  itemId: Scalars['ID'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of ArchiveProjectV2Item */
export type Github_ArchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item archived from the project. */
  item?: Maybe<Github_ProjectV2Item>;
};

/** Autogenerated input type of ArchiveRepository */
export type Github_ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of ArchiveRepository */
export type Github_ArchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was marked as archived. */
  repository?: Maybe<Github_Repository>;
};

/** An object that can have users assigned to it. */
export type Github_Assignable = {
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
};


/** An object that can have users assigned to it. */
export type Github_AssignableassigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an 'assigned' event on any assignable object. */
export type Github_AssignedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Github_Assignable;
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<Github_Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<Github_User>;
};

/** Types that can be assigned to issues. */
export type Github_Assignee = Github_Bot | Github_Mannequin | Github_Organization | Github_User;

/** An entry in the audit log. */
export type Github_AuditEntry = {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Types that can initiate an audit log event. */
export type Github_AuditEntryActor = Github_Bot | Github_Organization | Github_User;

/** Ordering options for Audit Log connections. */
export type Github_AuditLogOrder = {
  /** The ordering direction. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: InputMaybe<Github_AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export type Github_AuditLogOrderField =
  /** Order audit log entries by timestamp */
  | 'CREATED_AT';

/** Represents a 'auto_merge_disabled' event on a given pull request. */
export type Github_AutoMergeDisabledEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who disabled auto-merge for this Pull Request */
  disabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event */
  pullRequest?: Maybe<Github_PullRequest>;
  /** The reason auto-merge was disabled */
  reason?: Maybe<Scalars['String']>;
  /** The reason_code relating to why auto-merge was disabled */
  reasonCode?: Maybe<Scalars['String']>;
};

/** Represents a 'auto_merge_enabled' event on a given pull request. */
export type Github_AutoMergeEnabledEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who enabled auto-merge for this Pull Request */
  enabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents an auto-merge request for a pull request */
export type Github_AutoMergeRequest = {
  /** The email address of the author of this auto-merge request. */
  authorEmail?: Maybe<Scalars['String']>;
  /**
   * The commit message of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  commitBody?: Maybe<Scalars['String']>;
  /**
   * The commit title of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging
   */
  commitHeadline?: Maybe<Scalars['String']>;
  /** When was this auto-merge request was enabled. */
  enabledAt?: Maybe<Scalars['DateTime']>;
  /** The actor who created the auto-merge request. */
  enabledBy?: Maybe<Github_Actor>;
  /**
   * The merge method of the auto-merge request. If a merge queue is required by
   * the base branch, this value will be set by the merge queue when merging.
   */
  mergeMethod: Github_PullRequestMergeMethod;
  /** The pull request that this auto-merge request is set against. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'auto_rebase_enabled' event on a given pull request. */
export type Github_AutoRebaseEnabledEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who enabled auto-merge (rebase) for this Pull Request */
  enabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'auto_squash_enabled' event on a given pull request. */
export type Github_AutoSquashEnabledEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who enabled auto-merge (squash) for this Pull Request */
  enabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
export type Github_AutomaticBaseChangeFailedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The new base for this PR */
  newBase: Scalars['String'];
  /** The old base for this PR */
  oldBase: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
export type Github_AutomaticBaseChangeSucceededEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The new base for this PR */
  newBase: Scalars['String'];
  /** The old base for this PR */
  oldBase: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type Github_BaseRefChangedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the name of the base ref for the pull request after it was changed. */
  currentRefName: Scalars['String'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Identifies the name of the base ref for the pull request before it was changed. */
  previousRefName: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'base_ref_deleted' event on a given pull request. */
export type Github_BaseRefDeletedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */
  baseRefName?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type Github_BaseRefForcePushedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<Github_Commit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<Github_Ref>;
};

/** Represents a Git blame. */
export type Github_Blame = {
  /** The list of ranges from a Git blame. */
  ranges: Array<Github_BlameRange>;
};

/** Represents a range of information from a Git blame. */
export type Github_BlameRange = {
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  age: Scalars['Int'];
  /** Identifies the line author */
  commit: Github_Commit;
  /** The ending line for the range */
  endingLine: Scalars['Int'];
  /** The starting line for the range */
  startingLine: Scalars['Int'];
};

/** Represents a Git blob. */
export type Github_Blob = Github_GitObject & Github_Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** Byte size of Blob object */
  byteSize: Scalars['Int'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */
  isBinary?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the contents is truncated */
  isTruncated: Scalars['Boolean'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
  /** UTF8 text data or null if the Blob is binary */
  text?: Maybe<Scalars['String']>;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Github_Bot = Github_Actor & Github_Node & Github_UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this bot */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this bot */
  url: Scalars['Github_URI'];
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Github_BotavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Types which can be actors for `BranchActorAllowance` objects. */
export type Github_BranchActorAllowanceActor = Github_App | Github_Team | Github_User;

/** A branch protection rule. */
export type Github_BranchProtectionRule = Github_Node & {
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean'];
  /** Is branch creation a protected operation. */
  blocksCreations: Scalars['Boolean'];
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: Github_BranchProtectionRuleConflictConnection;
  /** A list of actors able to force push for this branch protection rule. */
  bypassForcePushAllowances: Github_BypassForcePushAllowanceConnection;
  /** A list of actors able to bypass PRs for this branch protection rule. */
  bypassPullRequestAllowances: Github_BypassPullRequestAllowanceConnection;
  /** The actor who created this branch protection rule. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Can admins overwrite branch protection. */
  isAdminEnforced: Scalars['Boolean'];
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge: Scalars['Boolean'];
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch: Scalars['Boolean'];
  /** Repository refs that are protected by this rule */
  matchingRefs: Github_RefConnection;
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String'];
  /** A list push allowances for this branch protection rule. */
  pushAllowances: Github_PushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<Github_Repository>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval: Scalars['Boolean'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** List of required status checks that must pass for commits to be accepted to matching branches. */
  requiredStatusChecks?: Maybe<Array<Github_RequiredStatusCheckDescription>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars['Boolean'];
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean'];
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars['Boolean'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean'];
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars['Boolean'];
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars['Boolean'];
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars['Boolean'];
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars['Boolean'];
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: Github_ReviewDismissalAllowanceConnection;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulebranchProtectionRuleConflictsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulebypassForcePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulebypassPullRequestAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulematchingRefsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulepushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulereviewDismissalAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A conflict between two branch protection rules. */
export type Github_BranchProtectionRuleConflict = {
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<Github_Ref>;
};

/** The connection type for BranchProtectionRuleConflict. */
export type Github_BranchProtectionRuleConflictConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BranchProtectionRuleConflictEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
export type Github_BranchProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BranchProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BranchProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BranchProtectionRule>;
};

/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */
export type Github_BypassForcePushAllowance = Github_Node & {
  /** The actor that can force push. */
  actor?: Maybe<Github_BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** The connection type for BypassForcePushAllowance. */
export type Github_BypassForcePushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BypassForcePushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BypassForcePushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BypassForcePushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BypassForcePushAllowance>;
};

/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */
export type Github_BypassPullRequestAllowance = Github_Node & {
  /** The actor that can bypass. */
  actor?: Maybe<Github_BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** The connection type for BypassPullRequestAllowance. */
export type Github_BypassPullRequestAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BypassPullRequestAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BypassPullRequestAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BypassPullRequestAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BypassPullRequestAllowance>;
};

/** The Common Vulnerability Scoring System */
export type Github_CVSS = {
  /** The CVSS score associated with this advisory */
  score: Scalars['Float'];
  /** The CVSS vector string associated with this advisory */
  vectorString?: Maybe<Scalars['String']>;
};

/** A common weakness enumeration */
export type Github_CWE = Github_Node & {
  /** The id of the CWE */
  cweId: Scalars['String'];
  /** A detailed description of this CWE */
  description: Scalars['String'];
  id: Scalars['ID'];
  /** The name of this CWE */
  name: Scalars['String'];
};

/** The connection type for CWE. */
export type Github_CWEConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CWEEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CWE>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CWEEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CWE>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type Github_CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
export type Github_CancelEnterpriseAdminInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The invitation that was canceled. */
  invitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CancelSponsorship */
export type Github_CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CancelSponsorship */
export type Github_CancelSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The tier that was being used at the time of cancellation. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
};

/** Autogenerated input type of ChangeUserStatus */
export type Github_ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: InputMaybe<Scalars['String']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: InputMaybe<Scalars['DateTime']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: InputMaybe<Scalars['Boolean']>;
  /** A short description of your current status. */
  message?: InputMaybe<Scalars['String']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of ChangeUserStatus */
export type Github_ChangeUserStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Your updated status. */
  status?: Maybe<Github_UserStatus>;
};

/** A single check annotation. */
export type Github_CheckAnnotation = {
  /** The annotation's severity level. */
  annotationLevel?: Maybe<Github_CheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  blobUrl: Scalars['Github_URI'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The position of this annotation. */
  location: Github_CheckAnnotationSpan;
  /** The annotation's message. */
  message: Scalars['String'];
  /** The path that this annotation was made on. */
  path: Scalars['String'];
  /** Additional information about the annotation. */
  rawDetails?: Maybe<Scalars['String']>;
  /** The annotation's title */
  title?: Maybe<Scalars['String']>;
};

/** The connection type for CheckAnnotation. */
export type Github_CheckAnnotationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Information from a check run analysis to specific lines of code. */
export type Github_CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: Github_CheckAnnotationLevel;
  /** The location of the annotation */
  location: Github_CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String'];
  /** Details about this annotation. */
  rawDetails?: InputMaybe<Scalars['String']>;
  /** The title that represents the annotation. */
  title?: InputMaybe<Scalars['String']>;
};

/** An edge in a connection. */
export type Github_CheckAnnotationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckAnnotation>;
};

/** Represents an annotation's information level. */
export type Github_CheckAnnotationLevel =
  /** An annotation indicating an inescapable error. */
  | 'FAILURE'
  /** An annotation indicating some information. */
  | 'NOTICE'
  /** An annotation indicating an ignorable error. */
  | 'WARNING';

/** A character position in a check annotation. */
export type Github_CheckAnnotationPosition = {
  /** Column number (1 indexed). */
  column?: Maybe<Scalars['Int']>;
  /** Line number (1 indexed). */
  line: Scalars['Int'];
};

/** Information from a check run analysis to specific lines of code. */
export type Github_CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: InputMaybe<Scalars['Int']>;
  /** The ending line of the range. */
  endLine: Scalars['Int'];
  /** The starting column of the range. */
  startColumn?: InputMaybe<Scalars['Int']>;
  /** The starting line of the range. */
  startLine: Scalars['Int'];
};

/** An inclusive pair of positions for a check annotation. */
export type Github_CheckAnnotationSpan = {
  /** End position (inclusive). */
  end: Github_CheckAnnotationPosition;
  /** Start position (inclusive). */
  start: Github_CheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
export type Github_CheckConclusionState =
  /** The check suite or run requires action. */
  | 'ACTION_REQUIRED'
  /** The check suite or run has been cancelled. */
  | 'CANCELLED'
  /** The check suite or run has failed. */
  | 'FAILURE'
  /** The check suite or run was neutral. */
  | 'NEUTRAL'
  /** The check suite or run was skipped. */
  | 'SKIPPED'
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  | 'STALE'
  /** The check suite or run has failed at startup. */
  | 'STARTUP_FAILURE'
  /** The check suite or run has succeeded. */
  | 'SUCCESS'
  /** The check suite or run has timed out. */
  | 'TIMED_OUT';

/** A check run. */
export type Github_CheckRun = Github_Node & Github_RequirableByPullRequest & Github_UniformResourceLocatable & {
  /** The check run's annotations */
  annotations?: Maybe<Github_CheckAnnotationConnection>;
  /** The check suite that this run is a part of. */
  checkSuite: Github_CheckSuite;
  /** Identifies the date and time when the check run was completed. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The conclusion of the check run. */
  conclusion?: Maybe<Github_CheckConclusionState>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The corresponding deployment for this job, if any */
  deployment?: Maybe<Github_Deployment>;
  /** The URL from which to find full details of the check run on the integrator's site. */
  detailsUrl?: Maybe<Scalars['Github_URI']>;
  /** A reference for the check run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
  /** The name of the check for this check run. */
  name: Scalars['String'];
  /** Information about a pending deployment, if any, in this check run */
  pendingDeploymentRequest?: Maybe<Github_DeploymentRequest>;
  /** The permalink to the check run summary. */
  permalink: Scalars['Github_URI'];
  /** The repository associated with this check run. */
  repository: Github_Repository;
  /** The HTTP path for this check run. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the check run was started. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status of the check run. */
  status: Github_CheckStatusState;
  /** The check run's steps */
  steps?: Maybe<Github_CheckStepConnection>;
  /** A string representing the check run's summary */
  summary?: Maybe<Scalars['String']>;
  /** A string representing the check run's text */
  text?: Maybe<Scalars['String']>;
  /** A string representing the check run */
  title?: Maybe<Scalars['String']>;
  /** The HTTP URL for this check run. */
  url: Scalars['Github_URI'];
};


/** A check run. */
export type Github_CheckRunannotationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A check run. */
export type Github_CheckRunisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};


/** A check run. */
export type Github_CheckRunstepsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  number?: InputMaybe<Scalars['Int']>;
};

/** Possible further actions the integrator can perform. */
export type Github_CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String'];
};

/** The connection type for CheckRun. */
export type Github_CheckRunConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckRun>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CheckRunEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckRun>;
};

/** The filters that are available when fetching check runs. */
export type Github_CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: InputMaybe<Scalars['Int']>;
  /** Filters the check runs by this name. */
  checkName?: InputMaybe<Scalars['String']>;
  /** Filters the check runs by this type. */
  checkType?: InputMaybe<Github_CheckRunType>;
  /** Filters the check runs by these conclusions. */
  conclusions?: InputMaybe<Array<Github_CheckConclusionState>>;
  /** Filters the check runs by this status. Superceded by statuses. */
  status?: InputMaybe<Github_CheckStatusState>;
  /** Filters the check runs by this status. Overrides status. */
  statuses?: InputMaybe<Array<Github_CheckStatusState>>;
};

/** Descriptive details about the check run. */
export type Github_CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: InputMaybe<Array<Github_CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: InputMaybe<Array<Github_CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String'];
  /** The details of the check run (supports Commonmark). */
  text?: InputMaybe<Scalars['String']>;
  /** A title to provide for this check run. */
  title: Scalars['String'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type Github_CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String'];
  /** A short image description. */
  caption?: InputMaybe<Scalars['String']>;
  /** The full URL of the image. */
  imageUrl: Scalars['Github_URI'];
};

/** The possible states of a check run in a status rollup. */
export type Github_CheckRunState =
  /** The check run requires action. */
  | 'ACTION_REQUIRED'
  /** The check run has been cancelled. */
  | 'CANCELLED'
  /** The check run has been completed. */
  | 'COMPLETED'
  /** The check run has failed. */
  | 'FAILURE'
  /** The check run is in progress. */
  | 'IN_PROGRESS'
  /** The check run was neutral. */
  | 'NEUTRAL'
  /** The check run is in pending state. */
  | 'PENDING'
  /** The check run has been queued. */
  | 'QUEUED'
  /** The check run was skipped. */
  | 'SKIPPED'
  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */
  | 'STALE'
  /** The check run has failed at startup. */
  | 'STARTUP_FAILURE'
  /** The check run has succeeded. */
  | 'SUCCESS'
  /** The check run has timed out. */
  | 'TIMED_OUT'
  /** The check run is in waiting state. */
  | 'WAITING';

/** Represents a count of the state of a check run. */
export type Github_CheckRunStateCount = {
  /** The number of check runs with this state. */
  count: Scalars['Int'];
  /** The state of a check run. */
  state: Github_CheckRunState;
};

/** The possible types of check runs. */
export type Github_CheckRunType =
  /** Every check run available. */
  | 'ALL'
  /** The latest check run. */
  | 'LATEST';

/** The possible states for a check suite or run status. */
export type Github_CheckStatusState =
  /** The check suite or run has been completed. */
  | 'COMPLETED'
  /** The check suite or run is in progress. */
  | 'IN_PROGRESS'
  /** The check suite or run is in pending state. */
  | 'PENDING'
  /** The check suite or run has been queued. */
  | 'QUEUED'
  /** The check suite or run has been requested. */
  | 'REQUESTED'
  /** The check suite or run is in waiting state. */
  | 'WAITING';

/** A single check step. */
export type Github_CheckStep = {
  /** Identifies the date and time when the check step was completed. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The conclusion of the check step. */
  conclusion?: Maybe<Github_CheckConclusionState>;
  /** A reference for the check step on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  /** The step's name. */
  name: Scalars['String'];
  /** The index of the step in the list of steps of the parent check run. */
  number: Scalars['Int'];
  /** Number of seconds to completion. */
  secondsToCompletion?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the check step was started. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status of the check step. */
  status: Github_CheckStatusState;
};

/** The connection type for CheckStep. */
export type Github_CheckStepConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckStepEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckStep>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CheckStepEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckStep>;
};

/** A check suite. */
export type Github_CheckSuite = Github_Node & {
  /** The GitHub App which created this check suite. */
  app?: Maybe<Github_App>;
  /** The name of the branch for this check suite. */
  branch?: Maybe<Github_Ref>;
  /** The check runs associated with a check suite. */
  checkRuns?: Maybe<Github_CheckRunConnection>;
  /** The commit for this check suite */
  commit: Github_Commit;
  /** The conclusion of this check suite. */
  conclusion?: Maybe<Github_CheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who triggered the check suite. */
  creator?: Maybe<Github_User>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of open pull requests matching the check suite. */
  matchingPullRequests?: Maybe<Github_PullRequestConnection>;
  /** The push that triggered this check suite. */
  push?: Maybe<Github_Push>;
  /** The repository associated with this check suite. */
  repository: Github_Repository;
  /** The HTTP path for this check suite */
  resourcePath: Scalars['Github_URI'];
  /** The status of this check suite. */
  status: Github_CheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this check suite */
  url: Scalars['Github_URI'];
  /** The workflow run associated with this check suite. */
  workflowRun?: Maybe<Github_WorkflowRun>;
};


/** A check suite. */
export type Github_CheckSuitecheckRunsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_CheckRunFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A check suite. */
export type Github_CheckSuitematchingPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
export type Github_CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean'];
};

/** The connection type for CheckSuite. */
export type Github_CheckSuiteConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckSuiteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckSuite>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CheckSuiteEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckSuite>;
};

/** The filters that are available when fetching check suites. */
export type Github_CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: InputMaybe<Scalars['Int']>;
  /** Filters the check suites by this name. */
  checkName?: InputMaybe<Scalars['String']>;
};

/** An object which can have its data claimed or claim data from another. */
export type Github_Claimable = Github_Mannequin | Github_User;

/** Autogenerated input type of ClearLabelsFromLabelable */
export type Github_ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of ClearLabelsFromLabelable */
export type Github_ClearLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was unlabeled. */
  labelable?: Maybe<Github_Labelable>;
};

/** Autogenerated input type of ClearProjectV2ItemFieldValue */
export type Github_ClearProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the field to be cleared. */
  fieldId: Scalars['ID'];
  /** The ID of the item to be cleared. */
  itemId: Scalars['ID'];
  /** The ID of the Project. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of ClearProjectV2ItemFieldValue */
export type Github_ClearProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated item. */
  projectV2Item?: Maybe<Github_ProjectV2Item>;
};

/** Autogenerated input type of CloneProject */
export type Github_CloneProjectInput = {
  /** The description of the project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean'];
  /** The name of the project. */
  name: Scalars['String'];
  /** The visibility of the project, defaults to false (private). */
  public?: InputMaybe<Scalars['Boolean']>;
  /** The source project to clone. */
  sourceId: Scalars['ID'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID'];
};

/** Autogenerated return type of CloneProject */
export type Github_CloneProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars['String']>;
  /** The new cloned project. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of CloneTemplateRepository */
export type Github_CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: InputMaybe<Scalars['Boolean']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID'];
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository */
export type Github_CloneTemplateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository. */
  repository?: Maybe<Github_Repository>;
};

/** An object that can be closed */
export type Github_Closable = {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
};

/** Autogenerated input type of CloseIssue */
export type Github_CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID'];
  /** The reason the issue is to be closed. */
  stateReason?: InputMaybe<Github_IssueClosedStateReason>;
};

/** Autogenerated return type of CloseIssue */
export type Github_CloseIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was closed. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of ClosePullRequest */
export type Github_ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ClosePullRequest */
export type Github_ClosePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was closed. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
export type Github_ClosedEvent = Github_Node & Github_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Object that was closed. */
  closable: Github_Closable;
  /** Object which triggered the creation of this event. */
  closer?: Maybe<Github_Closer>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The HTTP path for this closed event. */
  resourcePath: Scalars['Github_URI'];
  /** The reason the issue state was changed to closed. */
  stateReason?: Maybe<Github_IssueStateReason>;
  /** The HTTP URL for this closed event. */
  url: Scalars['Github_URI'];
};

/** The object which triggered a `ClosedEvent`. */
export type Github_Closer = Github_Commit | Github_PullRequest;

/** The Code of Conduct for a repository */
export type Github_CodeOfConduct = Github_Node & {
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The key for the Code of Conduct */
  key: Scalars['String'];
  /** The formal name of the Code of Conduct */
  name: Scalars['String'];
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars['Github_URI']>;
};

/** Collaborators affiliation level with a subject. */
export type Github_CollaboratorAffiliation =
  /** All collaborators the authenticated user can see. */
  | 'ALL'
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  | 'DIRECT'
  /** All outside collaborators of an organization-owned subject. */
  | 'OUTSIDE';

/** Represents a comment. */
export type Github_Comment = {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment. */
export type Github_CommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A comment author association with repository. */
export type Github_CommentAuthorAssociation =
  /** Author has been invited to collaborate on the repository. */
  | 'COLLABORATOR'
  /** Author has previously committed to the repository. */
  | 'CONTRIBUTOR'
  /** Author has not previously committed to GitHub. */
  | 'FIRST_TIMER'
  /** Author has not previously committed to the repository. */
  | 'FIRST_TIME_CONTRIBUTOR'
  /** Author is a placeholder for an unclaimed user. */
  | 'MANNEQUIN'
  /** Author is a member of the organization that owns the repository. */
  | 'MEMBER'
  /** Author has no association with the repository. */
  | 'NONE'
  /** Author is the owner of the repository. */
  | 'OWNER';

/** The possible errors that will prevent a user from updating a comment. */
export type Github_CommentCannotUpdateReason =
  /** Unable to create comment because repository is archived. */
  | 'ARCHIVED'
  /** You cannot update this comment */
  | 'DENIED'
  /** You must be the author or have write access to this repository to update this comment. */
  | 'INSUFFICIENT_ACCESS'
  /** Unable to create comment because issue is locked. */
  | 'LOCKED'
  /** You must be logged in to update this comment. */
  | 'LOGIN_REQUIRED'
  /** Repository is under maintenance. */
  | 'MAINTENANCE'
  /** At least one email address must be verified to update this comment. */
  | 'VERIFIED_EMAIL_REQUIRED';

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type Github_CommentDeletedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The user who authored the deleted comment. */
  deletedCommentAuthor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
};

/** Represents a Git commit. */
export type Github_Commit = Github_GitObject & Github_Node & Github_Subscribable & Github_UniformResourceLocatable & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The number of additions in this commit. */
  additions: Scalars['Int'];
  /**
   * The merged Pull Request that introduced the commit to the repository. If the
   * commit is not present in the default branch, additionally returns open Pull
   * Requests associated with the commit
   */
  associatedPullRequests?: Maybe<Github_PullRequestConnection>;
  /** Authorship details of the commit. */
  author?: Maybe<Github_GitActor>;
  /** Check if the committer and the author match. */
  authoredByCommitter: Scalars['Boolean'];
  /** The datetime when this commit was authored. */
  authoredDate: Scalars['DateTime'];
  /**
   * The list of authors for this commit based on the git author and the Co-authored-by
   * message trailer. The git author will always be first.
   */
  authors: Github_GitActorConnection;
  /** Fetches `git blame` information. */
  blame: Github_Blame;
  /**
   * We recommend using the `changedFielsIfAvailable` field instead of
   * `changedFiles`, as `changedFiles` will cause your request to return an error
   * if GitHub is unable to calculate the number of changed files.
   * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.
   */
  changedFiles: Scalars['Int'];
  /**
   * The number of changed files in this commit. If GitHub is unable to calculate
   * the number of changed files (for example due to a timeout), this will return
   * `null`. We recommend using this field instead of `changedFiles`.
   */
  changedFilesIfAvailable?: Maybe<Scalars['Int']>;
  /** The check suites associated with a commit. */
  checkSuites?: Maybe<Github_CheckSuiteConnection>;
  /** Comments made on the commit. */
  comments: Github_CommitCommentConnection;
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  /** The datetime when this commit was committed. */
  committedDate: Scalars['DateTime'];
  /** Check if committed via GitHub web UI. */
  committedViaWeb: Scalars['Boolean'];
  /** Committer details of the commit. */
  committer?: Maybe<Github_GitActor>;
  /** The number of deletions in this commit. */
  deletions: Scalars['Int'];
  /** The deployments associated with a commit. */
  deployments?: Maybe<Github_DeploymentConnection>;
  /** The tree entry representing the file located at the given path. */
  file?: Maybe<Github_TreeEntry>;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: Github_CommitHistoryConnection;
  id: Scalars['ID'];
  /** The Git commit message */
  message: Scalars['String'];
  /** The Git commit message body */
  messageBody: Scalars['String'];
  /** The commit message body rendered to HTML. */
  messageBodyHTML: Scalars['Github_HTML'];
  /** The Git commit message headline */
  messageHeadline: Scalars['String'];
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: Scalars['Github_HTML'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The organization this commit was made on behalf of. */
  onBehalfOf?: Maybe<Github_Organization>;
  /** The parents of a commit. */
  parents: Github_CommitConnection;
  /** The datetime when this commit was pushed. */
  pushedDate?: Maybe<Scalars['DateTime']>;
  /** The Repository this commit belongs to */
  repository: Github_Repository;
  /** The HTTP path for this commit */
  resourcePath: Scalars['Github_URI'];
  /** Commit signing information, if present. */
  signature?: Maybe<Github_GitSignature>;
  /** Status information for this commit */
  status?: Maybe<Github_Status>;
  /** Check and Status rollup information for this commit. */
  statusCheckRollup?: Maybe<Github_StatusCheckRollup>;
  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
  submodules: Github_SubmoduleConnection;
  /**
   * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  tarballUrl: Scalars['Github_URI'];
  /** Commit's root Tree */
  tree: Github_Tree;
  /** The HTTP path for the tree of this commit */
  treeResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the tree of this commit */
  treeUrl: Scalars['Github_URI'];
  /** The HTTP URL for this commit */
  url: Scalars['Github_URI'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
  /**
   * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  zipballUrl: Scalars['Github_URI'];
};


/** Represents a Git commit. */
export type Github_CommitassociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PullRequestOrder>;
};


/** Represents a Git commit. */
export type Github_CommitauthorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitblameArgs = {
  path: Scalars['String'];
};


/** Represents a Git commit. */
export type Github_CommitcheckSuitesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_CheckSuiteFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitdeploymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  environments?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DeploymentOrder>;
};


/** Represents a Git commit. */
export type Github_CommitfileArgs = {
  path: Scalars['String'];
};


/** Represents a Git commit. */
export type Github_CommithistoryArgs = {
  after?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Github_CommitAuthor>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  path?: InputMaybe<Scalars['String']>;
  since?: InputMaybe<Scalars['Github_GitTimestamp']>;
  until?: InputMaybe<Scalars['Github_GitTimestamp']>;
};


/** Represents a Git commit. */
export type Github_CommitparentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitsubmodulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Specifies an author for filtering Git commits. */
export type Github_CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: InputMaybe<Array<Scalars['String']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: InputMaybe<Scalars['ID']>;
};

/** Represents a comment on a given Commit. */
export type Github_CommitComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies the file path associated with the comment. */
  path?: Maybe<Scalars['String']>;
  /** Identifies the line position associated with the comment. */
  position?: Maybe<Scalars['Int']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path permalink for this commit comment. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this commit comment. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on a given Commit. */
export type Github_CommitCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** Represents a comment on a given Commit. */
export type Github_CommitCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CommitComment. */
export type Github_CommitCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CommitComment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CommitCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CommitComment>;
};

/** A thread of comments on a commit. */
export type Github_CommitCommentThread = Github_Node & Github_RepositoryNode & {
  /** The comments that exist in this thread. */
  comments: Github_CommitCommentConnection;
  /** The commit the comments were made on. */
  commit?: Maybe<Github_Commit>;
  id: Scalars['ID'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>;
  /** The repository associated with this node. */
  repository: Github_Repository;
};


/** A thread of comments on a commit. */
export type Github_CommitCommentThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Commit. */
export type Github_CommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Ordering options for commit contribution connections. */
export type Github_CommitContributionOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field by which to order commit contributions. */
  field: Github_CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export type Github_CommitContributionOrderField =
  /** Order commit contributions by how many commits they represent. */
  | 'COMMIT_COUNT'
  /** Order commit contributions by when they were made. */
  | 'OCCURRED_AT';

/** This aggregates commits made by a user within one repository. */
export type Github_CommitContributionsByRepository = {
  /** The commit contributions, each representing a day. */
  contributions: Github_CreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  repository: Github_Repository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars['Github_URI'];
};


/** This aggregates commits made by a user within one repository. */
export type Github_CommitContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_CommitContributionOrder>;
};

/** An edge in a connection. */
export type Github_CommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Commit>;
};

/** The connection type for Commit. */
export type Github_CommitHistoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A message to include with a new commit */
export type Github_CommitMessage = {
  /** The body of the message. */
  body?: InputMaybe<Scalars['String']>;
  /** The headline of the message. */
  headline: Scalars['String'];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * `repositoryNameWithOwner` and `branchName`.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using `repositoryNameWithOwner` and `branchName`:
 *
 *     {
 *       "repositoryNameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type Github_CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  branchName?: InputMaybe<Scalars['String']>;
  /** The Node ID of the Ref to be updated. */
  id?: InputMaybe<Scalars['ID']>;
  /** The nameWithOwner of the repository to commit to. */
  repositoryNameWithOwner?: InputMaybe<Scalars['String']>;
};

/** Represents a comparison between two commit revisions. */
export type Github_Comparison = Github_Node & {
  /** The number of commits ahead of the base branch. */
  aheadBy: Scalars['Int'];
  /** The base revision of this comparison. */
  baseTarget: Github_GitObject;
  /** The number of commits behind the base branch. */
  behindBy: Scalars['Int'];
  /** The commits which compose this comparison. */
  commits: Github_ComparisonCommitConnection;
  /** The head revision of this comparison. */
  headTarget: Github_GitObject;
  id: Scalars['ID'];
  /** The status of this comparison. */
  status: Github_ComparisonStatus;
};


/** Represents a comparison between two commit revisions. */
export type Github_ComparisoncommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Commit. */
export type Github_ComparisonCommitConnection = {
  /** The total count of authors and co-authors across all commits. */
  authorCount: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The status of a git comparison between two refs. */
export type Github_ComparisonStatus =
  /** The head ref is ahead of the base ref. */
  | 'AHEAD'
  /** The head ref is behind the base ref. */
  | 'BEHIND'
  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */
  | 'DIVERGED'
  /** The head ref and base ref are identical. */
  | 'IDENTICAL';

/** Represents a 'connected' event on a given issue or pull request. */
export type Github_ConnectedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Issue or pull request that made the reference. */
  source: Github_ReferencedSubject;
  /** Issue or pull request which was connected. */
  subject: Github_ReferencedSubject;
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type Github_Contribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** A calendar of contributions made on GitHub by a user. */
export type Github_ContributionCalendar = {
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars['String']>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars['Boolean'];
  /** A list of the months of contributions in this calendar. */
  months: Array<Github_ContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars['Int'];
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<Github_ContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
export type Github_ContributionCalendarDay = {
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars['String'];
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars['Int'];
  /**
   * Indication of contributions, relative to other days. Can be used to indicate
   * which color to represent this day on a calendar.
   */
  contributionLevel: Github_ContributionLevel;
  /** The day this square represents. */
  date: Scalars['Date'];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars['Int'];
};

/** A month of contributions in a user's contribution graph. */
export type Github_ContributionCalendarMonth = {
  /** The date of the first day of this month. */
  firstDay: Scalars['Date'];
  /** The name of the month. */
  name: Scalars['String'];
  /** How many weeks started in this month. */
  totalWeeks: Scalars['Int'];
  /** The year the month occurred in. */
  year: Scalars['Int'];
};

/** A week of contributions in a user's contribution graph. */
export type Github_ContributionCalendarWeek = {
  /** The days of contributions in this week. */
  contributionDays: Array<Github_ContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  firstDay: Scalars['Date'];
};

/** Varying levels of contributions from none to many. */
export type Github_ContributionLevel =
  /** Lowest 25% of days of contributions. */
  | 'FIRST_QUARTILE'
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  | 'FOURTH_QUARTILE'
  /** No contributions occurred. */
  | 'NONE'
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  | 'SECOND_QUARTILE'
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  | 'THIRD_QUARTILE';

/** Ordering options for contribution connections. */
export type Github_ContributionOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollection = {
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<Github_CommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: Github_ContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars['Int']>;
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars['Boolean'];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  earliestRestrictedContributionDate?: Maybe<Scalars['Date']>;
  /** The ending date and time of this collection. */
  endedAt: Scalars['DateTime'];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  firstIssueContribution?: Maybe<Github_CreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  firstPullRequestContribution?: Maybe<Github_CreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  firstRepositoryContribution?: Maybe<Github_CreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars['Boolean'];
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars['Boolean'];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  hasAnyRestrictedContributions: Scalars['Boolean'];
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars['Boolean'];
  /** A list of issues the user opened. */
  issueContributions: Github_CreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<Github_IssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  joinedGitHubContribution?: Maybe<Github_JoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  latestRestrictedContributionDate?: Maybe<Scalars['Date']>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  mostRecentCollectionWithActivity?: Maybe<Github_ContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  mostRecentCollectionWithoutActivity?: Maybe<Github_ContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  popularIssueContribution?: Maybe<Github_CreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  popularPullRequestContribution?: Maybe<Github_CreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  pullRequestContributions: Github_CreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<Github_PullRequestContributionsByRepository>;
  /**
   * Pull request review contributions made by the user. Returns the most recently
   * submitted review for each PR reviewed by the user.
   */
  pullRequestReviewContributions: Github_CreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<Github_PullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: Github_CreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  restrictedContributionsCount: Scalars['Int'];
  /** The beginning date and time of this collection. */
  startedAt: Scalars['DateTime'];
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars['Int'];
  /** How many issues the user opened. */
  totalIssueContributions: Scalars['Int'];
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars['Int'];
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars['Int'];
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars['Int'];
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars['Int'];
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int'];
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars['Int'];
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars['Int'];
  /** The user who made the contributions in this collection. */
  user: Github_User;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectioncommitContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionissueContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionissueContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionpullRequestContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionpullRequestContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionpullRequestReviewContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionpullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionrepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectiontotalIssueContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectiontotalPullRequestContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectiontotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectiontotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectiontotalRepositoryContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type Github_ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
export type Github_ConvertProjectCardNoteToIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<Github_ProjectCard>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type Github_ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ConvertPullRequestToDraft */
export type Github_ConvertPullRequestToDraftPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is now a draft. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
export type Github_ConvertToDraftEvent = Github_Node & Github_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this convert to draft event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this convert to draft event. */
  url: Scalars['Github_URI'];
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type Github_ConvertedNoteToIssueEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<Github_ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Represents a 'converted_to_discussion' event on a given issue. */
export type Github_ConvertedToDiscussionEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The discussion that the issue was converted into. */
  discussion?: Maybe<Github_Discussion>;
  id: Scalars['ID'];
};

/** Autogenerated input type of CopyProjectV2 */
export type Github_CopyProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Include draft issues in the new project */
  includeDraftIssues?: InputMaybe<Scalars['Boolean']>;
  /** The owner ID of the new project. */
  ownerId: Scalars['ID'];
  /** The ID of the source Project to copy. */
  projectId: Scalars['ID'];
  /** The title of the project. */
  title: Scalars['String'];
};

/** Autogenerated return type of CopyProjectV2 */
export type Github_CopyProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The copied project. */
  projectV2?: Maybe<Github_ProjectV2>;
};

/** Autogenerated input type of CreateAttributionInvitation */
export type Github_CreateAttributionInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the owner scoping the reattributable data. */
  ownerId: Scalars['ID'];
  /** The Node ID of the account owning the data to reattribute. */
  sourceId: Scalars['ID'];
  /** The Node ID of the account which may claim the data. */
  targetId: Scalars['ID'];
};

/** Autogenerated return type of CreateAttributionInvitation */
export type Github_CreateAttributionInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The owner scoping the reattributable data. */
  owner?: Maybe<Github_Organization>;
  /** The account owning the data to reattribute. */
  source?: Maybe<Github_Claimable>;
  /** The account which may claim the data. */
  target?: Maybe<Github_Claimable>;
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type Github_CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']>;
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String'];
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID'];
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<Github_RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of CreateBranchProtectionRule */
export type Github_CreateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckRun */
export type Github_CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<Github_CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<Github_CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['Github_URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['Github_GitObjectID'];
  /** The name of the check. */
  name: Scalars['String'];
  /** Descriptive details about the run. */
  output?: InputMaybe<Github_CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']>;
  /** The current status. */
  status?: InputMaybe<Github_RequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun */
export type Github_CreateCheckRunPayload = {
  /** The newly created check run. */
  checkRun?: Maybe<Github_CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckSuite */
export type Github_CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['Github_GitObjectID'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateCheckSuite */
export type Github_CreateCheckSuitePayload = {
  /** The newly created check suite. */
  checkSuite?: Maybe<Github_CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCommitOnBranch */
export type Github_CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  branch: Github_CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  expectedHeadOid: Scalars['Github_GitObjectID'];
  /** A description of changes to files in this commit. */
  fileChanges?: InputMaybe<Github_FileChanges>;
  /** The commit message the be included with the commit. */
  message: Github_CommitMessage;
};

/** Autogenerated return type of CreateCommitOnBranch */
export type Github_CreateCommitOnBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new commit. */
  commit?: Maybe<Github_Commit>;
  /** The ref which has been updated to point to the new commit. */
  ref?: Maybe<Github_Ref>;
};

/** Autogenerated input type of CreateDeployment */
export type Github_CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Short description of the deployment. */
  description?: InputMaybe<Scalars['String']>;
  /** Name for the target deployment environment. */
  environment?: InputMaybe<Scalars['String']>;
  /** JSON payload with extra information about the deployment. */
  payload?: InputMaybe<Scalars['String']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: InputMaybe<Array<Scalars['String']>>;
  /** Specifies a task to execute. */
  task?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateDeployment */
export type Github_CreateDeploymentPayload = {
  /** True if the default branch has been auto-merged into the deployment ref. */
  autoMerged?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new deployment. */
  deployment?: Maybe<Github_Deployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type Github_CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: InputMaybe<Scalars['String']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: InputMaybe<Scalars['String']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: InputMaybe<Scalars['String']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: InputMaybe<Scalars['String']>;
  /** The state of the deployment. */
  state: Github_DeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus */
export type Github_CreateDeploymentStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new deployment status. */
  deploymentStatus?: Maybe<Github_DeploymentStatus>;
};

/** Autogenerated input type of CreateDiscussion */
export type Github_CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars['String'];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateDiscussion */
export type Github_CreateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that was just created. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type Github_CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID'];
  /** The login of the new organization. */
  login: Scalars['String'];
  /** The profile name of the new organization. */
  profileName: Scalars['String'];
};

/** Autogenerated return type of CreateEnterpriseOrganization */
export type Github_CreateEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<Github_Enterprise>;
  /** The organization that was created. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of CreateEnvironment */
export type Github_CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the environment. */
  name: Scalars['String'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateEnvironment */
export type Github_CreateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new or existing environment. */
  environment?: Maybe<Github_Environment>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type Github_CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID'];
};

/** Autogenerated return type of CreateIpAllowListEntry */
export type Github_CreateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was created. */
  ipAllowListEntry?: Maybe<Github_IpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
export type Github_CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: InputMaybe<Scalars['String']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title for the issue. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateIssue */
export type Github_CreateIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new issue. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of CreateLabel */
export type Github_CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String'];
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the label. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateLabel */
export type Github_CreateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new label. */
  label?: Maybe<Github_Label>;
};

/** Autogenerated input type of CreateLinkedBranch */
export type Github_CreateLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue to link to. */
  issueId: Scalars['ID'];
  /** The name of the new branch. Defaults to issue number and title. */
  name?: InputMaybe<Scalars['String']>;
  /** The commit SHA to base the new branch on. */
  oid: Scalars['Github_GitObjectID'];
  /** ID of the repository to create the branch in. Defaults to the issue repository. */
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateLinkedBranch */
export type Github_CreateLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new branch issue reference. */
  linkedBranch?: Maybe<Github_LinkedBranch>;
};

/** Autogenerated input type of CreateMigrationSource */
export type Github_CreateMigrationSourceInput = {
  /** The migration source access token. */
  accessToken?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']>;
  /** The migration source name. */
  name: Scalars['String'];
  /** The ID of the organization that will own the migration source. */
  ownerId: Scalars['ID'];
  /** The migration source type. */
  type: Github_MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url: Scalars['String'];
};

/** Autogenerated return type of CreateMigrationSource */
export type Github_CreateMigrationSourcePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created migration source. */
  migrationSource?: Maybe<Github_MigrationSource>;
};

/** Autogenerated input type of CreateProject */
export type Github_CreateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of project. */
  name: Scalars['String'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The name of the GitHub-provided template. */
  template?: InputMaybe<Github_ProjectTemplate>;
};

/** Autogenerated return type of CreateProject */
export type Github_CreateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new project. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of CreateProjectV2 */
export type Github_CreateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID'];
  /** The repository to link the project to. */
  repositoryId?: InputMaybe<Scalars['ID']>;
  /** The team to link the project to. The team will be granted read permissions. */
  teamId?: InputMaybe<Scalars['ID']>;
  /** The title of the project. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateProjectV2 */
export type Github_CreateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new project. */
  projectV2?: Maybe<Github_ProjectV2>;
};

/** Autogenerated input type of CreatePullRequest */
export type Github_CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String'];
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String'];
  /** The Node ID of the head repository. */
  headRepositoryId?: InputMaybe<Scalars['ID']>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title of the pull request. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreatePullRequest */
export type Github_CreatePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of CreateRef */
export type Github_CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['Github_GitObjectID'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateRef */
export type Github_CreateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created ref. */
  ref?: Maybe<Github_Ref>;
};

/** Autogenerated input type of CreateRepository */
export type Github_CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: InputMaybe<Scalars['Github_URI']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId?: InputMaybe<Scalars['ID']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: InputMaybe<Scalars['ID']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']>;
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};

/** Autogenerated return type of CreateRepository */
export type Github_CreateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of CreateSponsorsListing */
export type Github_CreateSponsorsListingInput = {
  /**
   * The country or region where the sponsorable's bank account is located.
   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.
   */
  billingCountryOrRegionCode?: InputMaybe<Github_SponsorsCountryOrRegionCode>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * The email address we should use to contact you about the GitHub Sponsors
   * profile being created. This will not be shared publicly. Must be a verified
   * email address already on your GitHub account. Only relevant when the
   * sponsorable is yourself. Defaults to your primary email address on file if omitted.
   */
  contactEmail?: InputMaybe<Scalars['String']>;
  /**
   * The username of the supported fiscal host's GitHub organization, if you want
   * to receive sponsorship payouts through a fiscal host rather than directly to a
   * bank account. For example, 'Open-Source-Collective' for Open Source Collective
   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts
   * for more information.
   */
  fiscalHostLogin?: InputMaybe<Scalars['String']>;
  /**
   * The URL for your profile page on the fiscal host's website, e.g.,
   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.
   * Required if fiscalHostLogin is specified.
   */
  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']>;
  /**
   * Provide an introduction to serve as the main focus that appears on your GitHub
   * Sponsors profile. It's a great opportunity to help potential sponsors learn
   * more about you, your work, and why their sponsorship is important to you.
   * GitHub-flavored Markdown is supported.
   */
  fullDescription?: InputMaybe<Scalars['String']>;
  /**
   * The country or region where the sponsorable resides. This is for tax purposes.
   * Required if the sponsorable is yourself, ignored when sponsorableLogin
   * specifies an organization.
   */
  residenceCountryOrRegionCode?: InputMaybe<Github_SponsorsCountryOrRegionCode>;
  /**
   * The username of the organization to create a GitHub Sponsors profile for, if
   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated
   * user if omitted.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateSponsorsListing */
export type Github_CreateSponsorsListingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new GitHub Sponsors profile. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
};

/** Autogenerated input type of CreateSponsorsTier */
export type Github_CreateSponsorsTierInput = {
  /** The value of the new tier in US dollars. Valid values: 1-12000. */
  amount: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */
  description: Scalars['String'];
  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */
  isRecurring?: InputMaybe<Scalars['Boolean']>;
  /**
   * Whether to make the tier available immediately for sponsors to choose.
   * Defaults to creating a draft tier that will not be publicly visible.
   */
  publish?: InputMaybe<Scalars['Boolean']>;
  /**
   * Optional ID of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization.
   */
  repositoryId?: InputMaybe<Scalars['ID']>;
  /**
   * Optional name of the private repository that sponsors at this tier should gain
   * read-only access to. Must be owned by an organization. Necessary if
   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.
   */
  repositoryName?: InputMaybe<Scalars['String']>;
  /**
   * Optional login of the organization owner of the private repository that
   * sponsors at this tier should gain read-only access to. Necessary if
   * repositoryName is given. Will be ignored if repositoryId is given.
   */
  repositoryOwnerLogin?: InputMaybe<Scalars['String']>;
  /**
   * The ID of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableLogin is not given.
   */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who owns the GitHub Sponsors profile.
   * Defaults to the current user if omitted and sponsorableId is not given.
   */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
  /** Optional message new sponsors at this tier will receive. */
  welcomeMessage?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateSponsorsTier */
export type Github_CreateSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new tier. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
};

/** Autogenerated input type of CreateSponsorship */
export type Github_CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  amount?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  isRecurring?: InputMaybe<Scalars['Boolean']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<Github_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  tierId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateSponsorship */
export type Github_CreateSponsorshipPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The sponsorship that was started. */
  sponsorship?: Maybe<Github_Sponsorship>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type Github_CreateTeamDiscussionCommentInput = {
  /** The content of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the discussion to which the comment belongs. */
  discussionId: Scalars['ID'];
};

/** Autogenerated return type of CreateTeamDiscussionComment */
export type Github_CreateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new comment. */
  teamDiscussionComment?: Maybe<Github_TeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type Github_CreateTeamDiscussionInput = {
  /** The content of the discussion. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
   */
  private?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the team to which the discussion belongs. */
  teamId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateTeamDiscussion */
export type Github_CreateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new discussion. */
  teamDiscussion?: Maybe<Github_TeamDiscussion>;
};

/** Represents the contribution a user made by committing to a repository. */
export type Github_CreatedCommitContribution = Github_Contribution & {
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars['Int'];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The repository the user made a commit in. */
  repository: Github_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedCommitContribution. */
export type Github_CreatedCommitContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedCommitContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type Github_CreatedIssueContribution = Github_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** The issue that was opened. */
  issue: Github_Issue;
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedIssueContribution. */
export type Github_CreatedIssueContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedIssueContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type Github_CreatedIssueOrRestrictedContribution = Github_CreatedIssueContribution | Github_RestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type Github_CreatedPullRequestContribution = Github_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The pull request that was opened. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedPullRequestContribution. */
export type Github_CreatedPullRequestContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedPullRequestContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type Github_CreatedPullRequestOrRestrictedContribution = Github_CreatedPullRequestContribution | Github_RestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type Github_CreatedPullRequestReviewContribution = Github_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The pull request the user reviewed. */
  pullRequest: Github_PullRequest;
  /** The review the user left on the pull request. */
  pullRequestReview: Github_PullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  repository: Github_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type Github_CreatedPullRequestReviewContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedPullRequestReviewContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type Github_CreatedRepositoryContribution = Github_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The repository that was created. */
  repository: Github_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedRepositoryContribution. */
export type Github_CreatedRepositoryContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedRepositoryContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type Github_CreatedRepositoryOrRestrictedContribution = Github_CreatedRepositoryContribution | Github_RestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
export type Github_CrossReferencedEvent = Github_Node & Github_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Identifies when the reference was made. */
  referencedAt: Scalars['DateTime'];
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['Github_URI'];
  /** Issue or pull request that made the reference. */
  source: Github_ReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  target: Github_ReferencedSubject;
  /** The HTTP URL for this pull request. */
  url: Scalars['Github_URI'];
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: Scalars['Boolean'];
};

/** Autogenerated input type of DeclineTopicSuggestion */
export type Github_DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The reason why the suggested topic is declined. */
  reason: Github_TopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type Github_DeclineTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The declined topic. */
  topic?: Maybe<Github_Topic>;
};

/** The possible base permissions for repositories. */
export type Github_DefaultRepositoryPermissionField =
  /** Can read, write, and administrate repos by default */
  | 'ADMIN'
  /** No access */
  | 'NONE'
  /** Can read repos by default */
  | 'READ'
  /** Can read and write repos by default */
  | 'WRITE';

/** Entities that can be deleted. */
export type Github_Deletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type Github_DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteBranchProtectionRule */
export type Github_DeleteBranchProtectionRulePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDeployment */
export type Github_DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDeployment */
export type Github_DeleteDeploymentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDiscussionComment */
export type Github_DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDiscussionComment */
export type Github_DeleteDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion comment that was just deleted. */
  comment?: Maybe<Github_DiscussionComment>;
};

/** Autogenerated input type of DeleteDiscussion */
export type Github_DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the discussion to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDiscussion */
export type Github_DeleteDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that was just deleted. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of DeleteEnvironment */
export type Github_DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteEnvironment */
export type Github_DeleteEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type Github_DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID'];
};

/** Autogenerated return type of DeleteIpAllowListEntry */
export type Github_DeleteIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was deleted. */
  ipAllowListEntry?: Maybe<Github_IpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
export type Github_DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteIssueComment */
export type Github_DeleteIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteIssue */
export type Github_DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of DeleteIssue */
export type Github_DeleteIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository the issue belonged to */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of DeleteLabel */
export type Github_DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteLabel */
export type Github_DeleteLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteLinkedBranch */
export type Github_DeleteLinkedBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the linked branch */
  linkedBranchId: Scalars['ID'];
};

/** Autogenerated return type of DeleteLinkedBranch */
export type Github_DeleteLinkedBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue the linked branch was unlinked from. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of DeletePackageVersion */
export type Github_DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID'];
};

/** Autogenerated return type of DeletePackageVersion */
export type Github_DeletePackageVersionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the operation succeeded. */
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeleteProjectCard */
export type Github_DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteProjectCard */
export type Github_DeleteProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The column the deleted card was in. */
  column?: Maybe<Github_ProjectColumn>;
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type Github_DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProjectColumn */
export type Github_DeleteProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars['ID']>;
  /** The project the deleted column was in. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of DeleteProject */
export type Github_DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProject */
export type Github_DeleteProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository or organization the project was removed from. */
  owner?: Maybe<Github_ProjectOwner>;
};

/** Autogenerated input type of DeleteProjectV2 */
export type Github_DeleteProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Project to delete. */
  projectId: Scalars['ID'];
};

/** Autogenerated input type of DeleteProjectV2Item */
export type Github_DeleteProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the item to be removed. */
  itemId: Scalars['ID'];
  /** The ID of the Project from which the item should be removed. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProjectV2Item */
export type Github_DeleteProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted item. */
  deletedItemId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of DeleteProjectV2 */
export type Github_DeleteProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted Project. */
  projectV2?: Maybe<Github_ProjectV2>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type Github_DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePullRequestReviewComment */
export type Github_DeletePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
  /** The deleted pull request review comment. */
  pullRequestReviewComment?: Maybe<Github_PullRequestReviewComment>;
};

/** Autogenerated input type of DeletePullRequestReview */
export type Github_DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of DeletePullRequestReview */
export type Github_DeletePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
export type Github_DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID'];
};

/** Autogenerated return type of DeleteRef */
export type Github_DeleteRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type Github_DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
export type Github_DeleteTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type Github_DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The discussion ID to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteTeamDiscussion */
export type Github_DeleteTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type Github_DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteVerifiableDomain */
export type Github_DeleteVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The owning account from which the domain was deleted. */
  owner?: Maybe<Github_VerifiableDomainOwner>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type Github_DemilestonedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars['String'];
  /** Object referenced by event. */
  subject: Github_MilestoneItem;
};

/** A Dependabot Update for a dependency in a repository */
export type Github_DependabotUpdate = Github_RepositoryNode & {
  /** The error from a dependency update */
  error?: Maybe<Github_DependabotUpdateError>;
  /** The associated pull request */
  pullRequest?: Maybe<Github_PullRequest>;
  /** The repository associated with this node. */
  repository: Github_Repository;
};

/** An error produced from a Dependabot Update */
export type Github_DependabotUpdateError = {
  /** The body of the error */
  body: Scalars['String'];
  /** The error code */
  errorType: Scalars['String'];
  /** The title of the error */
  title: Scalars['String'];
};

/** A dependency manifest entry */
export type Github_DependencyGraphDependency = {
  /** Does the dependency itself have dependencies? */
  hasDependencies: Scalars['Boolean'];
  /**
   * The original name of the package, as it appears in the manifest.
   * @deprecated `packageLabel` will be removed. Use normalized `packageName` field instead. Removal on 2022-10-01 UTC.
   */
  packageLabel: Scalars['String'];
  /** The dependency package manager */
  packageManager?: Maybe<Scalars['String']>;
  /**
   * The name of the package in the canonical form used by the package manager.
   * This may differ from the original textual form (see packageLabel), for example
   * in a package manager that uses case-insensitive comparisons.
   */
  packageName: Scalars['String'];
  /** The repository containing the package */
  repository?: Maybe<Github_Repository>;
  /** The dependency version requirements */
  requirements: Scalars['String'];
};

/** The connection type for DependencyGraphDependency. */
export type Github_DependencyGraphDependencyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DependencyGraphDependencyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DependencyGraphDependency>;
};

/** The possible ecosystems of a dependency graph package. */
export type Github_DependencyGraphEcosystem =
  /** GitHub Actions */
  | 'ACTIONS'
  /** PHP packages hosted at packagist.org */
  | 'COMPOSER'
  /** Go modules */
  | 'GO'
  /** Java artifacts hosted at the Maven central repository */
  | 'MAVEN'
  /** JavaScript packages hosted at npmjs.com */
  | 'NPM'
  /** .NET packages hosted at the NuGet Gallery */
  | 'NUGET'
  /** Python packages hosted at PyPI.org */
  | 'PIP'
  /** Dart packages hosted at pub.dev */
  | 'PUB'
  /** Ruby gems hosted at RubyGems.org */
  | 'RUBYGEMS'
  /** Rust crates */
  | 'RUST';

/** Dependency manifest for a repository */
export type Github_DependencyGraphManifest = Github_Node & {
  /** Path to view the manifest file blob */
  blobPath: Scalars['String'];
  /** A list of manifest dependencies */
  dependencies?: Maybe<Github_DependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  dependenciesCount?: Maybe<Scalars['Int']>;
  /** Is the manifest too big to parse? */
  exceedsMaxSize: Scalars['Boolean'];
  /** Fully qualified manifest filename */
  filename: Scalars['String'];
  id: Scalars['ID'];
  /** Were we able to parse the manifest? */
  parseable: Scalars['Boolean'];
  /** The repository containing the manifest */
  repository: Github_Repository;
};


/** Dependency manifest for a repository */
export type Github_DependencyGraphManifestdependenciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DependencyGraphManifest. */
export type Github_DependencyGraphManifestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DependencyGraphManifestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DependencyGraphManifest>;
};

/** A repository deploy key. */
export type Github_DeployKey = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The deploy key. */
  key: Scalars['String'];
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars['Boolean'];
  /** The deploy key title. */
  title: Scalars['String'];
  /** Whether or not the deploy key has been verified. */
  verified: Scalars['Boolean'];
};

/** The connection type for DeployKey. */
export type Github_DeployKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeployKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
export type Github_DeployedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The deployment associated with the 'deployed' event. */
  deployment: Github_Deployment;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<Github_Ref>;
};

/** Represents triggered deployment instance. */
export type Github_Deployment = Github_Node & {
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who triggered the deployment. */
  creator: Github_Actor;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The deployment description. */
  description?: Maybe<Scalars['String']>;
  /** The latest environment to which this deployment was made. */
  environment?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The latest environment to which this deployment was made. */
  latestEnvironment?: Maybe<Scalars['String']>;
  /** The latest status of this deployment. */
  latestStatus?: Maybe<Github_DeploymentStatus>;
  /** The original environment to which this deployment was made. */
  originalEnvironment?: Maybe<Scalars['String']>;
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars['String']>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<Github_Ref>;
  /** Identifies the repository associated with the deployment. */
  repository: Github_Repository;
  /** The current state of the deployment. */
  state?: Maybe<Github_DeploymentState>;
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<Github_DeploymentStatusConnection>;
  /** The deployment task. */
  task?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** Represents triggered deployment instance. */
export type Github_DeploymentstatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Deployment. */
export type Github_DeploymentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Deployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type Github_DeploymentEnvironmentChangedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: Github_DeploymentStatus;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Ordering options for deployment connections */
export type Github_DeploymentOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order deployments by. */
  field: Github_DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export type Github_DeploymentOrderField =
  /** Order collection by creation time */
  | 'CREATED_AT';

/** A protection rule. */
export type Github_DeploymentProtectionRule = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The teams or users that can review the deployment */
  reviewers: Github_DeploymentReviewerConnection;
  /** The timeout in minutes for this protection rule. */
  timeout: Scalars['Int'];
  /** The type of protection rule. */
  type: Github_DeploymentProtectionRuleType;
};


/** A protection rule. */
export type Github_DeploymentProtectionRulereviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DeploymentProtectionRule. */
export type Github_DeploymentProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentProtectionRule>;
};

/** The possible protection rule types. */
export type Github_DeploymentProtectionRuleType =
  /** Required reviewers */
  | 'REQUIRED_REVIEWERS'
  /** Wait timer */
  | 'WAIT_TIMER';

/** A request to deploy a workflow run to an environment. */
export type Github_DeploymentRequest = {
  /** Whether or not the current user can approve the deployment */
  currentUserCanApprove: Scalars['Boolean'];
  /** The target environment of the deployment */
  environment: Github_Environment;
  /** The teams or users that can review the deployment */
  reviewers: Github_DeploymentReviewerConnection;
  /** The wait timer in minutes configured in the environment */
  waitTimer: Scalars['Int'];
  /** The wait timer in minutes configured in the environment */
  waitTimerStartedAt?: Maybe<Scalars['DateTime']>;
};


/** A request to deploy a workflow run to an environment. */
export type Github_DeploymentRequestreviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DeploymentRequest. */
export type Github_DeploymentRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentRequest>;
};

/** A deployment review. */
export type Github_DeploymentReview = Github_Node & {
  /** The comment the user left. */
  comment: Scalars['String'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The environments approved or rejected */
  environments: Github_EnvironmentConnection;
  id: Scalars['ID'];
  /** The decision of the user. */
  state: Github_DeploymentReviewState;
  /** The user that reviewed the deployment. */
  user: Github_User;
};


/** A deployment review. */
export type Github_DeploymentReviewenvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DeploymentReview. */
export type Github_DeploymentReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentReview>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentReview>;
};

/** The possible states for a deployment review. */
export type Github_DeploymentReviewState =
  /** The deployment was approved. */
  | 'APPROVED'
  /** The deployment was rejected. */
  | 'REJECTED';

/** Users and teams. */
export type Github_DeploymentReviewer = Github_Team | Github_User;

/** The connection type for DeploymentReviewer. */
export type Github_DeploymentReviewerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentReviewerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentReviewer>;
};

/** The possible states in which a deployment can be. */
export type Github_DeploymentState =
  /** The pending deployment was not updated after 30 minutes. */
  | 'ABANDONED'
  /** The deployment is currently active. */
  | 'ACTIVE'
  /** An inactive transient deployment. */
  | 'DESTROYED'
  /** The deployment experienced an error. */
  | 'ERROR'
  /** The deployment has failed. */
  | 'FAILURE'
  /** The deployment is inactive. */
  | 'INACTIVE'
  /** The deployment is in progress. */
  | 'IN_PROGRESS'
  /** The deployment is pending. */
  | 'PENDING'
  /** The deployment has queued */
  | 'QUEUED'
  /** The deployment is waiting. */
  | 'WAITING';

/** Describes the status of a given deployment attempt. */
export type Github_DeploymentStatus = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who triggered the deployment. */
  creator: Github_Actor;
  /** Identifies the deployment associated with status. */
  deployment: Github_Deployment;
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars['String']>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  environment?: Maybe<Scalars['String']>;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars['Github_URI']>;
  /** Identifies the current state of the deployment. */
  state: Github_DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for DeploymentStatus. */
export type Github_DeploymentStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentStatus>;
};

/** The possible states for a deployment status. */
export type Github_DeploymentStatusState =
  /** The deployment experienced an error. */
  | 'ERROR'
  /** The deployment has failed. */
  | 'FAILURE'
  /** The deployment is inactive. */
  | 'INACTIVE'
  /** The deployment is in progress. */
  | 'IN_PROGRESS'
  /** The deployment is pending. */
  | 'PENDING'
  /** The deployment is queued */
  | 'QUEUED'
  /** The deployment was successful. */
  | 'SUCCESS'
  /** The deployment is waiting. */
  | 'WAITING';

/** The possible sides of a diff. */
export type Github_DiffSide =
  /** The left side of the diff. */
  | 'LEFT'
  /** The right side of the diff. */
  | 'RIGHT';

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type Github_DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of DisablePullRequestAutoMerge */
export type Github_DisablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request auto merge was disabled on. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'disconnected' event on a given issue or pull request. */
export type Github_DisconnectedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Issue or pull request from which the issue was disconnected. */
  source: Github_ReferencedSubject;
  /** Issue or pull request which was disconnected. */
  subject: Github_ReferencedSubject;
};

/** A discussion in a repository. */
export type Github_Discussion = Github_Closable & Github_Comment & Github_Deletable & Github_Labelable & Github_Lockable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Subscribable & Github_Updatable & Github_Votable & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** The comment chosen as this discussion's answer, if any. */
  answer?: Maybe<Github_DiscussionComment>;
  /** The time when a user chose this discussion's answer, if answered. */
  answerChosenAt?: Maybe<Scalars['DateTime']>;
  /** The user who chose this discussion's answer, if answered. */
  answerChosenBy?: Maybe<Github_Actor>;
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The main text of the discussion post. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** The category for this discussion. */
  category: Github_DiscussionCategory;
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** The replies to the discussion. */
  comments: Github_DiscussionCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
  /** The number identifying this discussion within the repository. */
  number: Scalars['Int'];
  /** The poll associated with this discussion, if one exists. */
  poll?: Maybe<Github_DiscussionPoll>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The path for this discussion. */
  resourcePath: Scalars['Github_URI'];
  /** The title of this discussion. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** The URL for this discussion. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A discussion in a repository. */
export type Github_DiscussioncommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A discussion in a repository. */
export type Github_DiscussionlabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};


/** A discussion in a repository. */
export type Github_DiscussionreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A discussion in a repository. */
export type Github_DiscussionuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A category for discussions in a repository. */
export type Github_DiscussionCategory = Github_Node & Github_RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** A description of this category. */
  description?: Maybe<Scalars['String']>;
  /** An emoji representing this category. */
  emoji: Scalars['String'];
  /** This category's emoji rendered as HTML. */
  emojiHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */
  isAnswerable: Scalars['Boolean'];
  /** The name of this category. */
  name: Scalars['String'];
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The slug of this category. */
  slug: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for DiscussionCategory. */
export type Github_DiscussionCategoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DiscussionCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionCategoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DiscussionCategory>;
};

/** A comment on a discussion. */
export type Github_DiscussionComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_Updatable & Github_UpdatableComment & Github_Votable & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The time when this replied-to comment was deleted */
  deletedAt?: Maybe<Scalars['DateTime']>;
  /** The discussion this comment was created in */
  discussion?: Maybe<Github_Discussion>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Has this comment been chosen as the answer of its discussion? */
  isAnswer: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The threaded replies to this comment. */
  replies: Github_DiscussionCommentConnection;
  /** The discussion comment this comment is a reply to */
  replyTo?: Maybe<Github_DiscussionComment>;
  /** The path for this discussion comment. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** The URL for this discussion comment. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can the current user mark this comment as an answer? */
  viewerCanMarkAsAnswer: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Can the current user unmark this comment as an answer? */
  viewerCanUnmarkAsAnswer: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
};


/** A comment on a discussion. */
export type Github_DiscussionCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A comment on a discussion. */
export type Github_DiscussionCommentrepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A comment on a discussion. */
export type Github_DiscussionCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DiscussionComment. */
export type Github_DiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DiscussionComment>;
};

/** The connection type for Discussion. */
export type Github_DiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Discussion>;
};

/** Ways in which lists of discussions can be ordered upon return. */
export type Github_DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: Github_OrderDirection;
  /** The field by which to order discussions. */
  field: Github_DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export type Github_DiscussionOrderField =
  /** Order discussions by creation time. */
  | 'CREATED_AT'
  /** Order discussions by most recent modification time. */
  | 'UPDATED_AT';

/** A poll for a discussion. */
export type Github_DiscussionPoll = Github_Node & {
  /** The discussion that this poll belongs to. */
  discussion?: Maybe<Github_Discussion>;
  id: Scalars['ID'];
  /** The options for this poll. */
  options?: Maybe<Github_DiscussionPollOptionConnection>;
  /** The question that is being asked by this poll. */
  question: Scalars['String'];
  /** The total number of votes that have been cast for this poll. */
  totalVoteCount: Scalars['Int'];
  /** Indicates if the viewer has permission to vote in this poll. */
  viewerCanVote: Scalars['Boolean'];
  /** Indicates if the viewer has voted for any option in this poll. */
  viewerHasVoted: Scalars['Boolean'];
};


/** A poll for a discussion. */
export type Github_DiscussionPolloptionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionPollOptionOrder>;
};

/** An option for a discussion poll. */
export type Github_DiscussionPollOption = Github_Node & {
  id: Scalars['ID'];
  /** The text for this option. */
  option: Scalars['String'];
  /** The discussion poll that this option belongs to. */
  poll?: Maybe<Github_DiscussionPoll>;
  /** The total number of votes that have been cast for this option. */
  totalVoteCount: Scalars['Int'];
  /** Indicates if the viewer has voted for this option in the poll. */
  viewerHasVoted: Scalars['Boolean'];
};

/** The connection type for DiscussionPollOption. */
export type Github_DiscussionPollOptionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionPollOptionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DiscussionPollOption>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionPollOptionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DiscussionPollOption>;
};

/** Ordering options for discussion poll option connections. */
export type Github_DiscussionPollOptionOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order poll options by. */
  field: Github_DiscussionPollOptionOrderField;
};

/** Properties by which discussion poll option connections can be ordered. */
export type Github_DiscussionPollOptionOrderField =
  /** Order poll options by the order that the poll author specified when creating the poll. */
  | 'AUTHORED_ORDER'
  /** Order poll options by the number of votes it has. */
  | 'VOTE_COUNT';

/** Autogenerated input type of DismissPullRequestReview */
export type Github_DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of DismissPullRequestReview */
export type Github_DismissPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** The possible reasons that a Dependabot alert was dismissed. */
export type Github_DismissReason =
  /** A fix has already been started */
  | 'FIX_STARTED'
  /** This alert is inaccurate or incorrect */
  | 'INACCURATE'
  /** Vulnerable code is not actually used */
  | 'NOT_USED'
  /** No bandwidth to fix this */
  | 'NO_BANDWIDTH'
  /** Risk is tolerable to this project */
  | 'TOLERABLE_RISK';

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
export type Github_DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The reason the Dependabot alert is being dismissed. */
  dismissReason: Github_DismissReason;
  /** The Dependabot alert ID to dismiss. */
  repositoryVulnerabilityAlertId: Scalars['ID'];
};

/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */
export type Github_DismissRepositoryVulnerabilityAlertPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Dependabot alert that was dismissed */
  repositoryVulnerabilityAlert?: Maybe<Github_RepositoryVulnerabilityAlert>;
};

/** A draft issue within a project. */
export type Github_DraftIssue = Github_Node & {
  /** A list of users to assigned to this draft issue. */
  assignees: Github_UserConnection;
  /** The body of the draft issue. */
  body: Scalars['String'];
  /** The body of the draft issue rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body of the draft issue rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this draft issue. */
  creator?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */
  projectV2Items: Github_ProjectV2ItemConnection;
  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */
  projectsV2: Github_ProjectV2Connection;
  /** The title of the draft issue */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** A draft issue within a project. */
export type Github_DraftIssueassigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A draft issue within a project. */
export type Github_DraftIssueprojectV2ItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A draft issue within a project. */
export type Github_DraftIssueprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type Github_DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type Github_DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<Github_DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<Github_DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type Github_EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Commit body to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit message is ignored.
   */
  commitBody?: InputMaybe<Scalars['String']>;
  /**
   * Commit headline to use for the commit when the PR is mergable; if omitted, a
   * default message will be used. NOTE: when merging with a merge queue any input
   * value for commit headline is ignored.
   */
  commitHeadline?: InputMaybe<Scalars['String']>;
  /**
   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging
   * with a merge queue any input value for merge method is ignored.
   */
  mergeMethod?: InputMaybe<Github_PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of EnablePullRequestAutoMerge */
export type Github_EnablePullRequestAutoMergePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request auto-merge was enabled on. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_Enterprise = Github_AnnouncementBanner & Github_Node & {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']>;
  /** A URL pointing to the enterprise's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Enterprise billing informationvisible to enterprise billing managers. */
  billingInfo?: Maybe<Github_EnterpriseBillingInfo>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>;
  /** The description of the enterprise as HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>;
  /** A list of users who are members of this enterprise. */
  members: Github_EnterpriseMemberConnection;
  /** The name of the enterprise. */
  name: Scalars['String'];
  /** A list of organizations that belong to this enterprise. */
  organizations: Github_OrganizationConnection;
  /** Enterprise information only visible to enterprise owners. */
  ownerInfo?: Maybe<Github_EnterpriseOwnerInfo>;
  /** The HTTP path for this enterprise. */
  resourcePath: Scalars['Github_URI'];
  /** The URL-friendly identifier for the enterprise. */
  slug: Scalars['String'];
  /** The HTTP URL for this enterprise. */
  url: Scalars['Github_URI'];
  /** Is the current viewer an admin of this enterprise? */
  viewerIsAdmin: Scalars['Boolean'];
  /** The URL of the enterprise website. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterpriseavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterprisemembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deployment?: InputMaybe<Github_EnterpriseUserDeployment>;
  first?: InputMaybe<Scalars['Int']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']>>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseUserAccountMembershipRole>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterpriseorganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  query?: InputMaybe<Scalars['String']>;
  viewerOrganizationRole?: InputMaybe<Github_RoleInOrganization>;
};

/** The connection type for User. */
export type Github_EnterpriseAdministratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is an administrator of an enterprise. */
export type Github_EnterpriseAdministratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The role of the administrator. */
  role: Github_EnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type Github_EnterpriseAdministratorInvitation = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars['String']>;
  /** The enterprise the invitation is for. */
  enterprise: Github_Enterprise;
  id: Scalars['ID'];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<Github_User>;
  /** The user who created the invitation. */
  inviter?: Maybe<Github_User>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: Github_EnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type Github_EnterpriseAdministratorInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseAdministratorInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type Github_EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: Github_EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export type Github_EnterpriseAdministratorInvitationOrderField =
  /** Order enterprise administrator member invitations by creation time */
  | 'CREATED_AT';

/** The possible administrator roles in an enterprise account. */
export type Github_EnterpriseAdministratorRole =
  /** Represents a billing manager of the enterprise account. */
  | 'BILLING_MANAGER'
  /** Represents an owner of the enterprise account. */
  | 'OWNER';

/** The possible values for the enterprise allow private repository forking policy value. */
export type Github_EnterpriseAllowPrivateRepositoryForkingPolicyValue =
  /** Members can fork a repository to an organization within this enterprise. */
  | 'ENTERPRISE_ORGANIZATIONS'
  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */
  | 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS'
  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */
  | 'EVERYWHERE'
  /** Members can fork a repository only within the same organization (intra-org). */
  | 'SAME_ORGANIZATION'
  /** Members can fork a repository to their user account or within the same organization. */
  | 'SAME_ORGANIZATION_USER_ACCOUNTS'
  /** Members can fork a repository to their user account. */
  | 'USER_ACCOUNTS';

/** Metadata for an audit entry containing enterprise account information. */
export type Github_EnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type Github_EnterpriseBillingInfo = {
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars['Int'];
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars['Int'];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars['Float'];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars['Float'];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars['Int'];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars['Float'];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars['Float'];
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars['Int'];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars['Int'];
  /** The total number of licenses allocated. */
  totalLicenses: Scalars['Int'];
};

/** The possible values for the enterprise base repository permission setting. */
export type Github_EnterpriseDefaultRepositoryPermissionSettingValue =
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  | 'ADMIN'
  /** Organization members will only be able to clone and pull public repositories. */
  | 'NONE'
  /** Organizations in the enterprise choose base repository permissions for their members. */
  | 'NO_POLICY'
  /** Organization members will be able to clone and pull all organization repositories. */
  | 'READ'
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  | 'WRITE';

/** The possible values for an enabled/disabled enterprise setting. */
export type Github_EnterpriseEnabledDisabledSettingValue =
  /** The setting is disabled for organizations in the enterprise. */
  | 'DISABLED'
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED'
  /** There is no policy set for organizations in the enterprise. */
  | 'NO_POLICY';

/** The possible values for an enabled/no policy enterprise setting. */
export type Github_EnterpriseEnabledSettingValue =
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED'
  /** There is no policy set for organizations in the enterprise. */
  | 'NO_POLICY';

/** The connection type for OrganizationInvitation. */
export type Github_EnterpriseFailedInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseFailedInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int'];
};

/** A failed invitation to be a member in an enterprise organization. */
export type Github_EnterpriseFailedInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationInvitation>;
};

/** An identity provider configured to provision identities for an enterprise. */
export type Github_EnterpriseIdentityProvider = Github_Node & {
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<Github_SamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Github_Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: Github_ExternalIdentityConnection;
  id: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['Github_X509Certificate']>;
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars['String']>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars['String']>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<Github_SamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['Github_URI']>;
};


/** An identity provider configured to provision identities for an enterprise. */
export type Github_EnterpriseIdentityProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  login?: InputMaybe<Scalars['String']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
  userName?: InputMaybe<Scalars['String']>;
};

/** An object that is a member of an enterprise. */
export type Github_EnterpriseMember = Github_EnterpriseUserAccount | Github_User;

/** The connection type for EnterpriseMember. */
export type Github_EnterpriseMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseMember>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is a member of an enterprise through one or more organizations. */
export type Github_EnterpriseMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseMember>;
};

/** Ordering options for enterprise member connections. */
export type Github_EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order enterprise members by. */
  field: Github_EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export type Github_EnterpriseMemberOrderField =
  /** Order enterprise members by creation time */
  | 'CREATED_AT'
  /** Order enterprise members by login */
  | 'LOGIN';

/** The possible values for the enterprise members can create repositories setting. */
export type Github_EnterpriseMembersCanCreateRepositoriesSettingValue =
  /** Members will be able to create public and private repositories. */
  | 'ALL'
  /** Members will not be able to create public or private repositories. */
  | 'DISABLED'
  /** Organization administrators choose whether to allow members to create repositories. */
  | 'NO_POLICY'
  /** Members will be able to create only private repositories. */
  | 'PRIVATE'
  /** Members will be able to create only public repositories. */
  | 'PUBLIC';

/** The possible values for the members can make purchases setting. */
export type Github_EnterpriseMembersCanMakePurchasesSettingValue =
  /** The setting is disabled for organizations in the enterprise. */
  | 'DISABLED'
  /** The setting is enabled for organizations in the enterprise. */
  | 'ENABLED';

/** The connection type for Organization. */
export type Github_EnterpriseOrganizationMembershipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An enterprise organization that a user is a member of. */
export type Github_EnterpriseOrganizationMembershipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Organization>;
  /** The role of the user in the enterprise membership. */
  role: Github_EnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
export type Github_EnterpriseOutsideCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type Github_EnterpriseOutsideCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: Github_EnterpriseRepositoryInfoConnection;
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type Github_EnterpriseOutsideCollaboratorEdgerepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
};

/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfo = {
  /** A list of all of the administrators for this enterprise. */
  admins: Github_EnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: Github_UserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean'];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: Github_OrganizationConnection;
  /** The value for the allow private repository forking policy on the enterprise. */
  allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<Github_EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: Github_EnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided base repository permission. */
  defaultRepositoryPermissionSettingOrganizations: Github_OrganizationConnection;
  /** A list of domains owned by the enterprise. */
  domains: Github_VerifiableDomainConnection;
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: Github_EnterpriseServerInstallationConnection;
  /** A list of failed invitations in the enterprise. */
  failedInvitations: Github_EnterpriseFailedInvitationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  ipAllowListEnabledSetting: Github_IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the enterprise. */
  ipAllowListEntries: Github_IpAllowListEntryConnection;
  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: Github_IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether or not the base repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars['Boolean'];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars['Boolean'];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  membersCanChangeRepositoryVisibilitySetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<Github_EnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: Github_OrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: Github_EnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: Github_OrganizationConnection;
  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: Github_NotificationRestrictionSettingValue;
  /** The OIDC Identity Provider for the enterprise. */
  oidcProvider?: Maybe<Github_OIDCProvider>;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: Github_OrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: Github_EnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: Github_EnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  pendingCollaboratorInvitations: Github_RepositoryInvitationConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: Github_EnterprisePendingMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: Github_OrganizationConnection;
  /**
   * The SAML Identity Provider for the enterprise. When used by a GitHub App,
   * requires an installation token with read and write access to members.
   */
  samlIdentityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: Github_OrganizationConnection;
  /** A list of members with a support entitlement. */
  supportEntitlements: Github_EnterpriseMemberConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: Github_EnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: Github_OrganizationConnection;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoadminsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']>>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseAdministratorRole>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoaffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoallowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfodefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Github_DefaultRepositoryPermissionField;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfodomainsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isApproved?: InputMaybe<Scalars['Boolean']>;
  isVerified?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_VerifiableDomainOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoenterpriseServerInstallationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  connectedOnly?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerInstallationOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfofailedInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IpAllowListEntryOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Github_OrganizationMembersCanCreateRepositoriesSettingValue;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfomembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoorganizationProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfooutsideCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  login?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']>>;
  query?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Github_RepositoryVisibility>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfopendingAdminInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseAdministratorInvitationOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseAdministratorRole>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfopendingCollaboratorInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfopendingMemberInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  invitationSource?: InputMaybe<Github_OrganizationInvitationSource>;
  last?: InputMaybe<Scalars['Int']>;
  organizationLogins?: InputMaybe<Array<Scalars['String']>>;
  query?: InputMaybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInforepositoryProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfosamlIdentityProviderSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Github_IdentityProviderConfigurationState;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfosupportEntitlementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoteamDiscussionsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfotwoFactorRequiredSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};

/** The connection type for OrganizationInvitation. */
export type Github_EnterprisePendingMemberInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int'];
};

/** An invitation to be a member in an enterprise organization. */
export type Github_EnterprisePendingMemberInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
export type Github_EnterpriseRepositoryInfo = Github_Node & {
  id: Scalars['ID'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** The repository's name. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
};

/** The connection type for EnterpriseRepositoryInfo. */
export type Github_EnterpriseRepositoryInfoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseRepositoryInfoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
export type Github_EnterpriseServerInstallation = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars['String'];
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars['String'];
  id: Scalars['ID'];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars['Boolean'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** User accounts on this Enterprise Server installation. */
  userAccounts: Github_EnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: Github_EnterpriseServerUserAccountsUploadConnection;
};


/** An Enterprise Server installation. */
export type Github_EnterpriseServerInstallationuserAccountsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerUserAccountOrder>;
};


/** An Enterprise Server installation. */
export type Github_EnterpriseServerInstallationuserAccountsUploadsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
export type Github_EnterpriseServerInstallationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerInstallationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerInstallation>;
};

/** Ordering options for Enterprise Server installation connections. */
export type Github_EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: Github_EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export type Github_EnterpriseServerInstallationOrderField =
  /** Order Enterprise Server installations by creation time */
  | 'CREATED_AT'
  /** Order Enterprise Server installations by customer name */
  | 'CUSTOMER_NAME'
  /** Order Enterprise Server installations by host name */
  | 'HOST_NAME';

/** A user account on an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccount = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** User emails belonging to this user account. */
  emails: Github_EnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: Github_EnterpriseServerInstallation;
  id: Scalars['ID'];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars['Boolean'];
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars['String'];
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars['String']>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars['DateTime'];
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** A user account on an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccountemailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
export type Github_EnterpriseServerUserAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerUserAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccountEmail = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email address. */
  email: Scalars['String'];
  id: Scalars['ID'];
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars['Boolean'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user account to which the email belongs. */
  userAccount: Github_EnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type Github_EnterpriseServerUserAccountEmailConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerUserAccountEmailEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
export type Github_EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order emails by. */
  field: Github_EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export type Github_EnterpriseServerUserAccountEmailOrderField =
  /** Order emails by email */
  | 'EMAIL';

/** Ordering options for Enterprise Server user account connections. */
export type Github_EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order user accounts by. */
  field: Github_EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export type Github_EnterpriseServerUserAccountOrderField =
  /** Order user accounts by login */
  | 'LOGIN'
  /** Order user accounts by creation time on the Enterprise Server installation */
  | 'REMOTE_CREATED_AT';

/** A user accounts upload from an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccountsUpload = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The enterprise to which this upload belongs. */
  enterprise: Github_Enterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: Github_EnterpriseServerInstallation;
  id: Scalars['ID'];
  /** The name of the file uploaded. */
  name: Scalars['String'];
  /** The synchronization state of the upload */
  syncState: Github_EnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type Github_EnterpriseServerUserAccountsUploadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerUserAccountsUploadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type Github_EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order user accounts uploads by. */
  field: Github_EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export type Github_EnterpriseServerUserAccountsUploadOrderField =
  /** Order user accounts uploads by creation time */
  | 'CREATED_AT';

/** Synchronization state of the Enterprise Server user accounts upload */
export type Github_EnterpriseServerUserAccountsUploadSyncState =
  /** The synchronization of the upload failed. */
  | 'FAILURE'
  /** The synchronization of the upload is pending. */
  | 'PENDING'
  /** The synchronization of the upload succeeded. */
  | 'SUCCESS';

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type Github_EnterpriseUserAccount = Github_Actor & Github_Node & {
  /** A URL pointing to the enterprise user account's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The enterprise in which this user account exists. */
  enterprise: Github_Enterprise;
  id: Scalars['ID'];
  /** An identifier for the enterprise user account, a login or email address */
  login: Scalars['String'];
  /** The name of the enterprise user account */
  name?: Maybe<Scalars['String']>;
  /** A list of enterprise organizations this user is a member of. */
  organizations: Github_EnterpriseOrganizationMembershipConnection;
  /** The HTTP path for this user. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this user. */
  url: Scalars['Github_URI'];
  /** The user within the enterprise. */
  user?: Maybe<Github_User>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type Github_EnterpriseUserAccountavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type Github_EnterpriseUserAccountorganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseUserAccountMembershipRole>;
};

/** The possible roles for enterprise membership. */
export type Github_EnterpriseUserAccountMembershipRole =
  /** The user is a member of an organization in the enterprise. */
  | 'MEMBER'
  /** The user is an owner of an organization in the enterprise. */
  | 'OWNER'
  /**
   * The user is not an owner of the enterprise, and not a member or owner of any
   * organizations in the enterprise; only for EMU-enabled enterprises.
   */
  | 'UNAFFILIATED';

/** The possible GitHub Enterprise deployments where this user can exist. */
export type Github_EnterpriseUserDeployment =
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  | 'CLOUD'
  /** The user is part of a GitHub Enterprise Server deployment. */
  | 'SERVER';

/** An environment. */
export type Github_Environment = Github_Node & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The name of the environment */
  name: Scalars['String'];
  /** The protection rules defined for this environment */
  protectionRules: Github_DeploymentProtectionRuleConnection;
};


/** An environment. */
export type Github_EnvironmentprotectionRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Environment. */
export type Github_EnvironmentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnvironmentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Environment>;
};

/** An external identity provisioned by SAML SSO or SCIM. */
export type Github_ExternalIdentity = Github_Node & {
  /** The GUID for this identity */
  guid: Scalars['String'];
  id: Scalars['ID'];
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<Github_OrganizationInvitation>;
  /** SAML Identity attributes */
  samlIdentity?: Maybe<Github_ExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<Github_ExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<Github_User>;
};

/** An attribute for the External Identity attributes collection */
export type Github_ExternalIdentityAttribute = {
  /** The attribute metadata as JSON */
  metadata?: Maybe<Scalars['String']>;
  /** The attribute name */
  name: Scalars['String'];
  /** The attribute value */
  value: Scalars['String'];
};

/** The connection type for ExternalIdentity. */
export type Github_ExternalIdentityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ExternalIdentityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ExternalIdentity>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ExternalIdentityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ExternalIdentity>;
};

/** SAML attributes for the External Identity */
export type Github_ExternalIdentitySamlAttributes = {
  /** SAML Identity attributes */
  attributes: Array<Github_ExternalIdentityAttribute>;
  /** The emails associated with the SAML identity */
  emails?: Maybe<Array<Github_UserEmailMetadata>>;
  /** Family name of the SAML identity */
  familyName?: Maybe<Scalars['String']>;
  /** Given name of the SAML identity */
  givenName?: Maybe<Scalars['String']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']>>;
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars['String']>;
  /** The userName of the SAML identity */
  username?: Maybe<Scalars['String']>;
};

/** SCIM attributes for the External Identity */
export type Github_ExternalIdentityScimAttributes = {
  /** The emails associated with the SCIM identity */
  emails?: Maybe<Array<Github_UserEmailMetadata>>;
  /** Family name of the SCIM identity */
  familyName?: Maybe<Scalars['String']>;
  /** Given name of the SCIM identity */
  givenName?: Maybe<Scalars['String']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']>>;
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars['String']>;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type Github_FileAddition = {
  /** The base64 encoded contents of the file */
  contents: Scalars['Github_Base64String'];
  /** The path in the repository where the file will be located */
  path: Scalars['String'];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type Github_FileChanges = {
  /** File to add or change. */
  additions?: InputMaybe<Array<Github_FileAddition>>;
  /** Files to delete. */
  deletions?: InputMaybe<Array<Github_FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type Github_FileDeletion = {
  /** The path to delete */
  path: Scalars['String'];
};

/** The possible viewed states of a file . */
export type Github_FileViewedState =
  /** The file has new changes since last viewed. */
  | 'DISMISSED'
  /** The file has not been marked as viewed. */
  | 'UNVIEWED'
  /** The file has been marked as viewed. */
  | 'VIEWED';

/** Autogenerated input type of FollowOrganization */
export type Github_FollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the organization to follow. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of FollowOrganization */
export type Github_FollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization that was followed. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of FollowUser */
export type Github_FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the user to follow. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of FollowUser */
export type Github_FollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was followed. */
  user?: Maybe<Github_User>;
};

/** The connection type for User. */
export type Github_FollowerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The connection type for User. */
export type Github_FollowingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A funding platform link for a repository. */
export type Github_FundingLink = {
  /** The funding platform this link is for. */
  platform: Github_FundingPlatform;
  /** The configured URL for this funding link. */
  url: Scalars['Github_URI'];
};

/** The possible funding platforms for repository funding links. */
export type Github_FundingPlatform =
  /** Community Bridge funding platform. */
  | 'COMMUNITY_BRIDGE'
  /** Custom funding platform. */
  | 'CUSTOM'
  /** GitHub funding platform. */
  | 'GITHUB'
  /** IssueHunt funding platform. */
  | 'ISSUEHUNT'
  /** Ko-fi funding platform. */
  | 'KO_FI'
  /** LFX Crowdfunding funding platform. */
  | 'LFX_CROWDFUNDING'
  /** Liberapay funding platform. */
  | 'LIBERAPAY'
  /** Open Collective funding platform. */
  | 'OPEN_COLLECTIVE'
  /** Otechie funding platform. */
  | 'OTECHIE'
  /** Patreon funding platform. */
  | 'PATREON'
  /** Tidelift funding platform. */
  | 'TIDELIFT';

/** A generic hovercard context with a message and icon */
export type Github_GenericHovercardContext = Github_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** A Gist. */
export type Github_Gist = Github_Node & Github_Starrable & Github_UniformResourceLocatable & {
  /** A list of comments associated with the gist */
  comments: Github_GistCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The gist description. */
  description?: Maybe<Scalars['String']>;
  /** The files in this gist. */
  files?: Maybe<Array<Maybe<Github_GistFile>>>;
  /** A list of forks associated with the gist */
  forks: Github_GistConnection;
  id: Scalars['ID'];
  /** Identifies if the gist is a fork. */
  isFork: Scalars['Boolean'];
  /** Whether the gist is public or not. */
  isPublic: Scalars['Boolean'];
  /** The gist name. */
  name: Scalars['String'];
  /** The gist owner. */
  owner?: Maybe<Github_RepositoryOwner>;
  /** Identifies when the gist was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this Gist. */
  url: Scalars['Github_URI'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** A Gist. */
export type Github_GistcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A Gist. */
export type Github_GistfilesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  oid?: InputMaybe<Scalars['Github_GitObjectID']>;
};


/** A Gist. */
export type Github_GistforksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_GistOrder>;
};


/** A Gist. */
export type Github_GiststargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** Represents a comment on an Gist. */
export type Github_GistComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the gist. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  /** The associated gist. */
  gist: Github_Gist;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on an Gist. */
export type Github_GistCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for GistComment. */
export type Github_GistCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_GistCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_GistComment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_GistCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_GistComment>;
};

/** The connection type for Gist. */
export type Github_GistConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_GistEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Gist>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_GistEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Gist>;
};

/** A file in a gist. */
export type Github_GistFile = {
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars['String']>;
  /** The gist file encoding. */
  encoding?: Maybe<Scalars['String']>;
  /** The file extension from the file name. */
  extension?: Maybe<Scalars['String']>;
  /** Indicates if this file is an image. */
  isImage: Scalars['Boolean'];
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars['Boolean'];
  /** The programming language this file is written in. */
  language?: Maybe<Github_Language>;
  /** The gist file name. */
  name?: Maybe<Scalars['String']>;
  /** The gist file size in bytes. */
  size?: Maybe<Scalars['Int']>;
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars['String']>;
};


/** A file in a gist. */
export type Github_GistFiletextArgs = {
  truncate?: InputMaybe<Scalars['Int']>;
};

/** Ordering options for gist connections */
export type Github_GistOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repositories by. */
  field: Github_GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export type Github_GistOrderField =
  /** Order gists by creation time */
  | 'CREATED_AT'
  /** Order gists by push time */
  | 'PUSHED_AT'
  /** Order gists by update time */
  | 'UPDATED_AT';

/** The privacy of a Gist */
export type Github_GistPrivacy =
  /** Gists that are public and secret */
  | 'ALL'
  /** Public */
  | 'PUBLIC'
  /** Secret */
  | 'SECRET';

/** Represents an actor in a Git commit (ie. an author or committer). */
export type Github_GitActor = {
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars['Github_GitTimestamp']>;
  /** The email in the Git commit. */
  email?: Maybe<Scalars['String']>;
  /** The name in the Git commit. */
  name?: Maybe<Scalars['String']>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<Github_User>;
};


/** Represents an actor in a Git commit (ie. an author or committer). */
export type Github_GitActoravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** The connection type for GitActor. */
export type Github_GitActorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_GitActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_GitActor>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_GitActorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_GitActor>;
};

/** Represents information about the GitHub instance. */
export type Github_GitHubMetadata = {
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars['Github_GitObjectID'];
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars['Boolean'];
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars['String']>>;
};

/** Represents a Git object. */
export type Github_GitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type Github_GitSignature = {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** The state of a Git signature. */
export type Github_GitSignatureState =
  /** The signing certificate or its chain could not be verified */
  | 'BAD_CERT'
  /** Invalid email used for signing */
  | 'BAD_EMAIL'
  /** Signing key expired */
  | 'EXPIRED_KEY'
  /** Internal error - the GPG verification service misbehaved */
  | 'GPGVERIFY_ERROR'
  /** Internal error - the GPG verification service is unavailable at the moment */
  | 'GPGVERIFY_UNAVAILABLE'
  /** Invalid signature */
  | 'INVALID'
  /** Malformed signature */
  | 'MALFORMED_SIG'
  /** The usage flags for the key that signed this don't allow signing */
  | 'NOT_SIGNING_KEY'
  /** Email used for signing not known to GitHub */
  | 'NO_USER'
  /** Valid signature, though certificate revocation check failed */
  | 'OCSP_ERROR'
  /** Valid signature, pending certificate revocation checking */
  | 'OCSP_PENDING'
  /** One or more certificates in chain has been revoked */
  | 'OCSP_REVOKED'
  /** Key used for signing not known to GitHub */
  | 'UNKNOWN_KEY'
  /** Unknown signature type */
  | 'UNKNOWN_SIG_TYPE'
  /** Unsigned */
  | 'UNSIGNED'
  /** Email used for signing unverified on GitHub */
  | 'UNVERIFIED_EMAIL'
  /** Valid signature and verified by GitHub */
  | 'VALID';

/** Represents a GPG signature on a Commit or Tag. */
export type Github_GpgSignature = Github_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars['String']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */
export type Github_GrantEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID'];
  /** The login of the user to grant the migrator role */
  login: Scalars['String'];
};

/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
export type Github_GrantEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organizations that had the migrator role applied to for the given user. */
  organizations?: Maybe<Github_OrganizationConnection>;
};


/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */
export type Github_GrantEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of GrantMigratorRole */
export type Github_GrantMigratorRoleInput = {
  /** The user login or Team slug to grant the migrator role. */
  actor: Scalars['String'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: Github_ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of GrantMigratorRole */
export type Github_GrantMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']>;
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type Github_HeadRefDeletedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<Github_Ref>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars['String'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type Github_HeadRefForcePushedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<Github_Commit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<Github_Ref>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type Github_HeadRefRestoredEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Detail needed to display a hovercard for a user */
export type Github_Hovercard = {
  /** Each of the contexts for this hovercard */
  contexts: Array<Github_HovercardContext>;
};

/** An individual line of a hovercard */
export type Github_HovercardContext = {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** The possible states in which authentication can be configured with an identity provider. */
export type Github_IdentityProviderConfigurationState =
  /** Authentication with an identity provider is configured but not enforced. */
  | 'CONFIGURED'
  /** Authentication with an identity provider is configured and enforced. */
  | 'ENFORCED'
  /** Authentication with an identity provider is not configured. */
  | 'UNCONFIGURED';

/** Autogenerated input type of ImportProject */
export type Github_ImportProjectInput = {
  /** The description of Project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<Github_ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String'];
  /** Whether the Project is public or not. */
  public?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of ImportProject */
export type Github_ImportProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new Project! */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type Github_InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The email of the person to invite as an administrator. */
  email?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of a user to invite as an administrator. */
  invitee?: InputMaybe<Scalars['String']>;
  /** The role of the administrator. */
  role?: InputMaybe<Github_EnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin */
export type Github_InviteEnterpriseAdminPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
export type Github_IpAllowListEnabledSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** An IP address or range of addresses that is allowed to access an owner's resources. */
export type Github_IpAllowListEntry = Github_Node & {
  /** A single IP address or range of IP addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Whether the entry is currently active. */
  isActive: Scalars['Boolean'];
  /** The name of the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
  /** The owner of the IP allow list entry. */
  owner: Github_IpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for IpAllowListEntry. */
export type Github_IpAllowListEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IpAllowListEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IpAllowListEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_IpAllowListEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
export type Github_IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order IP allow list entries by. */
  field: Github_IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export type Github_IpAllowListEntryOrderField =
  /** Order IP allow list entries by the allow list value. */
  | 'ALLOW_LIST_VALUE'
  /** Order IP allow list entries by creation time. */
  | 'CREATED_AT';

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export type Github_IpAllowListForInstalledAppsEnabledSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** Types that can own an IP allow list. */
export type Github_IpAllowListOwner = Github_App | Github_Enterprise | Github_Organization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_Issue = Github_Assignable & Github_Closable & Github_Comment & Github_Labelable & Github_Lockable & Github_Node & Github_ProjectV2Owner & Github_Reactable & Github_RepositoryNode & Github_Subscribable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Identifies the body of the issue. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The http path for this issue body */
  bodyResourcePath: Scalars['Github_URI'];
  /** Identifies the body of the issue rendered to text. */
  bodyText: Scalars['String'];
  /** The http URL for this issue body */
  bodyUrl: Scalars['Github_URI'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** A list of comments associated with the Issue. */
  comments: Github_IssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  /** The hovercard information for this issue */
  hovercard: Github_Hovercard;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Indicates whether or not this issue is currently pinned to the repository issues list */
  isPinned?: Maybe<Scalars['Boolean']>;
  /** Is this issue read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Branches linked to this issue. */
  linkedBranches: Github_LinkedBranchConnection;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
  /** Identifies the milestone associated with the issue. */
  milestone?: Maybe<Github_Milestone>;
  /** Identifies the issue number. */
  number: Scalars['Int'];
  /** A list of Users that are participating in the Issue conversation. */
  participants: Github_UserConnection;
  /** List of project cards associated with this issue. */
  projectCards: Github_ProjectCardConnection;
  /** List of project items associated with this issue. */
  projectItems: Github_ProjectV2ItemConnection;
  /** Find a project by number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: Github_ProjectV2Connection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the state of the issue. */
  state: Github_IssueState;
  /** Identifies the reason for the issue state. */
  stateReason?: Maybe<Github_IssueStateReason>;
  /**
   * A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: Github_IssueTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the issue. */
  timelineItems: Github_IssueTimelineItemsConnection;
  /** Identifies the issue title. */
  title: Scalars['String'];
  /** Identifies the issue title rendered to HTML. */
  titleHTML: Scalars['String'];
  /** A list of issues that track this issue */
  trackedInIssues: Github_IssueConnection;
  /** A list of issues tracked inside the current issue */
  trackedIssues: Github_IssueConnection;
  /** The number of tracked issues for this issue */
  trackedIssuesCount: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueassigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuecommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueCommentOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuehovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuelabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuelinkedBranchesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueparticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueprojectCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueprojectItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueprojectV2Args = {
  number: Scalars['Int'];
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuereactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuetimelineArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuetimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  itemTypes?: InputMaybe<Array<Github_IssueTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuetrackedInIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuetrackedIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssuetrackedIssuesCountArgs = {
  states?: InputMaybe<Array<InputMaybe<Github_TrackedIssueStates>>>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The possible state reasons of a closed issue. */
export type Github_IssueClosedStateReason =
  /** An issue that has been closed as completed */
  | 'COMPLETED'
  /** An issue that has been closed as not planned */
  | 'NOT_PLANNED';

/** Represents a comment on an Issue. */
export type Github_IssueComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** Identifies the issue associated with the comment. */
  issue: Github_Issue;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
   */
  pullRequest?: Maybe<Github_PullRequest>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path for this issue comment */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue comment */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on an Issue. */
export type Github_IssueCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** Represents a comment on an Issue. */
export type Github_IssueCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for IssueComment. */
export type Github_IssueCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IssueComment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_IssueCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IssueComment>;
};

/** Ways in which lists of issue comments can be ordered upon return. */
export type Github_IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order issue comments by. */
  field: Github_IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export type Github_IssueCommentOrderField =
  /** Order issue comments by update time */
  | 'UPDATED_AT';

/** The connection type for Issue. */
export type Github_IssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates issues opened by a user within one repository. */
export type Github_IssueContributionsByRepository = {
  /** The issue contributions. */
  contributions: Github_CreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  repository: Github_Repository;
};


/** This aggregates issues opened by a user within one repository. */
export type Github_IssueContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};

/** An edge in a connection. */
export type Github_IssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Issue>;
};

/** Ways in which to filter lists of issues. */
export type Github_IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: InputMaybe<Scalars['String']>;
  /** List issues created by given name. */
  createdBy?: InputMaybe<Scalars['String']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: InputMaybe<Scalars['String']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its database ID. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: InputMaybe<Scalars['String']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestoneNumber?: InputMaybe<Scalars['String']>;
  /** List issues that have been updated at or after the given date. */
  since?: InputMaybe<Scalars['DateTime']>;
  /** List issues filtered by the list of states given. */
  states?: InputMaybe<Array<Github_IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: InputMaybe<Scalars['Boolean']>;
};

/** Used for return value of Repository.issueOrPullRequest. */
export type Github_IssueOrPullRequest = Github_Issue | Github_PullRequest;

/** Ways in which lists of issues can be ordered upon return. */
export type Github_IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order issues by. */
  field: Github_IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export type Github_IssueOrderField =
  /** Order issues by comment count */
  | 'COMMENTS'
  /** Order issues by creation time */
  | 'CREATED_AT'
  /** Order issues by update time */
  | 'UPDATED_AT';

/** The possible states of an issue. */
export type Github_IssueState =
  /** An issue that has been closed */
  | 'CLOSED'
  /** An issue that is still open */
  | 'OPEN';

/** The possible state reasons of an issue. */
export type Github_IssueStateReason =
  /** An issue that has been closed as completed */
  | 'COMPLETED'
  /** An issue that has been closed as not planned */
  | 'NOT_PLANNED'
  /** An issue that has been reopened */
  | 'REOPENED';

/** A repository issue template. */
export type Github_IssueTemplate = {
  /** The template purpose. */
  about?: Maybe<Scalars['String']>;
  /** The suggested issue body. */
  body?: Maybe<Scalars['String']>;
  /** The template filename. */
  filename: Scalars['String'];
  /** The template name. */
  name: Scalars['String'];
  /** The suggested issue title. */
  title?: Maybe<Scalars['String']>;
};

/** The connection type for IssueTimelineItem. */
export type Github_IssueTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IssueTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An item in an issue timeline */
export type Github_IssueTimelineItem = Github_AssignedEvent | Github_ClosedEvent | Github_Commit | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MilestonedEvent | Github_ReferencedEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_SubscribedEvent | Github_TransferredEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** An edge in a connection. */
export type Github_IssueTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IssueTimelineItem>;
};

/** An item in an issue timeline */
export type Github_IssueTimelineItems = Github_AddedToProjectEvent | Github_AssignedEvent | Github_ClosedEvent | Github_CommentDeletedEvent | Github_ConnectedEvent | Github_ConvertedNoteToIssueEvent | Github_ConvertedToDiscussionEvent | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_DisconnectedEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MarkedAsDuplicateEvent | Github_MentionedEvent | Github_MilestonedEvent | Github_MovedColumnsInProjectEvent | Github_PinnedEvent | Github_ReferencedEvent | Github_RemovedFromProjectEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_SubscribedEvent | Github_TransferredEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnmarkedAsDuplicateEvent | Github_UnpinnedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** The connection type for IssueTimelineItems. */
export type Github_IssueTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** An edge in a connection. */
export type Github_IssueTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IssueTimelineItems>;
};

/** The possible item types found in a timeline. */
export type Github_IssueTimelineItemsItemType =
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  | 'ADDED_TO_PROJECT_EVENT'
  /** Represents an 'assigned' event on any assignable object. */
  | 'ASSIGNED_EVENT'
  /** Represents a 'closed' event on any `Closable`. */
  | 'CLOSED_EVENT'
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  | 'COMMENT_DELETED_EVENT'
  /** Represents a 'connected' event on a given issue or pull request. */
  | 'CONNECTED_EVENT'
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  | 'CONVERTED_NOTE_TO_ISSUE_EVENT'
  /** Represents a 'converted_to_discussion' event on a given issue. */
  | 'CONVERTED_TO_DISCUSSION_EVENT'
  /** Represents a mention made by one issue or pull request to another. */
  | 'CROSS_REFERENCED_EVENT'
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  | 'DEMILESTONED_EVENT'
  /** Represents a 'disconnected' event on a given issue or pull request. */
  | 'DISCONNECTED_EVENT'
  /** Represents a comment on an Issue. */
  | 'ISSUE_COMMENT'
  /** Represents a 'labeled' event on a given issue or pull request. */
  | 'LABELED_EVENT'
  /** Represents a 'locked' event on a given issue or pull request. */
  | 'LOCKED_EVENT'
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  | 'MARKED_AS_DUPLICATE_EVENT'
  /** Represents a 'mentioned' event on a given issue or pull request. */
  | 'MENTIONED_EVENT'
  /** Represents a 'milestoned' event on a given issue or pull request. */
  | 'MILESTONED_EVENT'
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  | 'MOVED_COLUMNS_IN_PROJECT_EVENT'
  /** Represents a 'pinned' event on a given issue or pull request. */
  | 'PINNED_EVENT'
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  | 'REFERENCED_EVENT'
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  | 'REMOVED_FROM_PROJECT_EVENT'
  /** Represents a 'renamed' event on a given issue or pull request */
  | 'RENAMED_TITLE_EVENT'
  /** Represents a 'reopened' event on any `Closable`. */
  | 'REOPENED_EVENT'
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  | 'SUBSCRIBED_EVENT'
  /** Represents a 'transferred' event on a given issue or pull request. */
  | 'TRANSFERRED_EVENT'
  /** Represents an 'unassigned' event on any assignable object. */
  | 'UNASSIGNED_EVENT'
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  | 'UNLABELED_EVENT'
  /** Represents an 'unlocked' event on a given issue or pull request. */
  | 'UNLOCKED_EVENT'
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  | 'UNMARKED_AS_DUPLICATE_EVENT'
  /** Represents an 'unpinned' event on a given issue or pull request. */
  | 'UNPINNED_EVENT'
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  | 'UNSUBSCRIBED_EVENT'
  /** Represents a 'user_blocked' event on a given user. */
  | 'USER_BLOCKED_EVENT';

/** Represents a user signing up for a GitHub account. */
export type Github_JoinedGitHubContribution = Github_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Github_Label = Github_Node & {
  /** Identifies the label color. */
  color: Scalars['String'];
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** A brief description of this label. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars['Boolean'];
  /** A list of issues associated with this label. */
  issues: Github_IssueConnection;
  /** Identifies the label name. */
  name: Scalars['String'];
  /** A list of pull requests associated with this label. */
  pullRequests: Github_PullRequestConnection;
  /** The repository associated with this label. */
  repository: Github_Repository;
  /** The HTTP path for this label. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP URL for this label. */
  url: Scalars['Github_URI'];
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Github_LabelissuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Github_LabelpullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The connection type for Label. */
export type Github_LabelConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Label>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_LabelEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Label>;
};

/** Ways in which lists of labels can be ordered upon return. */
export type Github_LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order labels by. */
  field: Github_LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export type Github_LabelOrderField =
  /** Order labels by creation time */
  | 'CREATED_AT'
  /** Order labels by name */
  | 'NAME';

/** An object that can have labels assigned to it. */
export type Github_Labelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
};


/** An object that can have labels assigned to it. */
export type Github_LabelablelabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type Github_LabeledEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the label associated with the 'labeled' event. */
  label: Github_Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Github_Labelable;
};

/** Represents a given language found in repositories. */
export type Github_Language = Github_Node & {
  /** The color defined for the current language. */
  color?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The name of the current language. */
  name: Scalars['String'];
};

/** A list of languages associated with the parent. */
export type Github_LanguageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_LanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Language>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars['Int'];
};

/** Represents the language of a repository. */
export type Github_LanguageEdge = {
  cursor: Scalars['String'];
  node: Github_Language;
  /** The number of bytes of code written in the language. */
  size: Scalars['Int'];
};

/** Ordering options for language connections. */
export type Github_LanguageOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order languages by. */
  field: Github_LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export type Github_LanguageOrderField =
  /** Order languages by the size of all files containing the language */
  | 'SIZE';

/** A repository's open source license */
export type Github_License = Github_Node & {
  /** The full text of the license */
  body: Scalars['String'];
  /** The conditions set by the license */
  conditions: Array<Maybe<Github_LicenseRule>>;
  /** A human-readable description of the license */
  description?: Maybe<Scalars['String']>;
  /** Whether the license should be featured */
  featured: Scalars['Boolean'];
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars['String']>;
  /** The lowercased SPDX ID of the license */
  key: Scalars['String'];
  /** The limitations set by the license */
  limitations: Array<Maybe<Github_LicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars['String'];
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars['String']>;
  /** The permissions set by the license */
  permissions: Array<Maybe<Github_LicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars['Boolean'];
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars['String']>;
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars['Github_URI']>;
};

/** Describes a License's conditions, permissions, and limitations */
export type Github_LicenseRule = {
  /** A description of the rule */
  description: Scalars['String'];
  /** The machine-readable rule key */
  key: Scalars['String'];
  /** The human-readable rule label */
  label: Scalars['String'];
};

/** Autogenerated input type of LinkProjectV2ToRepository */
export type Github_LinkProjectV2ToRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the project to link to the repository. */
  projectId: Scalars['ID'];
  /** The ID of the repository to link to the project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of LinkProjectV2ToRepository */
export type Github_LinkProjectV2ToRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository the project is linked to. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of LinkProjectV2ToTeam */
export type Github_LinkProjectV2ToTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the project to link to the team. */
  projectId: Scalars['ID'];
  /** The ID of the team to link to the project. */
  teamId: Scalars['ID'];
};

/** Autogenerated return type of LinkProjectV2ToTeam */
export type Github_LinkProjectV2ToTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The team the project is linked to */
  team?: Maybe<Github_Team>;
};

/** Autogenerated input type of LinkRepositoryToProject */
export type Github_LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of LinkRepositoryToProject */
export type Github_LinkRepositoryToProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The linked Project. */
  project?: Maybe<Github_Project>;
  /** The linked Repository. */
  repository?: Maybe<Github_Repository>;
};

/** A branch linked to an issue. */
export type Github_LinkedBranch = Github_Node & {
  id: Scalars['ID'];
  /** The branch's ref. */
  ref?: Maybe<Github_Ref>;
};

/** The connection type for LinkedBranch. */
export type Github_LinkedBranchConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_LinkedBranchEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_LinkedBranch>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_LinkedBranchEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_LinkedBranch>;
};

/** Autogenerated input type of LockLockable */
export type Github_LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A reason for why the item will be locked. */
  lockReason?: InputMaybe<Github_LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars['ID'];
};

/** Autogenerated return type of LockLockable */
export type Github_LockLockablePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was locked. */
  lockedRecord?: Maybe<Github_Lockable>;
};

/** The possible reasons that an issue or pull request was locked. */
export type Github_LockReason =
  /** The issue or pull request was locked because the conversation was off-topic. */
  | 'OFF_TOPIC'
  /** The issue or pull request was locked because the conversation was resolved. */
  | 'RESOLVED'
  /** The issue or pull request was locked because the conversation was spam. */
  | 'SPAM'
  /** The issue or pull request was locked because the conversation was too heated. */
  | 'TOO_HEATED';

/** An object that can be locked. */
export type Github_Lockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
};

/** Represents a 'locked' event on a given issue or pull request. */
export type Github_LockedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<Github_LockReason>;
  /** Object that was locked. */
  lockable: Github_Lockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
export type Github_Mannequin = Github_Actor & Github_Node & Github_UniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The user that has claimed the data attributed to this mannequin. */
  claimant?: Maybe<Github_User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The mannequin's email on the source instance. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The URL to this resource. */
  url: Scalars['Github_URI'];
};


/** A placeholder user for attribution of imported data on GitHub. */
export type Github_MannequinavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Mannequin. */
export type Github_MannequinConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_MannequinEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Mannequin>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a mannequin. */
export type Github_MannequinEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Mannequin>;
};

/** Ordering options for mannequins. */
export type Github_MannequinOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order mannequins by. */
  field: Github_MannequinOrderField;
};

/** Properties by which mannequins can be ordered. */
export type Github_MannequinOrderField =
  /** Order mannequins why when they were created. */
  | 'CREATED_AT'
  /** Order mannequins alphabetically by their source login. */
  | 'LOGIN';

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type Github_MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars['ID'];
};

/** Autogenerated return type of MarkDiscussionCommentAsAnswer */
export type Github_MarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that includes the chosen comment. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of MarkFileAsViewed */
export type Github_MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The path of the file to mark as viewed */
  path: Scalars['String'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MarkFileAsViewed */
export type Github_MarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type Github_MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MarkPullRequestReadyForReview */
export type Github_MarkPullRequestReadyForReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is ready for review. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type Github_MarkedAsDuplicateEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<Github_IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<Github_IssueOrPullRequest>;
  id: Scalars['ID'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean'];
};

/** A public description of a Marketplace category. */
export type Github_MarketplaceCategory = Github_Node & {
  /** The category's description. */
  description?: Maybe<Scalars['String']>;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The category's name. */
  name: Scalars['String'];
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars['Int'];
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars['Github_URI'];
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars['Int'];
  /** The short name of the category used in its URL. */
  slug: Scalars['String'];
  /** The HTTP URL for this Marketplace category. */
  url: Scalars['Github_URI'];
};

/** A listing in the GitHub integration marketplace. */
export type Github_MarketplaceListing = Github_Node & {
  /** The GitHub App this listing represents. */
  app?: Maybe<Github_App>;
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars['Github_URI']>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars['Github_URI'];
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars['Github_URI']>;
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars['String']>;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars['Github_HTML'];
  /** The listing's introductory description. */
  fullDescription: Scalars['String'];
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars['Github_HTML'];
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars['Boolean'];
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars['Boolean'];
  /** Whether the creator of the app is a verified org */
  hasVerifiedOwner: Scalars['Boolean'];
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars['String']>;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars['Github_URI']>;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars['Boolean'];
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars['Boolean'];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  isDraft: Scalars['Boolean'];
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars['Boolean'];
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars['Boolean'];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars['Boolean'];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars['Boolean'];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars['Boolean'];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars['Boolean'];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars['Boolean'];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars['Boolean'];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'];
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars['Github_URI']>;
  /** The listing's full name. */
  name: Scalars['String'];
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars['String'];
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars['Github_URI']>;
  /** The category that best describes the listing. */
  primaryCategory: Github_MarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars['Github_URI'];
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars['Github_URI'];
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars['String']>>;
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<Github_MarketplaceCategory>;
  /** The listing's very short description. */
  shortDescription: Scalars['String'];
  /** The short name of the listing used in its URL. */
  slug: Scalars['String'];
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars['Github_URI']>;
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars['String']>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  supportUrl: Scalars['Github_URI'];
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars['Github_URI'];
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars['Boolean'];
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars['Boolean'];
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars['Boolean'];
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars['Boolean'];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  viewerCanEditCategories: Scalars['Boolean'];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars['Boolean'];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  viewerCanRedraft: Scalars['Boolean'];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  viewerCanReject: Scalars['Boolean'];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  viewerCanRequestApproval: Scalars['Boolean'];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars['Boolean'];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  viewerHasPurchasedForAllOrganizations: Scalars['Boolean'];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars['Boolean'];
};


/** A listing in the GitHub integration marketplace. */
export type Github_MarketplaceListinglogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Look up Marketplace Listings */
export type Github_MarketplaceListingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_MarketplaceListingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_MarketplaceListing>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_MarketplaceListingEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_MarketplaceListing>;
};

/** Entities that have members who can set status messages. */
export type Github_MemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
};


/** Entities that have members who can set status messages. */
export type Github_MemberStatusablememberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type Github_MembersCanDeleteReposClearAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a members_can_delete_repos.disable event. */
export type Github_MembersCanDeleteReposDisableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a members_can_delete_repos.enable event. */
export type Github_MembersCanDeleteReposEnableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type Github_MentionedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of MergeBranch */
export type Github_MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: InputMaybe<Scalars['String']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of MergeBranch */
export type Github_MergeBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<Github_Commit>;
};

/** The possible default commit messages for merges. */
export type Github_MergeCommitMessage =
  /** Default to a blank commit message. */
  | 'BLANK'
  /** Default to the pull request's body. */
  | 'PR_BODY'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** The possible default commit titles for merges. */
export type Github_MergeCommitTitle =
  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */
  | 'MERGE_MESSAGE'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** Autogenerated input type of MergePullRequest */
export type Github_MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: InputMaybe<Scalars['String']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars['String']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<Github_PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MergePullRequest */
export type Github_MergePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was merged. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Detailed status information about a pull request merge. */
export type Github_MergeStateStatus =
  /** The head ref is out of date. */
  | 'BEHIND'
  /** The merge is blocked. */
  | 'BLOCKED'
  /** Mergeable and passing commit status. */
  | 'CLEAN'
  /** The merge commit cannot be cleanly created. */
  | 'DIRTY'
  /** The merge is blocked due to the pull request being a draft. */
  | 'DRAFT'
  /** Mergeable with passing commit status and pre-receive hooks. */
  | 'HAS_HOOKS'
  /** The state cannot currently be determined. */
  | 'UNKNOWN'
  /** Mergeable with non-passing commit status. */
  | 'UNSTABLE';

/** Whether or not a PullRequest can be merged. */
export type Github_MergeableState =
  /** The pull request cannot be merged due to merge conflicts. */
  | 'CONFLICTING'
  /** The pull request can be merged. */
  | 'MERGEABLE'
  /** The mergeability of the pull request is still being calculated. */
  | 'UNKNOWN';

/** Represents a 'merged' event on a given pull request. */
export type Github_MergedEvent = Github_Node & Github_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the commit associated with the `merge` event. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Maybe<Github_Ref>;
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this merged event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this merged event. */
  url: Scalars['Github_URI'];
};

/** Represents a GitHub Enterprise Importer (GEI) migration. */
export type Github_Migration = {
  /** The migration flag to continue on error. */
  continueOnError: Scalars['Boolean'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars['Github_URI']>;
  /** The migration source. */
  migrationSource: Github_MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars['String'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars['Github_URI'];
  /** The migration state. */
  state: Github_MigrationState;
};

/** A GitHub Enterprise Importer (GEI) migration source. */
export type Github_MigrationSource = Github_Node & {
  id: Scalars['ID'];
  /** The migration source name. */
  name: Scalars['String'];
  /** The migration source type. */
  type: Github_MigrationSourceType;
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  url: Scalars['Github_URI'];
};

/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */
export type Github_MigrationSourceType =
  /** An Azure DevOps migration source. */
  | 'AZURE_DEVOPS'
  /** A Bitbucket Server migration source. */
  | 'BITBUCKET_SERVER'
  /** A GitHub Migration API source. */
  | 'GITHUB_ARCHIVE';

/** The GitHub Enterprise Importer (GEI) migration state. */
export type Github_MigrationState =
  /** The migration has failed. */
  | 'FAILED'
  /** The migration has invalid credentials. */
  | 'FAILED_VALIDATION'
  /** The migration is in progress. */
  | 'IN_PROGRESS'
  /** The migration has not started. */
  | 'NOT_STARTED'
  /** The migration needs to have its credentials validated. */
  | 'PENDING_VALIDATION'
  /** The migration has been queued. */
  | 'QUEUED'
  /** The migration has succeeded. */
  | 'SUCCEEDED';

/** Represents a Milestone object on a given repository. */
export type Github_Milestone = Github_Closable & Github_Node & Github_UniformResourceLocatable & {
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who created the milestone. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the description of the milestone. */
  description?: Maybe<Scalars['String']>;
  /** Identifies the due date of the milestone. */
  dueOn?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** A list of issues associated with the milestone. */
  issues: Github_IssueConnection;
  /** Identifies the number of the milestone. */
  number: Scalars['Int'];
  /** Identifies the percentage complete for the milestone */
  progressPercentage: Scalars['Float'];
  /** A list of pull requests associated with the milestone. */
  pullRequests: Github_PullRequestConnection;
  /** The repository associated with this milestone. */
  repository: Github_Repository;
  /** The HTTP path for this milestone */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the state of the milestone. */
  state: Github_MilestoneState;
  /** Identifies the title of the milestone. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this milestone */
  url: Scalars['Github_URI'];
};


/** Represents a Milestone object on a given repository. */
export type Github_MilestoneissuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** Represents a Milestone object on a given repository. */
export type Github_MilestonepullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The connection type for Milestone. */
export type Github_MilestoneConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_MilestoneEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Milestone>;
};

/** Types that can be inside a Milestone. */
export type Github_MilestoneItem = Github_Issue | Github_PullRequest;

/** Ordering options for milestone connections. */
export type Github_MilestoneOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order milestones by. */
  field: Github_MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export type Github_MilestoneOrderField =
  /** Order milestones by when they were created. */
  | 'CREATED_AT'
  /** Order milestones by when they are due. */
  | 'DUE_DATE'
  /** Order milestones by their number. */
  | 'NUMBER'
  /** Order milestones by when they were last updated. */
  | 'UPDATED_AT';

/** The possible states of a milestone. */
export type Github_MilestoneState =
  /** A milestone that has been closed. */
  | 'CLOSED'
  /** A milestone that is still open. */
  | 'OPEN';

/** Represents a 'milestoned' event on a given issue or pull request. */
export type Github_MilestonedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars['String'];
  /** Object referenced by event. */
  subject: Github_MilestoneItem;
};

/** Entities that can be minimized. */
export type Github_Minimizable = {
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
};

/** Autogenerated input type of MinimizeComment */
export type Github_MinimizeCommentInput = {
  /** The classification of comment */
  classifier: Github_ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of MinimizeComment */
export type Github_MinimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was minimized. */
  minimizedComment?: Maybe<Github_Minimizable>;
};

/** Autogenerated input type of MoveProjectCard */
export type Github_MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: InputMaybe<Scalars['ID']>;
  /** The id of the card to move. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of MoveProjectCard */
export type Github_MoveProjectCardPayload = {
  /** The new edge of the moved card. */
  cardEdge?: Maybe<Github_ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MoveProjectColumn */
export type Github_MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the column to move. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of MoveProjectColumn */
export type Github_MoveProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new edge of the moved column. */
  columnEdge?: Maybe<Github_ProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type Github_MovedColumnsInProjectEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Column name the issue or pull request was moved from. */
  previousProjectColumnName: Scalars['String'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<Github_ProjectCard>;
  /** Column name the issue or pull request was moved to. */
  projectColumnName: Scalars['String'];
};

/** An object with an ID. */
export type Github_Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** The possible values for the notification restriction setting. */
export type Github_NotificationRestrictionSettingValue =
  /** The setting is disabled for the owner. */
  | 'DISABLED'
  /** The setting is enabled for the owner. */
  | 'ENABLED';

/** An OIDC identity provider configured to provision identities for an enterprise. */
export type Github_OIDCProvider = Github_Node & {
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Github_Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: Github_ExternalIdentityConnection;
  id: Scalars['ID'];
  /** The OIDC identity provider type */
  providerType: Github_OIDCProviderType;
  /** The id of the tenant this provider is attached to */
  tenantId: Scalars['String'];
};


/** An OIDC identity provider configured to provision identities for an enterprise. */
export type Github_OIDCProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  login?: InputMaybe<Scalars['String']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
  userName?: InputMaybe<Scalars['String']>;
};

/** The OIDC identity provider type */
export type Github_OIDCProviderType =
  /** Azure Active Directory */
  | 'AAD';

/** Metadata for an audit entry with action oauth_application.* */
export type Github_OauthApplicationAuditEntryData = {
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a oauth_application.create event. */
export type Github_OauthApplicationCreateAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The application URL of the OAuth Application. */
  applicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The callback URL of the OAuth Application. */
  callbackUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The rate limit of the OAuth Application. */
  rateLimit?: Maybe<Scalars['Int']>;
  /** The state of the OAuth Application. */
  state?: Maybe<Github_OauthApplicationCreateAuditEntryState>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The state of an OAuth Application when it was created. */
export type Github_OauthApplicationCreateAuditEntryState =
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  | 'ACTIVE'
  /** The OAuth Application was in the process of being deleted. */
  | 'PENDING_DELETION'
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  | 'SUSPENDED';

/** The corresponding operation type for the action */
export type Github_OperationType =
  /** An existing resource was accessed */
  | 'ACCESS'
  /** A resource performed an authentication event */
  | 'AUTHENTICATION'
  /** A new resource was created */
  | 'CREATE'
  /** An existing resource was modified */
  | 'MODIFY'
  /** An existing resource was removed */
  | 'REMOVE'
  /** An existing resource was restored */
  | 'RESTORE'
  /** An existing resource was transferred between multiple resources */
  | 'TRANSFER';

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export type Github_OrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC';

/** Audit log entry for a org.add_billing_manager */
export type Github_OrgAddBillingManagerAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The email address used to invite a billing manager for the organization. */
  invitationEmail?: Maybe<Scalars['String']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.add_member */
export type Github_OrgAddMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The permission level of the member added to the organization. */
  permission?: Maybe<Github_OrgAddMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The permissions available to members on an Organization. */
export type Github_OrgAddMemberAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** Can read and clone repositories. */
  | 'READ';

/** Audit log entry for a org.block_user */
export type Github_OrgBlockUserAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The blocked user. */
  blockedUser?: Maybe<Github_User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type Github_OrgConfigDisableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type Github_OrgConfigEnableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.create event. */
export type Github_OrgCreateAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The billing plan for the Organization. */
  billingPlan?: Maybe<Github_OrgCreateAuditEntryBillingPlan>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The billing plans available for organizations. */
export type Github_OrgCreateAuditEntryBillingPlan =
  /** Team Plan */
  | 'BUSINESS'
  /** Enterprise Cloud Plan */
  | 'BUSINESS_PLUS'
  /** Free Plan */
  | 'FREE'
  /** Tiered Per Seat Plan */
  | 'TIERED_PER_SEAT'
  /** Legacy Unlimited Plan */
  | 'UNLIMITED';

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type Github_OrgDisableOauthAppRestrictionsAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.disable_saml event. */
export type Github_OrgDisableSamlAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type Github_OrgDisableTwoFactorRequirementAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type Github_OrgEnableOauthAppRestrictionsAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.enable_saml event. */
export type Github_OrgEnableSamlAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type Github_OrgEnableTwoFactorRequirementAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Ordering options for an organization's enterprise owner connections. */
export type Github_OrgEnterpriseOwnerOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order enterprise owners by. */
  field: Github_OrgEnterpriseOwnerOrderField;
};

/** Properties by which enterprise owners can be ordered. */
export type Github_OrgEnterpriseOwnerOrderField =
  /** Order enterprise owners by login. */
  | 'LOGIN';

/** Audit log entry for a org.invite_member event. */
export type Github_OrgInviteMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The email address of the organization invitation. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The organization invitation. */
  organizationInvitation?: Maybe<Github_OrganizationInvitation>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.invite_to_business event. */
export type Github_OrgInviteToBusinessAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.oauth_app_access_approved event. */
export type Github_OrgOauthAppAccessApprovedAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.oauth_app_access_denied event. */
export type Github_OrgOauthAppAccessDeniedAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.oauth_app_access_requested event. */
export type Github_OrgOauthAppAccessRequestedAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.remove_billing_manager event. */
export type Github_OrgRemoveBillingManagerAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The reason for the billing manager being removed. */
  reason?: Maybe<Github_OrgRemoveBillingManagerAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The reason a billing manager was removed from an Organization. */
export type Github_OrgRemoveBillingManagerAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** SAML SSO enforcement requires an external identity */
  | 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';

/** Audit log entry for a org.remove_member event. */
export type Github_OrgRemoveMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The types of membership the member has with the organization. */
  membershipTypes?: Maybe<Array<Github_OrgRemoveMemberAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The reason for the member being removed. */
  reason?: Maybe<Github_OrgRemoveMemberAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The type of membership a user has with an Organization. */
export type Github_OrgRemoveMemberAuditEntryMembershipType =
  /**
   * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
   */
  | 'ADMIN'
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  | 'BILLING_MANAGER'
  /** A direct member is a user that is a member of the Organization. */
  | 'DIRECT_MEMBER'
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  | 'OUTSIDE_COLLABORATOR'
  /** A suspended member. */
  | 'SUSPENDED'
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  | 'UNAFFILIATED';

/** The reason a member was removed from an Organization. */
export type Github_OrgRemoveMemberAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** SAML SSO enforcement requires an external identity */
  | 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
  /** User was removed from organization during account recovery */
  | 'TWO_FACTOR_ACCOUNT_RECOVERY'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
  /** User account has been deleted */
  | 'USER_ACCOUNT_DELETED';

/** Audit log entry for a org.remove_outside_collaborator event. */
export type Github_OrgRemoveOutsideCollaboratorAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The types of membership the outside collaborator has with the organization. */
  membershipTypes?: Maybe<Array<Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The reason for the outside collaborator being removed from the Organization. */
  reason?: Maybe<Github_OrgRemoveOutsideCollaboratorAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The type of membership a user has with an Organization. */
export type Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType =
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  | 'BILLING_MANAGER'
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  | 'OUTSIDE_COLLABORATOR'
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  | 'UNAFFILIATED';

/** The reason an outside collaborator was removed from an Organization. */
export type Github_OrgRemoveOutsideCollaboratorAuditEntryReason =
  /** SAML external identity missing */
  | 'SAML_EXTERNAL_IDENTITY_MISSING'
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  | 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';

/** Audit log entry for a org.restore_member event. */
export type Github_OrgRestoreMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The number of custom email routings for the restored member. */
  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']>;
  /** The number of issue assignments for the restored member. */
  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']>;
  /** Restored organization membership objects. */
  restoredMemberships?: Maybe<Array<Github_OrgRestoreMemberAuditEntryMembership>>;
  /** The number of restored memberships. */
  restoredMembershipsCount?: Maybe<Scalars['Int']>;
  /** The number of repositories of the restored member. */
  restoredRepositoriesCount?: Maybe<Scalars['Int']>;
  /** The number of starred repositories for the restored member. */
  restoredRepositoryStarsCount?: Maybe<Scalars['Int']>;
  /** The number of watched repositories for the restored member. */
  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Types of memberships that can be restored for an Organization member. */
export type Github_OrgRestoreMemberAuditEntryMembership = Github_OrgRestoreMemberMembershipOrganizationAuditEntryData | Github_OrgRestoreMemberMembershipRepositoryAuditEntryData | Github_OrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type Github_OrgRestoreMemberMembershipOrganizationAuditEntryData = Github_OrganizationAuditEntryData & {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
};

/** Metadata for a repository membership for org.restore_member actions */
export type Github_OrgRestoreMemberMembershipRepositoryAuditEntryData = Github_RepositoryAuditEntryData & {
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
};

/** Metadata for a team membership for org.restore_member actions */
export type Github_OrgRestoreMemberMembershipTeamAuditEntryData = Github_TeamAuditEntryData & {
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.unblock_user */
export type Github_OrgUnblockUserAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The user being unblocked by the organization. */
  blockedUser?: Maybe<Github_User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.update_default_repository_permission */
export type Github_OrgUpdateDefaultRepositoryPermissionAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The new base repository permission level for the organization. */
  permission?: Maybe<Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The former base repository permission level for the organization. */
  permissionWas?: Maybe<Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The default permission a repository can have in an Organization. */
export type Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** No default permission value. */
  | 'NONE'
  /** Can read and clone repositories. */
  | 'READ'
  /** Can read, clone and push to repositories. */
  | 'WRITE';

/** Audit log entry for a org.update_member event. */
export type Github_OrgUpdateMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The new member permission level for the organization. */
  permission?: Maybe<Github_OrgUpdateMemberAuditEntryPermission>;
  /** The former member permission level for the organization. */
  permissionWas?: Maybe<Github_OrgUpdateMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The permissions available to members on an Organization. */
export type Github_OrgUpdateMemberAuditEntryPermission =
  /** Can read, clone, push, and add collaborators to repositories. */
  | 'ADMIN'
  /** Can read and clone repositories. */
  | 'READ';

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** Can members create repositories in the organization. */
  canCreateRepositories?: Maybe<Scalars['Boolean']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The permission for visibility level of repositories for this organization. */
  visibility?: Maybe<Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
};

/** The permissions available for repository creation on an Organization. */
export type Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility =
  /** All organization members are restricted from creating any repositories. */
  | 'ALL'
  /** All organization members are restricted from creating internal repositories. */
  | 'INTERNAL'
  /** All organization members are allowed to create any repositories. */
  | 'NONE'
  /** All organization members are restricted from creating private repositories. */
  | 'PRIVATE'
  /** All organization members are restricted from creating private or internal repositories. */
  | 'PRIVATE_INTERNAL'
  /** All organization members are restricted from creating public repositories. */
  | 'PUBLIC'
  /** All organization members are restricted from creating public or internal repositories. */
  | 'PUBLIC_INTERNAL'
  /** All organization members are restricted from creating public or private repositories. */
  | 'PUBLIC_PRIVATE';

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** Can outside collaborators be invited to repositories in the organization. */
  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_Organization = Github_Actor & Github_AnnouncementBanner & Github_MemberStatusable & Github_Node & Github_PackageOwner & Github_ProfileOwner & Github_ProjectOwner & Github_ProjectV2Owner & Github_ProjectV2Recent & Github_RepositoryDiscussionAuthor & Github_RepositoryDiscussionCommentAuthor & Github_RepositoryOwner & Github_Sponsorable & Github_UniformResourceLocatable & {
  /** The text of the announcement */
  announcement?: Maybe<Scalars['String']>;
  /** The expiration date of the announcement, if any */
  announcementExpiresAt?: Maybe<Scalars['DateTime']>;
  /** Whether the announcement can be dismissed by the user */
  announcementUserDismissible?: Maybe<Scalars['Boolean']>;
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** Audit log entries of the organization */
  auditLog: Github_OrganizationAuditEntryConnection;
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The organization's public profile description. */
  description?: Maybe<Scalars['String']>;
  /** The organization's public profile description rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['String']>;
  /** A list of domains owned by the organization. */
  domains?: Maybe<Github_VerifiableDomainConnection>;
  /** The organization's public email. */
  email?: Maybe<Scalars['String']>;
  /** A list of owners of the organization's enterprise account. */
  enterpriseOwners: Github_OrganizationEnterpriseOwnerConnection;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  id: Scalars['ID'];
  /** The interaction ability settings for this organization. */
  interactionAbility?: Maybe<Github_RepositoryInteractionAbility>;
  /** The setting value for whether the organization has an IP allow list enabled. */
  ipAllowListEnabledSetting: Github_IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the organization. */
  ipAllowListEntries: Github_IpAllowListEntryConnection;
  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: Github_IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** Whether the organization has verified its profile email and website. */
  isVerified: Scalars['Boolean'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The organization's public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The organization's login name. */
  login: Scalars['String'];
  /** A list of all mannequins for this organization. */
  mannequins: Github_MannequinConnection;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
  /** Members can fork private repositories in this organization */
  membersCanForkPrivateRepositories: Scalars['Boolean'];
  /** A list of users who are members of this organization. */
  membersWithRole: Github_OrganizationMemberConnection;
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** The organization's public profile name. */
  name?: Maybe<Scalars['String']>;
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['Github_URI'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['Github_URI'];
  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: Github_NotificationRestrictionSettingValue;
  /** The billing email for the organization. */
  organizationBillingEmail?: Maybe<Scalars['String']>;
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
  /** A list of users who have been invited to join this organization. */
  pendingMembers: Github_UserConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** Find a project by number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing organization's projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing organization's projects */
  projectsUrl: Scalars['Github_URI'];
  /** A list of projects under the owner. */
  projectsV2: Github_ProjectV2Connection;
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: Github_ProjectV2Connection;
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
  /** A list of all repository migrations for this organization. */
  repositoryMigrations: Github_RepositoryMigrationConnection;
  /**
   * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
   */
  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']>;
  /** The HTTP path for this organization. */
  resourcePath: Scalars['Github_URI'];
  /** The Organization's SAML identity providers */
  samlIdentityProvider?: Maybe<Github_OrganizationIdentityProvider>;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /** Find an organization's team by its slug. */
  team?: Maybe<Github_Team>;
  /** A list of teams in this organization. */
  teams: Github_TeamConnection;
  /** The HTTP path listing organization's teams */
  teamsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing organization's teams */
  teamsUrl: Scalars['Github_URI'];
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']>;
  /** The organization's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this organization. */
  url: Scalars['Github_URI'];
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: Scalars['Boolean'];
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: Scalars['Boolean'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** Viewer is an active member of this organization. */
  viewerIsAMember: Scalars['Boolean'];
  /** Whether or not this Organization is followed by the viewer. */
  viewerIsFollowing: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
  /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */
  webCommitSignoffRequired: Scalars['Boolean'];
  /** The organization's public profile URL. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationanyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationauditLogArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_AuditLogOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationdomainsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isApproved?: InputMaybe<Scalars['Boolean']>;
  isVerified?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_VerifiableDomainOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationenterpriseOwnersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrgEnterpriseOwnerOrder>;
  organizationRole?: InputMaybe<Github_RoleInOrganization>;
  query?: InputMaybe<Scalars['String']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationipAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IpAllowListEntryOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationisSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationmannequinsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_MannequinOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationmemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationmembersWithRoleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationpackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationpendingMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationprojectArgs = {
  number: Scalars['Int'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationprojectV2Args = {
  number: Scalars['Int'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationprojectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationrepositoryMigrationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryMigrationOrder>;
  repositoryName?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Github_MigrationState>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<Github_SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']>;
  until?: InputMaybe<Scalars['DateTime']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationsponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']>>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationteamArgs = {
  slug: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationteamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  ldapMapped?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<Github_TeamOrder>;
  privacy?: InputMaybe<Github_TeamPrivacy>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_TeamRole>;
  rootTeamsOnly?: InputMaybe<Scalars['Boolean']>;
  userLogins?: InputMaybe<Array<Scalars['String']>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationtotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']>>;
  until?: InputMaybe<Scalars['DateTime']>;
};

/** An audit entry in an organization audit log. */
export type Github_OrganizationAuditEntry = Github_MembersCanDeleteReposClearAuditEntry | Github_MembersCanDeleteReposDisableAuditEntry | Github_MembersCanDeleteReposEnableAuditEntry | Github_OauthApplicationCreateAuditEntry | Github_OrgAddBillingManagerAuditEntry | Github_OrgAddMemberAuditEntry | Github_OrgBlockUserAuditEntry | Github_OrgConfigDisableCollaboratorsOnlyAuditEntry | Github_OrgConfigEnableCollaboratorsOnlyAuditEntry | Github_OrgCreateAuditEntry | Github_OrgDisableOauthAppRestrictionsAuditEntry | Github_OrgDisableSamlAuditEntry | Github_OrgDisableTwoFactorRequirementAuditEntry | Github_OrgEnableOauthAppRestrictionsAuditEntry | Github_OrgEnableSamlAuditEntry | Github_OrgEnableTwoFactorRequirementAuditEntry | Github_OrgInviteMemberAuditEntry | Github_OrgInviteToBusinessAuditEntry | Github_OrgOauthAppAccessApprovedAuditEntry | Github_OrgOauthAppAccessDeniedAuditEntry | Github_OrgOauthAppAccessRequestedAuditEntry | Github_OrgRemoveBillingManagerAuditEntry | Github_OrgRemoveMemberAuditEntry | Github_OrgRemoveOutsideCollaboratorAuditEntry | Github_OrgRestoreMemberAuditEntry | Github_OrgUnblockUserAuditEntry | Github_OrgUpdateDefaultRepositoryPermissionAuditEntry | Github_OrgUpdateMemberAuditEntry | Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry | Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | Github_PrivateRepositoryForkingDisableAuditEntry | Github_PrivateRepositoryForkingEnableAuditEntry | Github_RepoAccessAuditEntry | Github_RepoAddMemberAuditEntry | Github_RepoAddTopicAuditEntry | Github_RepoArchivedAuditEntry | Github_RepoChangeMergeSettingAuditEntry | Github_RepoConfigDisableAnonymousGitAccessAuditEntry | Github_RepoConfigDisableCollaboratorsOnlyAuditEntry | Github_RepoConfigDisableContributorsOnlyAuditEntry | Github_RepoConfigDisableSockpuppetDisallowedAuditEntry | Github_RepoConfigEnableAnonymousGitAccessAuditEntry | Github_RepoConfigEnableCollaboratorsOnlyAuditEntry | Github_RepoConfigEnableContributorsOnlyAuditEntry | Github_RepoConfigEnableSockpuppetDisallowedAuditEntry | Github_RepoConfigLockAnonymousGitAccessAuditEntry | Github_RepoConfigUnlockAnonymousGitAccessAuditEntry | Github_RepoCreateAuditEntry | Github_RepoDestroyAuditEntry | Github_RepoRemoveMemberAuditEntry | Github_RepoRemoveTopicAuditEntry | Github_RepositoryVisibilityChangeDisableAuditEntry | Github_RepositoryVisibilityChangeEnableAuditEntry | Github_TeamAddMemberAuditEntry | Github_TeamAddRepositoryAuditEntry | Github_TeamChangeParentTeamAuditEntry | Github_TeamRemoveMemberAuditEntry | Github_TeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type Github_OrganizationAuditEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Metadata for an audit entry with action org.* */
export type Github_OrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
};

/** An edge in a connection. */
export type Github_OrganizationAuditEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationAuditEntry>;
};

/** A list of organizations managed by an enterprise. */
export type Github_OrganizationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_OrganizationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Organization>;
};

/** The connection type for User. */
export type Github_OrganizationEnterpriseOwnerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationEnterpriseOwnerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An enterprise owner in the context of an organization that is part of the enterprise. */
export type Github_OrganizationEnterpriseOwnerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The role of the owner with respect to the organization. */
  organizationRole: Github_RoleInOrganization;
};

/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type Github_OrganizationIdentityProvider = Github_Node & {
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars['Github_URI']>;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: Github_ExternalIdentityConnection;
  id: Scalars['ID'];
  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['Github_X509Certificate']>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars['String']>;
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<Github_Organization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars['Github_URI']>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['Github_URI']>;
};


/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type Github_OrganizationIdentityProviderexternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  login?: InputMaybe<Scalars['String']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
  userName?: InputMaybe<Scalars['String']>;
};

/** An Invitation for a user to an organization. */
export type Github_OrganizationInvitation = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The source of the invitation. */
  invitationSource: Github_OrganizationInvitationSource;
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: Github_OrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: Maybe<Github_User>;
  /** The user who created the invitation. */
  inviter: Github_User;
  /** The organization the invite is for */
  organization: Github_Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: Github_OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type Github_OrganizationInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_OrganizationInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationInvitation>;
};

/** The possible organization invitation roles. */
export type Github_OrganizationInvitationRole =
  /** The user is invited to be an admin of the organization. */
  | 'ADMIN'
  /** The user is invited to be a billing manager of the organization. */
  | 'BILLING_MANAGER'
  /** The user is invited to be a direct member of the organization. */
  | 'DIRECT_MEMBER'
  /** The user's previous role will be reinstated. */
  | 'REINSTATE';

/** The possible organization invitation sources. */
export type Github_OrganizationInvitationSource =
  /** The invitation was created from the web interface or from API */
  | 'MEMBER'
  /** The invitation was created from SCIM */
  | 'SCIM'
  /** The invitation was sent before this feature was added */
  | 'UNKNOWN';

/** The possible organization invitation types. */
export type Github_OrganizationInvitationType =
  /** The invitation was to an email address. */
  | 'EMAIL'
  /** The invitation was to an existing user. */
  | 'USER';

/** The connection type for User. */
export type Github_OrganizationMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user within an organization. */
export type Github_OrganizationMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>;
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The role this user has in the organization. */
  role?: Maybe<Github_OrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
export type Github_OrganizationMemberRole =
  /** The user is an administrator of the organization. */
  | 'ADMIN'
  /** The user is a member of the organization. */
  | 'MEMBER';

/** The possible values for the members can create repositories setting on an organization. */
export type Github_OrganizationMembersCanCreateRepositoriesSettingValue =
  /** Members will be able to create public and private repositories. */
  | 'ALL'
  /** Members will not be able to create public or private repositories. */
  | 'DISABLED'
  /** Members will be able to create only internal repositories. */
  | 'INTERNAL'
  /** Members will be able to create only private repositories. */
  | 'PRIVATE';

/** A GitHub Enterprise Importer (GEI) organization migration. */
export type Github_OrganizationMigration = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']>;
  /** The reason the organization migration failed. */
  failureReason?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The remaining amount of repos to be migrated. */
  remainingRepositoriesCount?: Maybe<Scalars['Int']>;
  /** The name of the source organization to be migrated. */
  sourceOrgName: Scalars['String'];
  /** The URL of the source organization to migrate. */
  sourceOrgUrl: Scalars['Github_URI'];
  /** The migration state. */
  state: Github_OrganizationMigrationState;
  /** The name of the target organization. */
  targetOrgName: Scalars['String'];
  /** The total amount of repositories to be migrated. */
  totalRepositoriesCount?: Maybe<Scalars['Int']>;
};

/** The Octoshift Organization migration state. */
export type Github_OrganizationMigrationState =
  /** The Octoshift migration has failed. */
  | 'FAILED'
  /** The Octoshift migration is in progress. */
  | 'IN_PROGRESS'
  /** The Octoshift migration has not started. */
  | 'NOT_STARTED'
  /** The Octoshift migration is performing post repository migrations. */
  | 'POST_REPO_MIGRATION'
  /** The Octoshift migration is performing pre repository migrations. */
  | 'PRE_REPO_MIGRATION'
  /** The Octoshift migration has been queued. */
  | 'QUEUED'
  /** The Octoshift org migration is performing repository migrations. */
  | 'REPO_MIGRATION'
  /** The Octoshift migration has succeeded. */
  | 'SUCCEEDED';

/** Used for argument of CreateProjectV2 mutation. */
export type Github_OrganizationOrUser = Github_Organization | Github_User;

/** Ordering options for organization connections. */
export type Github_OrganizationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order organizations by. */
  field: Github_OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export type Github_OrganizationOrderField =
  /** Order organizations by creation time */
  | 'CREATED_AT'
  /** Order organizations by login */
  | 'LOGIN';

/** An organization teams hovercard context */
export type Github_OrganizationTeamsHovercardContext = Github_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: Github_TeamConnection;
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars['Github_URI'];
  /** The URL for the full team list for this user */
  teamsUrl: Scalars['Github_URI'];
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars['Int'];
};


/** An organization teams hovercard context */
export type Github_OrganizationTeamsHovercardContextrelevantTeamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An organization list hovercard context */
export type Github_OrganizationsHovercardContext = Github_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: Github_OrganizationConnection;
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars['Int'];
};


/** An organization list hovercard context */
export type Github_OrganizationsHovercardContextrelevantOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
};

/** Information for an uploaded package. */
export type Github_Package = Github_Node & {
  id: Scalars['ID'];
  /** Find the latest version for the package. */
  latestVersion?: Maybe<Github_PackageVersion>;
  /** Identifies the name of the package. */
  name: Scalars['String'];
  /** Identifies the type of the package. */
  packageType: Github_PackageType;
  /** The repository this package belongs to. */
  repository?: Maybe<Github_Repository>;
  /** Statistics about package activity. */
  statistics?: Maybe<Github_PackageStatistics>;
  /** Find package version by version string. */
  version?: Maybe<Github_PackageVersion>;
  /** list of versions for this package */
  versions: Github_PackageVersionConnection;
};


/** Information for an uploaded package. */
export type Github_PackageversionArgs = {
  version: Scalars['String'];
};


/** Information for an uploaded package. */
export type Github_PackageversionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PackageVersionOrder>;
};

/** The connection type for Package. */
export type Github_PackageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Package>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PackageEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Package>;
};

/** A file in a package version. */
export type Github_PackageFile = Github_Node & {
  id: Scalars['ID'];
  /** MD5 hash of the file. */
  md5?: Maybe<Scalars['String']>;
  /** Name of the file. */
  name: Scalars['String'];
  /** The package version this file belongs to. */
  packageVersion?: Maybe<Github_PackageVersion>;
  /** SHA1 hash of the file. */
  sha1?: Maybe<Scalars['String']>;
  /** SHA256 hash of the file. */
  sha256?: Maybe<Scalars['String']>;
  /** Size of the file in bytes. */
  size?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** URL to download the asset. */
  url?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for PackageFile. */
export type Github_PackageFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PackageFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
export type Github_PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field in which to order package files by. */
  field?: InputMaybe<Github_PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export type Github_PackageFileOrderField =
  /** Order package files by creation time */
  | 'CREATED_AT';

/** Ways in which lists of packages can be ordered upon return. */
export type Github_PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field in which to order packages by. */
  field?: InputMaybe<Github_PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export type Github_PackageOrderField =
  /** Order packages by creation time */
  | 'CREATED_AT';

/** Represents an owner of a package. */
export type Github_PackageOwner = {
  id: Scalars['ID'];
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
};


/** Represents an owner of a package. */
export type Github_PackageOwnerpackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type Github_PackageStatistics = {
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'];
};

/** A version tag contains the mapping between a tag name and a version. */
export type Github_PackageTag = Github_Node & {
  id: Scalars['ID'];
  /** Identifies the tag name of the version. */
  name: Scalars['String'];
  /** Version that the tag is associated with. */
  version?: Maybe<Github_PackageVersion>;
};

/** The possible types of a package. */
export type Github_PackageType =
  /** A debian package. */
  | 'DEBIAN'
  /** A docker image. */
  | 'DOCKER'
  /** A maven package. */
  | 'MAVEN'
  /** An npm package. */
  | 'NPM'
  /** A nuget package. */
  | 'NUGET'
  /** A python package. */
  | 'PYPI'
  /** A rubygems package. */
  | 'RUBYGEMS';

/** Information about a specific package version. */
export type Github_PackageVersion = Github_Node & {
  /** List of files associated with this package version */
  files: Github_PackageFileConnection;
  id: Scalars['ID'];
  /** The package associated with this version. */
  package?: Maybe<Github_Package>;
  /** The platform this version was built for. */
  platform?: Maybe<Scalars['String']>;
  /** Whether or not this version is a pre-release. */
  preRelease: Scalars['Boolean'];
  /** The README of this package version. */
  readme?: Maybe<Scalars['String']>;
  /** The release associated with this package version. */
  release?: Maybe<Github_Release>;
  /** Statistics about package activity. */
  statistics?: Maybe<Github_PackageVersionStatistics>;
  /** The package version summary. */
  summary?: Maybe<Scalars['String']>;
  /** The version string. */
  version: Scalars['String'];
};


/** Information about a specific package version. */
export type Github_PackageVersionfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PackageFileOrder>;
};

/** The connection type for PackageVersion. */
export type Github_PackageVersionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PackageVersionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
export type Github_PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field in which to order package versions by. */
  field?: InputMaybe<Github_PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export type Github_PackageVersionOrderField =
  /** Order package versions by creation time */
  | 'CREATED_AT';

/** Represents a object that contains package version activity statistics such as downloads. */
export type Github_PackageVersionStatistics = {
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'];
};

/** Information about pagination in a connection. */
export type Github_PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** The possible types of patch statuses. */
export type Github_PatchStatus =
  /** The file was added. Git status 'A'. */
  | 'ADDED'
  /** The file's type was changed. Git status 'T'. */
  | 'CHANGED'
  /** The file was copied. Git status 'C'. */
  | 'COPIED'
  /** The file was deleted. Git status 'D'. */
  | 'DELETED'
  /** The file's contents were changed. Git status 'M'. */
  | 'MODIFIED'
  /** The file was renamed. Git status 'R'. */
  | 'RENAMED';

/** Types that can grant permissions on a repository to a user */
export type Github_PermissionGranter = Github_Organization | Github_Repository | Github_Team;

/** A level of permission and source for a user's access to a repository. */
export type Github_PermissionSource = {
  /** The organization the repository belongs to. */
  organization: Github_Organization;
  /** The level of access this source has granted to the user. */
  permission: Github_DefaultRepositoryPermissionField;
  /** The source of this permission. */
  source: Github_PermissionGranter;
};

/** Autogenerated input type of PinIssue */
export type Github_PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of PinIssue */
export type Github_PinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was pinned */
  issue?: Maybe<Github_Issue>;
};

/** Types that can be pinned to a profile page. */
export type Github_PinnableItem = Github_Gist | Github_Repository;

/** The connection type for PinnableItem. */
export type Github_PinnableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PinnableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PinnableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PinnableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
export type Github_PinnableItemType =
  /** A gist. */
  | 'GIST'
  /** An issue. */
  | 'ISSUE'
  /** An organization. */
  | 'ORGANIZATION'
  /** A project. */
  | 'PROJECT'
  /** A pull request. */
  | 'PULL_REQUEST'
  /** A repository. */
  | 'REPOSITORY'
  /** A team. */
  | 'TEAM'
  /** A user. */
  | 'USER';

/** A Pinned Discussion is a discussion pinned to a repository's index page. */
export type Github_PinnedDiscussion = Github_Node & Github_RepositoryNode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The discussion that was pinned. */
  discussion: Github_Discussion;
  /** Color stops of the chosen gradient */
  gradientStopColors: Array<Scalars['String']>;
  id: Scalars['ID'];
  /** Background texture pattern */
  pattern: Github_PinnedDiscussionPattern;
  /** The actor that pinned this discussion. */
  pinnedBy: Github_Actor;
  /** Preconfigured background gradient option */
  preconfiguredGradient?: Maybe<Github_PinnedDiscussionGradient>;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for PinnedDiscussion. */
export type Github_PinnedDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PinnedDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PinnedDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PinnedDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PinnedDiscussion>;
};

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export type Github_PinnedDiscussionGradient =
  /** A gradient of blue to mint */
  | 'BLUE_MINT'
  /** A gradient of blue to purple */
  | 'BLUE_PURPLE'
  /** A gradient of pink to blue */
  | 'PINK_BLUE'
  /** A gradient of purple to coral */
  | 'PURPLE_CORAL'
  /** A gradient of red to orange */
  | 'RED_ORANGE';

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export type Github_PinnedDiscussionPattern =
  /** An upward-facing chevron pattern */
  | 'CHEVRON_UP'
  /** A hollow dot pattern */
  | 'DOT'
  /** A solid dot pattern */
  | 'DOT_FILL'
  /** A heart pattern */
  | 'HEART_FILL'
  /** A plus sign pattern */
  | 'PLUS'
  /** A lightning bolt pattern */
  | 'ZAP';

/** Represents a 'pinned' event on a given issue or pull request. */
export type Github_PinnedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: Github_Issue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
export type Github_PinnedIssue = Github_Node & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The issue that was pinned. */
  issue: Github_Issue;
  /** The actor that pinned this issue. */
  pinnedBy: Github_Actor;
  /** The repository that this issue was pinned to. */
  repository: Github_Repository;
};

/** The connection type for PinnedIssue. */
export type Github_PinnedIssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PinnedIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PinnedIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PinnedIssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PinnedIssue>;
};

/** Audit log entry for a private_repository_forking.disable event. */
export type Github_PrivateRepositoryForkingDisableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a private_repository_forking.enable event. */
export type Github_PrivateRepositoryForkingEnableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type Github_ProfileItemShowcase = {
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars['Boolean'];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  items: Github_PinnableItemConnection;
};


/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type Github_ProfileItemShowcaseitemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** The public profile email. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The public profile name. */
  name?: Maybe<Scalars['String']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwneranyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwnerpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwnerpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type Github_Project = Github_Closable & Github_Node & Github_Updatable & {
  /** The project's description body. */
  body?: Maybe<Scalars['String']>;
  /** The projects description body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** Indicates if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** List of columns in the project */
  columns: Github_ProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who originally created the project. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project's name. */
  name: Scalars['String'];
  /** The project's number. */
  number: Scalars['Int'];
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  owner: Github_ProjectOwner;
  /** List of pending cards in this project */
  pendingCards: Github_ProjectCardConnection;
  /** Project progress details. */
  progress: Github_ProjectProgress;
  /** The HTTP path for this project */
  resourcePath: Scalars['Github_URI'];
  /** Whether the project is open or closed. */
  state: Github_ProjectState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project */
  url: Scalars['Github_URI'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type Github_ProjectcolumnsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type Github_ProjectpendingCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A card in a project. */
export type Github_ProjectCard = Github_Node & {
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  column?: Maybe<Github_ProjectColumn>;
  /** The card content item */
  content?: Maybe<Github_ProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this card */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Whether the card is archived */
  isArchived: Scalars['Boolean'];
  /** The card note */
  note?: Maybe<Scalars['String']>;
  /** The project that contains this card. */
  project: Github_Project;
  /** The HTTP path for this card */
  resourcePath: Scalars['Github_URI'];
  /** The state of ProjectCard */
  state?: Maybe<Github_ProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this card */
  url: Scalars['Github_URI'];
};

/** The possible archived states of a project card. */
export type Github_ProjectCardArchivedState =
  /** A project card that is archived */
  | 'ARCHIVED'
  /** A project card that is not archived */
  | 'NOT_ARCHIVED';

/** The connection type for ProjectCard. */
export type Github_ProjectCardConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectCard>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectCardEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
export type Github_ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String'];
};

/** Types that can be inside Project Cards. */
export type Github_ProjectCardItem = Github_Issue | Github_PullRequest;

/** Various content states of a ProjectCard */
export type Github_ProjectCardState =
  /** The card has content only. */
  | 'CONTENT_ONLY'
  /** The card has a note only. */
  | 'NOTE_ONLY'
  /** The card is redacted. */
  | 'REDACTED';

/** A column inside a project. */
export type Github_ProjectColumn = Github_Node & {
  /** List of cards in the column */
  cards: Github_ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project column's name. */
  name: Scalars['String'];
  /** The project that contains this column. */
  project: Github_Project;
  /** The semantic purpose of the column */
  purpose?: Maybe<Github_ProjectColumnPurpose>;
  /** The HTTP path for this project column */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project column */
  url: Scalars['Github_URI'];
};


/** A column inside a project. */
export type Github_ProjectColumncardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ProjectColumn. */
export type Github_ProjectColumnConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectColumnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectColumn>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectColumnEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
export type Github_ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String'];
  /** A list of issues and pull requests in the column. */
  issues?: InputMaybe<Array<Github_ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export type Github_ProjectColumnPurpose =
  /** The column contains cards which are complete */
  | 'DONE'
  /** The column contains cards which are currently being worked on */
  | 'IN_PROGRESS'
  /** The column contains cards still to be worked on */
  | 'TODO';

/** A list of projects associated with the owner. */
export type Github_ProjectConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Project>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Project>;
};

/** Ways in which lists of projects can be ordered upon return. */
export type Github_ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order projects by. */
  field: Github_ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export type Github_ProjectOrderField =
  /** Order projects by creation time */
  | 'CREATED_AT'
  /** Order projects by name */
  | 'NAME'
  /** Order projects by update time */
  | 'UPDATED_AT';

/** Represents an owner of a Project. */
export type Github_ProjectOwner = {
  id: Scalars['ID'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['Github_URI'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
};


/** Represents an owner of a Project. */
export type Github_ProjectOwnerprojectArgs = {
  number: Scalars['Int'];
};


/** Represents an owner of a Project. */
export type Github_ProjectOwnerprojectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};

/** Project progress stats. */
export type Github_ProjectProgress = {
  /** The number of done cards. */
  doneCount: Scalars['Int'];
  /** The percentage of done cards. */
  donePercentage: Scalars['Float'];
  /** Whether progress tracking is enabled and cards with purpose exist for this project */
  enabled: Scalars['Boolean'];
  /** The number of in-progress cards. */
  inProgressCount: Scalars['Int'];
  /** The percentage of in-progress cards. */
  inProgressPercentage: Scalars['Float'];
  /** The number of to do cards. */
  todoCount: Scalars['Int'];
  /** The percentage of to do cards. */
  todoPercentage: Scalars['Float'];
};

/** State of the project; either 'open' or 'closed' */
export type Github_ProjectState =
  /** The project is closed. */
  | 'CLOSED'
  /** The project is open. */
  | 'OPEN';

/** GitHub-provided templates for Projects */
export type Github_ProjectTemplate =
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  | 'AUTOMATED_KANBAN_V2'
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  | 'AUTOMATED_REVIEWS_KANBAN'
  /** Create a board with columns for To do, In progress and Done. */
  | 'BASIC_KANBAN'
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  | 'BUG_TRIAGE';

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2 = Github_Closable & Github_Node & Github_Updatable & {
  /** Returns true if the project is closed. */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who originally created the project. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** A field of the project */
  field?: Maybe<Github_ProjectV2FieldConfiguration>;
  /** List of fields and their constraints in the project */
  fields: Github_ProjectV2FieldConfigurationConnection;
  id: Scalars['ID'];
  /** List of items in the project */
  items: Github_ProjectV2ItemConnection;
  /** The project's number. */
  number: Scalars['Int'];
  /** The project's owner. Currently limited to organizations and users. */
  owner: Github_ProjectV2Owner;
  /** Returns true if the project is public. */
  public: Scalars['Boolean'];
  /** The project's readme. */
  readme?: Maybe<Scalars['String']>;
  /** The repositories the project is linked to. */
  repositories: Github_RepositoryConnection;
  /** The HTTP path for this project */
  resourcePath: Scalars['Github_URI'];
  /** The project's short description. */
  shortDescription?: Maybe<Scalars['String']>;
  /** The teams the project is linked to. */
  teams: Github_TeamConnection;
  /** The project's name. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project */
  url: Scalars['Github_URI'];
  /** A view of the project */
  view?: Maybe<Github_ProjectV2View>;
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** List of views in the project */
  views: Github_ProjectV2ViewConnection;
  /** A workflow of the project */
  workflow?: Maybe<Github_ProjectV2Workflow>;
  /** List of the workflows in the project */
  workflows: Github_ProjectV2WorkflowConnection;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2fieldArgs = {
  name: Scalars['String'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2fieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2itemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2ItemOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2repositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2teamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2viewArgs = {
  number: Scalars['Int'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2viewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2ViewOrder>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2workflowArgs = {
  number: Scalars['Int'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectV2workflowsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2WorkflowOrder>;
};

/** The connection type for ProjectV2. */
export type Github_ProjectV2Connection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2Edge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2Edge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2>;
};

/** A field inside a project. */
export type Github_ProjectV2Field = Github_Node & Github_ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The field's type. */
  dataType: Github_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project field's name. */
  name: Scalars['String'];
  /** The project that contains this field. */
  project: Github_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** Common fields across different project field types */
export type Github_ProjectV2FieldCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The field's type. */
  dataType: Github_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project field's name. */
  name: Scalars['String'];
  /** The project that contains this field. */
  project: Github_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** Configurations for project fields. */
export type Github_ProjectV2FieldConfiguration = Github_ProjectV2Field | Github_ProjectV2IterationField | Github_ProjectV2SingleSelectField;

/** The connection type for ProjectV2FieldConfiguration. */
export type Github_ProjectV2FieldConfigurationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2FieldConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2FieldConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2FieldConfigurationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2FieldConfiguration>;
};

/** The connection type for ProjectV2Field. */
export type Github_ProjectV2FieldConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2FieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2Field>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2FieldEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2Field>;
};

/** Ordering options for project v2 field connections */
export type Github_ProjectV2FieldOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order the project v2 fields by. */
  field: Github_ProjectV2FieldOrderField;
};

/** Properties by which project v2 field connections can be ordered. */
export type Github_ProjectV2FieldOrderField =
  /** Order project v2 fields by creation time */
  | 'CREATED_AT'
  /** Order project v2 fields by name */
  | 'NAME'
  /** Order project v2 fields by position */
  | 'POSITION';

/** The type of a project field. */
export type Github_ProjectV2FieldType =
  /** Assignees */
  | 'ASSIGNEES'
  /** Date */
  | 'DATE'
  /** Iteration */
  | 'ITERATION'
  /** Labels */
  | 'LABELS'
  /** Linked Pull Requests */
  | 'LINKED_PULL_REQUESTS'
  /** Milestone */
  | 'MILESTONE'
  /** Number */
  | 'NUMBER'
  /** Repository */
  | 'REPOSITORY'
  /** Reviewers */
  | 'REVIEWERS'
  /** Single Select */
  | 'SINGLE_SELECT'
  /** Text */
  | 'TEXT'
  /** Title */
  | 'TITLE'
  /** Tracked by */
  | 'TRACKED_BY'
  /** Tracks */
  | 'TRACKS';

/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */
export type Github_ProjectV2FieldValue = {
  /** The ISO 8601 date to set on the field. */
  date?: InputMaybe<Scalars['Date']>;
  /** The id of the iteration to set on the field. */
  iterationId?: InputMaybe<Scalars['String']>;
  /** The number to set on the field. */
  number?: InputMaybe<Scalars['Float']>;
  /** The id of the single select option to set on the field. */
  singleSelectOptionId?: InputMaybe<Scalars['String']>;
  /** The text to set on the field. */
  text?: InputMaybe<Scalars['String']>;
};

/** Ways in which to filter lists of projects. */
export type Github_ProjectV2Filters = {
  /** List project v2 filtered by the state given. */
  state?: InputMaybe<Github_ProjectV2State>;
};

/** An item within a Project. */
export type Github_ProjectV2Item = Github_Node & {
  /** The content of the referenced draft issue, issue, or pull request */
  content?: Maybe<Github_ProjectV2ItemContent>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** A specific field value given a field name */
  fieldValueByName?: Maybe<Github_ProjectV2ItemFieldValue>;
  /** List of field values */
  fieldValues: Github_ProjectV2ItemFieldValueConnection;
  id: Scalars['ID'];
  /** Whether the item is archived. */
  isArchived: Scalars['Boolean'];
  /** The project that contains this item. */
  project: Github_ProjectV2;
  /** The type of the item. */
  type: Github_ProjectV2ItemType;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** An item within a Project. */
export type Github_ProjectV2ItemfieldValueByNameArgs = {
  name: Scalars['String'];
};


/** An item within a Project. */
export type Github_ProjectV2ItemfieldValuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2ItemFieldValueOrder>;
};

/** The connection type for ProjectV2Item. */
export type Github_ProjectV2ItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2ItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2Item>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Types that can be inside Project Items. */
export type Github_ProjectV2ItemContent = Github_DraftIssue | Github_Issue | Github_PullRequest;

/** An edge in a connection. */
export type Github_ProjectV2ItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2Item>;
};

/** The value of a date field in a Project item. */
export type Github_ProjectV2ItemFieldDateValue = Github_Node & Github_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Date value for the field */
  date?: Maybe<Scalars['Date']>;
  /** The project field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  id: Scalars['ID'];
  /** The project item that contains this value. */
  item: Github_ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The value of an iteration field in a Project item. */
export type Github_ProjectV2ItemFieldIterationValue = Github_Node & Github_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The duration of the iteration in days. */
  duration: Scalars['Int'];
  /** The project field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  id: Scalars['ID'];
  /** The project item that contains this value. */
  item: Github_ProjectV2Item;
  /** The ID of the iteration. */
  iterationId: Scalars['String'];
  /** The start date of the iteration. */
  startDate: Scalars['Date'];
  /** The title of the iteration. */
  title: Scalars['String'];
  /** The title of the iteration, with HTML. */
  titleHTML: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The value of the labels field in a Project item. */
export type Github_ProjectV2ItemFieldLabelValue = {
  /** The field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  /** Labels value of a field */
  labels?: Maybe<Github_LabelConnection>;
};


/** The value of the labels field in a Project item. */
export type Github_ProjectV2ItemFieldLabelValuelabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The value of a milestone field in a Project item. */
export type Github_ProjectV2ItemFieldMilestoneValue = {
  /** The field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  /** Milestone value of a field */
  milestone?: Maybe<Github_Milestone>;
};

/** The value of a number field in a Project item. */
export type Github_ProjectV2ItemFieldNumberValue = Github_Node & Github_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The project field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  id: Scalars['ID'];
  /** The project item that contains this value. */
  item: Github_ProjectV2Item;
  /** Number as a float(8) */
  number?: Maybe<Scalars['Float']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The value of a pull request field in a Project item. */
export type Github_ProjectV2ItemFieldPullRequestValue = {
  /** The field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  /** The pull requests for this field */
  pullRequests?: Maybe<Github_PullRequestConnection>;
};


/** The value of a pull request field in a Project item. */
export type Github_ProjectV2ItemFieldPullRequestValuepullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PullRequestOrder>;
};

/** The value of a repository field in a Project item. */
export type Github_ProjectV2ItemFieldRepositoryValue = {
  /** The field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  /** The repository for this field. */
  repository?: Maybe<Github_Repository>;
};

/** The value of a reviewers field in a Project item. */
export type Github_ProjectV2ItemFieldReviewerValue = {
  /** The field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  /** The reviewers for this field. */
  reviewers?: Maybe<Github_RequestedReviewerConnection>;
};


/** The value of a reviewers field in a Project item. */
export type Github_ProjectV2ItemFieldReviewerValuereviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The value of a single select field in a Project item. */
export type Github_ProjectV2ItemFieldSingleSelectValue = Github_Node & Github_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The project field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  id: Scalars['ID'];
  /** The project item that contains this value. */
  item: Github_ProjectV2Item;
  /** The name of the selected single select option. */
  name?: Maybe<Scalars['String']>;
  /** The html name of the selected single select option. */
  nameHTML?: Maybe<Scalars['String']>;
  /** The id of the selected single select option. */
  optionId?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The value of a text field in a Project item. */
export type Github_ProjectV2ItemFieldTextValue = Github_Node & Github_ProjectV2ItemFieldValueCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The project field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  id: Scalars['ID'];
  /** The project item that contains this value. */
  item: Github_ProjectV2Item;
  /** Text value of a field */
  text?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The value of a user field in a Project item. */
export type Github_ProjectV2ItemFieldUserValue = {
  /** The field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  /** The users for this field */
  users?: Maybe<Github_UserConnection>;
};


/** The value of a user field in a Project item. */
export type Github_ProjectV2ItemFieldUserValueusersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Project field values */
export type Github_ProjectV2ItemFieldValue = Github_ProjectV2ItemFieldDateValue | Github_ProjectV2ItemFieldIterationValue | Github_ProjectV2ItemFieldLabelValue | Github_ProjectV2ItemFieldMilestoneValue | Github_ProjectV2ItemFieldNumberValue | Github_ProjectV2ItemFieldPullRequestValue | Github_ProjectV2ItemFieldRepositoryValue | Github_ProjectV2ItemFieldReviewerValue | Github_ProjectV2ItemFieldSingleSelectValue | Github_ProjectV2ItemFieldTextValue | Github_ProjectV2ItemFieldUserValue;

/** Common fields across different project field value types */
export type Github_ProjectV2ItemFieldValueCommon = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The project field that contains this value. */
  field: Github_ProjectV2FieldConfiguration;
  id: Scalars['ID'];
  /** The project item that contains this value. */
  item: Github_ProjectV2Item;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for ProjectV2ItemFieldValue. */
export type Github_ProjectV2ItemFieldValueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2ItemFieldValueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2ItemFieldValue>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2ItemFieldValueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2ItemFieldValue>;
};

/** Ordering options for project v2 item field value connections */
export type Github_ProjectV2ItemFieldValueOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order the project v2 item field values by. */
  field: Github_ProjectV2ItemFieldValueOrderField;
};

/** Properties by which project v2 item field value connections can be ordered. */
export type Github_ProjectV2ItemFieldValueOrderField =
  /** Order project v2 item field values by the their position in the project */
  | 'POSITION';

/** Ordering options for project v2 item connections */
export type Github_ProjectV2ItemOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order the project v2 items by. */
  field: Github_ProjectV2ItemOrderField;
};

/** Properties by which project v2 item connections can be ordered. */
export type Github_ProjectV2ItemOrderField =
  /** Order project v2 items by the their position in the project */
  | 'POSITION';

/** The type of a project item. */
export type Github_ProjectV2ItemType =
  /** Draft Issue */
  | 'DRAFT_ISSUE'
  /** Issue */
  | 'ISSUE'
  /** Pull Request */
  | 'PULL_REQUEST'
  /** Redacted Item */
  | 'REDACTED';

/** An iteration field inside a project. */
export type Github_ProjectV2IterationField = Github_Node & Github_ProjectV2FieldCommon & {
  /** Iteration configuration settings */
  configuration: Github_ProjectV2IterationFieldConfiguration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The field's type. */
  dataType: Github_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project field's name. */
  name: Scalars['String'];
  /** The project that contains this field. */
  project: Github_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** Iteration field configuration for a project. */
export type Github_ProjectV2IterationFieldConfiguration = {
  /** The iteration's completed iterations */
  completedIterations: Array<Github_ProjectV2IterationFieldIteration>;
  /** The iteration's duration in days */
  duration: Scalars['Int'];
  /** The iteration's iterations */
  iterations: Array<Github_ProjectV2IterationFieldIteration>;
  /** The iteration's start day of the week */
  startDay: Scalars['Int'];
};

/** Iteration field iteration settings for a project. */
export type Github_ProjectV2IterationFieldIteration = {
  /** The iteration's duration in days */
  duration: Scalars['Int'];
  /** The iteration's ID. */
  id: Scalars['String'];
  /** The iteration's start date */
  startDate: Scalars['Date'];
  /** The iteration's title. */
  title: Scalars['String'];
  /** The iteration's html title. */
  titleHTML: Scalars['String'];
};

/** Ways in which lists of projects can be ordered upon return. */
export type Github_ProjectV2Order = {
  /** The direction in which to order projects by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order projects by. */
  field: Github_ProjectV2OrderField;
};

/** Properties by which projects can be ordered. */
export type Github_ProjectV2OrderField =
  /** The project's date and time of creation */
  | 'CREATED_AT'
  /** The project's number */
  | 'NUMBER'
  /** The project's title */
  | 'TITLE'
  /** The project's date and time of update */
  | 'UPDATED_AT';

/** Represents an owner of a project (beta). */
export type Github_ProjectV2Owner = {
  id: Scalars['ID'];
  /** Find a project by number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: Github_ProjectV2Connection;
};


/** Represents an owner of a project (beta). */
export type Github_ProjectV2OwnerprojectV2Args = {
  number: Scalars['Int'];
};


/** Represents an owner of a project (beta). */
export type Github_ProjectV2OwnerprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};

/** Recent projects for the owner. */
export type Github_ProjectV2Recent = {
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: Github_ProjectV2Connection;
};


/** Recent projects for the owner. */
export type Github_ProjectV2RecentrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A single select field inside a project. */
export type Github_ProjectV2SingleSelectField = Github_Node & Github_ProjectV2FieldCommon & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The field's type. */
  dataType: Github_ProjectV2FieldType;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project field's name. */
  name: Scalars['String'];
  /** Options for the single select field */
  options: Array<Github_ProjectV2SingleSelectFieldOption>;
  /** The project that contains this field. */
  project: Github_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** Single select field option for a configuration for a project. */
export type Github_ProjectV2SingleSelectFieldOption = {
  /** The option's ID. */
  id: Scalars['String'];
  /** The option's name. */
  name: Scalars['String'];
  /** The option's html name. */
  nameHTML: Scalars['String'];
};

/** Represents a sort by field and direction. */
export type Github_ProjectV2SortBy = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: Github_OrderDirection;
  /** The field by which items are sorted. */
  field: Github_ProjectV2Field;
};

/** The connection type for ProjectV2SortBy. */
export type Github_ProjectV2SortByConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2SortByEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2SortBy>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2SortByEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2SortBy>;
};

/** Represents a sort by field and direction. */
export type Github_ProjectV2SortByField = {
  /** The direction of the sorting. Possible values are ASC and DESC. */
  direction: Github_OrderDirection;
  /** The field by which items are sorted. */
  field: Github_ProjectV2FieldConfiguration;
};

/** The connection type for ProjectV2SortByField. */
export type Github_ProjectV2SortByFieldConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2SortByFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2SortByField>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2SortByFieldEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2SortByField>;
};

/** The possible states of a project v2. */
export type Github_ProjectV2State =
  /** A project v2 that has been closed */
  | 'CLOSED'
  /** A project v2 that is still open */
  | 'OPEN';

/** A view within a ProjectV2. */
export type Github_ProjectV2View = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The view's visible fields. */
  fields?: Maybe<Github_ProjectV2FieldConfigurationConnection>;
  /** The project view's filter. */
  filter?: Maybe<Scalars['String']>;
  /**
   * The view's group-by field.
   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  groupBy?: Maybe<Github_ProjectV2FieldConnection>;
  /** The view's group-by field. */
  groupByFields?: Maybe<Github_ProjectV2FieldConfigurationConnection>;
  id: Scalars['ID'];
  /** The project view's layout. */
  layout: Github_ProjectV2ViewLayout;
  /** The project view's name. */
  name: Scalars['String'];
  /** The project view's number. */
  number: Scalars['Int'];
  /** The project that contains this view. */
  project: Github_ProjectV2;
  /**
   * The view's sort-by config.
   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  sortBy?: Maybe<Github_ProjectV2SortByConnection>;
  /** The view's sort-by config. */
  sortByFields?: Maybe<Github_ProjectV2SortByFieldConnection>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /**
   * The view's vertical-group-by field.
   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.
   */
  verticalGroupBy?: Maybe<Github_ProjectV2FieldConnection>;
  /** The view's vertical-group-by field. */
  verticalGroupByFields?: Maybe<Github_ProjectV2FieldConfigurationConnection>;
  /**
   * The view's visible fields.
   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.
   */
  visibleFields?: Maybe<Github_ProjectV2FieldConnection>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewfieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewgroupByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewgroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewsortByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewsortByFieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewverticalGroupByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewverticalGroupByFieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};


/** A view within a ProjectV2. */
export type Github_ProjectV2ViewvisibleFieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2FieldOrder>;
};

/** The connection type for ProjectV2View. */
export type Github_ProjectV2ViewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2ViewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2View>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2ViewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2View>;
};

/** The layout of a project v2 view. */
export type Github_ProjectV2ViewLayout =
  /** Board layout */
  | 'BOARD_LAYOUT'
  /** Table layout */
  | 'TABLE_LAYOUT';

/** Ordering options for project v2 view connections */
export type Github_ProjectV2ViewOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order the project v2 views by. */
  field: Github_ProjectV2ViewOrderField;
};

/** Properties by which project v2 view connections can be ordered. */
export type Github_ProjectV2ViewOrderField =
  /** Order project v2 views by creation time */
  | 'CREATED_AT'
  /** Order project v2 views by name */
  | 'NAME'
  /** Order project v2 views by position */
  | 'POSITION';

/** A workflow inside a project. */
export type Github_ProjectV2Workflow = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The workflows' enabled state. */
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  /** The workflows' name. */
  name: Scalars['String'];
  /** The workflows' number. */
  number: Scalars['Int'];
  /** The project that contains this workflow. */
  project: Github_ProjectV2;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for ProjectV2Workflow. */
export type Github_ProjectV2WorkflowConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectV2WorkflowEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectV2Workflow>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectV2WorkflowEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectV2Workflow>;
};

/** Ordering options for project v2 workflows connections */
export type Github_ProjectV2WorkflowOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order the project v2 workflows by. */
  field: Github_ProjectV2WorkflowsOrderField;
};

/** Properties by which project workflows can be ordered. */
export type Github_ProjectV2WorkflowsOrderField =
  /** The workflows' date and time of creation */
  | 'CREATED_AT'
  /** The workflows' name */
  | 'NAME'
  /** The workflows' number */
  | 'NUMBER'
  /** The workflows' date and time of update */
  | 'UPDATED_AT';

/** A user's public key. */
export type Github_PublicKey = Github_Node & {
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars['String'];
  id: Scalars['ID'];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars['Boolean']>;
  /** The public key string. */
  key: Scalars['String'];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for PublicKey. */
export type Github_PublicKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PublicKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PublicKey>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PublicKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PublicKey>;
};

/** Autogenerated input type of PublishSponsorsTier */
export type Github_PublishSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the draft tier to publish. */
  tierId: Scalars['ID'];
};

/** Autogenerated return type of PublishSponsorsTier */
export type Github_PublishSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The tier that was published. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
};

/** A repository pull request. */
export type Github_PullRequest = Github_Assignable & Github_Closable & Github_Comment & Github_Labelable & Github_Lockable & Github_Node & Github_ProjectV2Owner & Github_Reactable & Github_RepositoryNode & Github_Subscribable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** The number of additions in this pull request. */
  additions: Scalars['Int'];
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Returns the auto-merge request object if one exists for this pull request. */
  autoMergeRequest?: Maybe<Github_AutoMergeRequest>;
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Maybe<Github_Ref>;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: Scalars['String'];
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: Scalars['Github_GitObjectID'];
  /** The repository associated with this pull request's base Ref. */
  baseRepository?: Maybe<Github_Repository>;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Whether or not the pull request is rebaseable. */
  canBeRebased: Scalars['Boolean'];
  /** The number of changed files in this pull request. */
  changedFiles: Scalars['Int'];
  /** The HTTP path for the checks of this pull request. */
  checksResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the checks of this pull request. */
  checksUrl: Scalars['Github_URI'];
  /** `true` if the pull request is closed */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** List of issues that were may be closed by this pull request */
  closingIssuesReferences?: Maybe<Github_IssueConnection>;
  /** A list of comments associated with the pull request. */
  comments: Github_IssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: Github_PullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The number of deletions in this pull request. */
  deletions: Scalars['Int'];
  /** The actor who edited this pull request's body. */
  editor?: Maybe<Github_Actor>;
  /** Lists the files changed within this pull request. */
  files?: Maybe<Github_PullRequestChangedFileConnection>;
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Maybe<Github_Ref>;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: Scalars['String'];
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: Scalars['Github_GitObjectID'];
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Maybe<Github_Repository>;
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: Maybe<Github_RepositoryOwner>;
  /** The hovercard information for this issue */
  hovercard: Github_Hovercard;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The head and base repositories are different. */
  isCrossRepository: Scalars['Boolean'];
  /** Identifies if the pull request is a draft. */
  isDraft: Scalars['Boolean'];
  /** Is this pull request read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** A list of latest reviews per user associated with the pull request. */
  latestOpinionatedReviews?: Maybe<Github_PullRequestReviewConnection>;
  /** A list of latest reviews per user associated with the pull request that are not also pending review. */
  latestReviews?: Maybe<Github_PullRequestReviewConnection>;
  /** `true` if the pull request is locked */
  locked: Scalars['Boolean'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: Scalars['Boolean'];
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Maybe<Github_Commit>;
  /** Detailed information about the current pull request merge state status. */
  mergeStateStatus: Github_MergeStateStatus;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: Github_MergeableState;
  /** Whether or not the pull request was merged. */
  merged: Scalars['Boolean'];
  /** The date and time that the pull request was merged. */
  mergedAt?: Maybe<Scalars['DateTime']>;
  /** The actor who merged the pull request. */
  mergedBy?: Maybe<Github_Actor>;
  /** Identifies the milestone associated with the pull request. */
  milestone?: Maybe<Github_Milestone>;
  /** Identifies the pull request number. */
  number: Scalars['Int'];
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: Github_UserConnection;
  /** The permalink to the pull request. */
  permalink: Scalars['Github_URI'];
  /**
   * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
   */
  potentialMergeCommit?: Maybe<Github_Commit>;
  /** List of project cards associated with this pull request. */
  projectCards: Github_ProjectCardConnection;
  /** List of project items associated with this pull request. */
  projectItems: Github_ProjectV2ItemConnection;
  /** Find a project by number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** A list of projects under the owner. */
  projectsV2: Github_ProjectV2Connection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for reverting this pull request. */
  revertUrl: Scalars['Github_URI'];
  /** The current status of this pull request with respect to code review. */
  reviewDecision?: Maybe<Github_PullRequestReviewDecision>;
  /** A list of review requests associated with the pull request. */
  reviewRequests?: Maybe<Github_ReviewRequestConnection>;
  /** The list of all review threads for this pull request. */
  reviewThreads: Github_PullRequestReviewThreadConnection;
  /** A list of reviews associated with the pull request. */
  reviews?: Maybe<Github_PullRequestReviewConnection>;
  /** Identifies the state of the pull request. */
  state: Github_PullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers: Array<Maybe<Github_SuggestedReviewer>>;
  /**
   * A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: Github_PullRequestTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timelineItems: Github_PullRequestTimelineItemsConnection;
  /** Identifies the pull request title. */
  title: Scalars['String'];
  /** Identifies the pull request title rendered to HTML. */
  titleHTML: Scalars['Github_HTML'];
  /** Returns a count of how many comments this pull request has received. */
  totalCommentsCount?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this pull request. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: Scalars['Boolean'];
  /** Check if the viewer can restore the deleted head ref. */
  viewerCanDeleteHeadRef: Scalars['Boolean'];
  /** Whether or not the viewer can disable auto-merge */
  viewerCanDisableAutoMerge: Scalars['Boolean'];
  /** Can the viewer edit files within this pull request. */
  viewerCanEditFiles: Scalars['Boolean'];
  /** Whether or not the viewer can enable auto-merge */
  viewerCanEnableAutoMerge: Scalars['Boolean'];
  /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */
  viewerCanMergeAsAdmin: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** The latest review given from the viewer. */
  viewerLatestReview?: Maybe<Github_PullRequestReview>;
  /** The person who has requested the viewer for review on this pull request. */
  viewerLatestReviewRequest?: Maybe<Github_ReviewRequest>;
  /** The merge body text for the viewer and method. */
  viewerMergeBodyText: Scalars['String'];
  /** The merge headline text for the viewer and method. */
  viewerMergeHeadlineText: Scalars['String'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A repository pull request. */
export type Github_PullRequestassigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestclosingIssuesReferencesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  userLinkedOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A repository pull request. */
export type Github_PullRequestcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueCommentOrder>;
};


/** A repository pull request. */
export type Github_PullRequestcommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequesthovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']>;
};


/** A repository pull request. */
export type Github_PullRequestlabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};


/** A repository pull request. */
export type Github_PullRequestlatestOpinionatedReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  writersOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A repository pull request. */
export type Github_PullRequestlatestReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestparticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestprojectCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestprojectItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestprojectV2Args = {
  number: Scalars['Int'];
};


/** A repository pull request. */
export type Github_PullRequestprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository pull request. */
export type Github_PullRequestreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A repository pull request. */
export type Github_PullRequestreviewRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestreviewThreadsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestreviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  states?: InputMaybe<Array<Github_PullRequestReviewState>>;
};


/** A repository pull request. */
export type Github_PullRequesttimelineArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
};


/** A repository pull request. */
export type Github_PullRequesttimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  itemTypes?: InputMaybe<Array<Github_PullRequestTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestviewerMergeBodyTextArgs = {
  mergeType?: InputMaybe<Github_PullRequestMergeMethod>;
};


/** A repository pull request. */
export type Github_PullRequestviewerMergeHeadlineTextArgs = {
  mergeType?: InputMaybe<Github_PullRequestMergeMethod>;
};

/** A file changed in a pull request. */
export type Github_PullRequestChangedFile = {
  /** The number of additions to the file. */
  additions: Scalars['Int'];
  /** How the file was changed in this PullRequest */
  changeType: Github_PatchStatus;
  /** The number of deletions to the file. */
  deletions: Scalars['Int'];
  /** The path of the file. */
  path: Scalars['String'];
  /** The state of the file for the viewer. */
  viewerViewedState: Github_FileViewedState;
};

/** The connection type for PullRequestChangedFile. */
export type Github_PullRequestChangedFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestChangedFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
export type Github_PullRequestCommit = Github_Node & Github_UniformResourceLocatable & {
  /** The Git commit object */
  commit: Github_Commit;
  id: Scalars['ID'];
  /** The pull request this commit belongs to */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this pull request commit */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this pull request commit */
  url: Scalars['Github_URI'];
};

/** Represents a commit comment thread part of a pull request. */
export type Github_PullRequestCommitCommentThread = Github_Node & Github_RepositoryNode & {
  /** The comments that exist in this thread. */
  comments: Github_CommitCommentConnection;
  /** The commit the comments were made on. */
  commit: Github_Commit;
  id: Scalars['ID'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>;
  /** The pull request this commit comment thread belongs to */
  pullRequest: Github_PullRequest;
  /** The repository associated with this node. */
  repository: Github_Repository;
};


/** Represents a commit comment thread part of a pull request. */
export type Github_PullRequestCommitCommentThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PullRequestCommit. */
export type Github_PullRequestCommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestCommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestCommit>;
};

/** The connection type for PullRequest. */
export type Github_PullRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates pull requests opened by a user within one repository. */
export type Github_PullRequestContributionsByRepository = {
  /** The pull request contributions. */
  contributions: Github_CreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  repository: Github_Repository;
};


/** This aggregates pull requests opened by a user within one repository. */
export type Github_PullRequestContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};

/** An edge in a connection. */
export type Github_PullRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
export type Github_PullRequestMergeMethod =
  /** Add all commits from the head branch to the base branch with a merge commit. */
  | 'MERGE'
  /** Add all commits from the head branch onto the base branch individually. */
  | 'REBASE'
  /** Combine all commits from the head branch into a single commit in the base branch. */
  | 'SQUASH';

/** Ways in which lists of issues can be ordered upon return. */
export type Github_PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order pull requests by. */
  field: Github_PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export type Github_PullRequestOrderField =
  /** Order pull_requests by creation time */
  | 'CREATED_AT'
  /** Order pull_requests by update time */
  | 'UPDATED_AT';

/** A review object for a given pull request. */
export type Github_PullRequestReview = Github_Comment & Github_Deletable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Indicates whether the author of this review has push access to the repository. */
  authorCanPushToRepository: Scalars['Boolean'];
  /** Identifies the pull request review body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body of this review rendered as plain text. */
  bodyText: Scalars['String'];
  /** A list of review comments for the current pull request review. */
  comments: Github_PullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** A list of teams that this review was made on behalf of. */
  onBehalfOf: Github_TeamConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: Github_PullRequest;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the current state of the pull request review. */
  state: Github_PullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this PullRequestReview. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewonBehalfOfArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A review comment associated with a given repository pull request. */
export type Github_PullRequestReviewComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The comment body of this review comment. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The comment body of this review comment rendered as plain text. */
  bodyText: Scalars['String'];
  /** Identifies the commit associated with the comment. */
  commit?: Maybe<Github_Commit>;
  /** Identifies when the comment was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The diff hunk to which the comment applies. */
  diffHunk: Scalars['String'];
  /** Identifies when the comment was created in a draft state. */
  draftedAt: Scalars['DateTime'];
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns why the comment was minimized. One of `abuse`, `off-topic`,
   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and
   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.
   */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Maybe<Github_Commit>;
  /** The original line index in the diff to which the comment applies. */
  originalPosition: Scalars['Int'];
  /** Identifies when the comment body is outdated */
  outdated: Scalars['Boolean'];
  /** The path to which the comment applies. */
  path: Scalars['String'];
  /** The line index in the diff to which the comment applies. */
  position?: Maybe<Scalars['Int']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** The pull request associated with this review comment. */
  pullRequest: Github_PullRequest;
  /** The pull request review associated with this review comment. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The comment this is a reply to. */
  replyTo?: Maybe<Github_PullRequestReviewComment>;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path permalink for this review comment. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the state of the comment. */
  state: Github_PullRequestReviewCommentState;
  /** Identifies when the comment was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this review comment. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A review comment associated with a given repository pull request. */
export type Github_PullRequestReviewCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A review comment associated with a given repository pull request. */
export type Github_PullRequestReviewCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PullRequestReviewComment. */
export type Github_PullRequestReviewCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestReviewCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
export type Github_PullRequestReviewCommentState =
  /** A comment that is part of a pending review */
  | 'PENDING'
  /** A comment that is part of a submitted review */
  | 'SUBMITTED';

/** The connection type for PullRequestReview. */
export type Github_PullRequestReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestReview>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates pull request reviews made by a user within one repository. */
export type Github_PullRequestReviewContributionsByRepository = {
  /** The pull request review contributions. */
  contributions: Github_CreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  repository: Github_Repository;
};


/** This aggregates pull request reviews made by a user within one repository. */
export type Github_PullRequestReviewContributionsByRepositorycontributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};

/** The review status of a pull request. */
export type Github_PullRequestReviewDecision =
  /** The pull request has received an approving review. */
  | 'APPROVED'
  /** Changes have been requested on the pull request. */
  | 'CHANGES_REQUESTED'
  /** A review is required before the pull request can be merged. */
  | 'REVIEW_REQUIRED';

/** An edge in a connection. */
export type Github_PullRequestReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestReview>;
};

/** The possible events to perform on a pull request review. */
export type Github_PullRequestReviewEvent =
  /** Submit feedback and approve merging these changes. */
  | 'APPROVE'
  /** Submit general feedback without explicit approval. */
  | 'COMMENT'
  /** Dismiss review so it now longer effects merging. */
  | 'DISMISS'
  /** Submit feedback that must be addressed before merging. */
  | 'REQUEST_CHANGES';

/** The possible states of a pull request review. */
export type Github_PullRequestReviewState =
  /** A review allowing the pull request to merge. */
  | 'APPROVED'
  /** A review blocking the pull request from merging. */
  | 'CHANGES_REQUESTED'
  /** An informational review. */
  | 'COMMENTED'
  /** A review that has been dismissed. */
  | 'DISMISSED'
  /** A review that has not yet been submitted. */
  | 'PENDING';

/** A threaded list of comments for a given pull request. */
export type Github_PullRequestReviewThread = Github_Node & {
  /** A list of pull request comments associated with the thread. */
  comments: Github_PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: Github_DiffSide;
  id: Scalars['ID'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']>;
  /** The original line in the file to which this thread refers. */
  originalLine?: Maybe<Scalars['Int']>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  originalStartLine?: Maybe<Scalars['Int']>;
  /** Identifies the file path of this thread. */
  path: Scalars['String'];
  /** Identifies the pull request associated with this thread. */
  pullRequest: Github_PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Github_Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<Github_User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<Github_DiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  startLine?: Maybe<Scalars['Int']>;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean'];
};


/** A threaded list of comments for a given pull request. */
export type Github_PullRequestReviewThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
};

/** Review comment threads for a pull request review. */
export type Github_PullRequestReviewThreadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestReviewThreadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestReviewThread>;
};

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type Github_PullRequestRevisionMarker = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The last commit the viewer has seen. */
  lastSeenCommit: Github_Commit;
  /** The pull request to which the marker belongs. */
  pullRequest: Github_PullRequest;
};

/** The possible states of a pull request. */
export type Github_PullRequestState =
  /** A pull request that has been closed without being merged. */
  | 'CLOSED'
  /** A pull request that has been closed by being merged. */
  | 'MERGED'
  /** A pull request that is still open. */
  | 'OPEN';

/** A repository pull request template. */
export type Github_PullRequestTemplate = {
  /** The body of the template */
  body?: Maybe<Scalars['String']>;
  /** The filename of the template */
  filename?: Maybe<Scalars['String']>;
  /** The repository the template belongs to */
  repository: Github_Repository;
};

/** A threaded list of comments for a given pull request. */
export type Github_PullRequestThread = Github_Node & {
  /** A list of pull request comments associated with the thread. */
  comments: Github_PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: Github_DiffSide;
  id: Scalars['ID'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']>;
  /** Identifies the pull request associated with this thread. */
  pullRequest: Github_PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Github_Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<Github_User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<Github_DiffSide>;
  /** The line of the first file diff in the thread. */
  startLine?: Maybe<Scalars['Int']>;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean'];
};


/** A threaded list of comments for a given pull request. */
export type Github_PullRequestThreadcommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PullRequestTimelineItem. */
export type Github_PullRequestTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An item in a pull request timeline */
export type Github_PullRequestTimelineItem = Github_AssignedEvent | Github_BaseRefDeletedEvent | Github_BaseRefForcePushedEvent | Github_ClosedEvent | Github_Commit | Github_CommitCommentThread | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_DeployedEvent | Github_DeploymentEnvironmentChangedEvent | Github_HeadRefDeletedEvent | Github_HeadRefForcePushedEvent | Github_HeadRefRestoredEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MergedEvent | Github_MilestonedEvent | Github_PullRequestReview | Github_PullRequestReviewComment | Github_PullRequestReviewThread | Github_ReferencedEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_ReviewDismissedEvent | Github_ReviewRequestRemovedEvent | Github_ReviewRequestedEvent | Github_SubscribedEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** An edge in a connection. */
export type Github_PullRequestTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestTimelineItem>;
};

/** An item in a pull request timeline */
export type Github_PullRequestTimelineItems = Github_AddedToProjectEvent | Github_AssignedEvent | Github_AutoMergeDisabledEvent | Github_AutoMergeEnabledEvent | Github_AutoRebaseEnabledEvent | Github_AutoSquashEnabledEvent | Github_AutomaticBaseChangeFailedEvent | Github_AutomaticBaseChangeSucceededEvent | Github_BaseRefChangedEvent | Github_BaseRefDeletedEvent | Github_BaseRefForcePushedEvent | Github_ClosedEvent | Github_CommentDeletedEvent | Github_ConnectedEvent | Github_ConvertToDraftEvent | Github_ConvertedNoteToIssueEvent | Github_ConvertedToDiscussionEvent | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_DeployedEvent | Github_DeploymentEnvironmentChangedEvent | Github_DisconnectedEvent | Github_HeadRefDeletedEvent | Github_HeadRefForcePushedEvent | Github_HeadRefRestoredEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MarkedAsDuplicateEvent | Github_MentionedEvent | Github_MergedEvent | Github_MilestonedEvent | Github_MovedColumnsInProjectEvent | Github_PinnedEvent | Github_PullRequestCommit | Github_PullRequestCommitCommentThread | Github_PullRequestReview | Github_PullRequestReviewThread | Github_PullRequestRevisionMarker | Github_ReadyForReviewEvent | Github_ReferencedEvent | Github_RemovedFromProjectEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_ReviewDismissedEvent | Github_ReviewRequestRemovedEvent | Github_ReviewRequestedEvent | Github_SubscribedEvent | Github_TransferredEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnmarkedAsDuplicateEvent | Github_UnpinnedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
export type Github_PullRequestTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** An edge in a connection. */
export type Github_PullRequestTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
export type Github_PullRequestTimelineItemsItemType =
  /** Represents an 'added_to_merge_queue' event on a given pull request. */
  | 'ADDED_TO_MERGE_QUEUE_EVENT'
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  | 'ADDED_TO_PROJECT_EVENT'
  /** Represents an 'assigned' event on any assignable object. */
  | 'ASSIGNED_EVENT'
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  | 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT'
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  | 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT'
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  | 'AUTO_MERGE_DISABLED_EVENT'
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  | 'AUTO_MERGE_ENABLED_EVENT'
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  | 'AUTO_REBASE_ENABLED_EVENT'
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  | 'AUTO_SQUASH_ENABLED_EVENT'
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  | 'BASE_REF_CHANGED_EVENT'
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  | 'BASE_REF_DELETED_EVENT'
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  | 'BASE_REF_FORCE_PUSHED_EVENT'
  /** Represents a 'closed' event on any `Closable`. */
  | 'CLOSED_EVENT'
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  | 'COMMENT_DELETED_EVENT'
  /** Represents a 'connected' event on a given issue or pull request. */
  | 'CONNECTED_EVENT'
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  | 'CONVERTED_NOTE_TO_ISSUE_EVENT'
  /** Represents a 'converted_to_discussion' event on a given issue. */
  | 'CONVERTED_TO_DISCUSSION_EVENT'
  /** Represents a 'convert_to_draft' event on a given pull request. */
  | 'CONVERT_TO_DRAFT_EVENT'
  /** Represents a mention made by one issue or pull request to another. */
  | 'CROSS_REFERENCED_EVENT'
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  | 'DEMILESTONED_EVENT'
  /** Represents a 'deployed' event on a given pull request. */
  | 'DEPLOYED_EVENT'
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  | 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT'
  /** Represents a 'disconnected' event on a given issue or pull request. */
  | 'DISCONNECTED_EVENT'
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  | 'HEAD_REF_DELETED_EVENT'
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  | 'HEAD_REF_FORCE_PUSHED_EVENT'
  /** Represents a 'head_ref_restored' event on a given pull request. */
  | 'HEAD_REF_RESTORED_EVENT'
  /** Represents a comment on an Issue. */
  | 'ISSUE_COMMENT'
  /** Represents a 'labeled' event on a given issue or pull request. */
  | 'LABELED_EVENT'
  /** Represents a 'locked' event on a given issue or pull request. */
  | 'LOCKED_EVENT'
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  | 'MARKED_AS_DUPLICATE_EVENT'
  /** Represents a 'mentioned' event on a given issue or pull request. */
  | 'MENTIONED_EVENT'
  /** Represents a 'merged' event on a given pull request. */
  | 'MERGED_EVENT'
  /** Represents a 'milestoned' event on a given issue or pull request. */
  | 'MILESTONED_EVENT'
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  | 'MOVED_COLUMNS_IN_PROJECT_EVENT'
  /** Represents a 'pinned' event on a given issue or pull request. */
  | 'PINNED_EVENT'
  /** Represents a Git commit part of a pull request. */
  | 'PULL_REQUEST_COMMIT'
  /** Represents a commit comment thread part of a pull request. */
  | 'PULL_REQUEST_COMMIT_COMMENT_THREAD'
  /** A review object for a given pull request. */
  | 'PULL_REQUEST_REVIEW'
  /** A threaded list of comments for a given pull request. */
  | 'PULL_REQUEST_REVIEW_THREAD'
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  | 'PULL_REQUEST_REVISION_MARKER'
  /** Represents a 'ready_for_review' event on a given pull request. */
  | 'READY_FOR_REVIEW_EVENT'
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  | 'REFERENCED_EVENT'
  /** Represents a 'removed_from_merge_queue' event on a given pull request. */
  | 'REMOVED_FROM_MERGE_QUEUE_EVENT'
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  | 'REMOVED_FROM_PROJECT_EVENT'
  /** Represents a 'renamed' event on a given issue or pull request */
  | 'RENAMED_TITLE_EVENT'
  /** Represents a 'reopened' event on any `Closable`. */
  | 'REOPENED_EVENT'
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  | 'REVIEW_DISMISSED_EVENT'
  /** Represents an 'review_requested' event on a given pull request. */
  | 'REVIEW_REQUESTED_EVENT'
  /** Represents an 'review_request_removed' event on a given pull request. */
  | 'REVIEW_REQUEST_REMOVED_EVENT'
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  | 'SUBSCRIBED_EVENT'
  /** Represents a 'transferred' event on a given issue or pull request. */
  | 'TRANSFERRED_EVENT'
  /** Represents an 'unassigned' event on any assignable object. */
  | 'UNASSIGNED_EVENT'
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  | 'UNLABELED_EVENT'
  /** Represents an 'unlocked' event on a given issue or pull request. */
  | 'UNLOCKED_EVENT'
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  | 'UNMARKED_AS_DUPLICATE_EVENT'
  /** Represents an 'unpinned' event on a given issue or pull request. */
  | 'UNPINNED_EVENT'
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  | 'UNSUBSCRIBED_EVENT'
  /** Represents a 'user_blocked' event on a given user. */
  | 'USER_BLOCKED_EVENT';

/** The possible target states when updating a pull request. */
export type Github_PullRequestUpdateState =
  /** A pull request that has been closed without being merged. */
  | 'CLOSED'
  /** A pull request that is still open. */
  | 'OPEN';

/** A Git push. */
export type Github_Push = Github_Node & {
  id: Scalars['ID'];
  /** The SHA after the push */
  nextSha?: Maybe<Scalars['Github_GitObjectID']>;
  /** The permalink for this push. */
  permalink: Scalars['Github_URI'];
  /** The SHA before the push */
  previousSha?: Maybe<Scalars['Github_GitObjectID']>;
  /** The actor who pushed */
  pusher: Github_Actor;
  /** The repository that was pushed to */
  repository: Github_Repository;
};

/** A team, user, or app who has the ability to push to a protected branch. */
export type Github_PushAllowance = Github_Node & {
  /** The actor that can push. */
  actor?: Maybe<Github_PushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** Types that can be an actor. */
export type Github_PushAllowanceActor = Github_App | Github_Team | Github_User;

/** The connection type for PushAllowance. */
export type Github_PushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PushAllowance>;
};

/** Represents the client's rate limit. */
export type Github_RateLimit = {
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars['Int'];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars['Int'];
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars['Int'];
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars['Int'];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars['DateTime'];
  /** The number of points used in the current rate limit window. */
  used: Scalars['Int'];
};

/** Represents a subject that can be reacted on. */
export type Github_Reactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
};


/** Represents a subject that can be reacted on. */
export type Github_ReactablereactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};

/** The connection type for User. */
export type Github_ReactingUserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReactingUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user that's made a reaction. */
export type Github_ReactingUserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_User;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime'];
};

/** An emoji reaction to a particular piece of content. */
export type Github_Reaction = Github_Node & {
  /** Identifies the emoji reaction. */
  content: Github_ReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The reactable piece of content */
  reactable: Github_Reactable;
  /** Identifies the user who created this reaction. */
  user?: Maybe<Github_User>;
};

/** A list of reactions that have been left on the subject. */
export type Github_ReactionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Reaction>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export type Github_ReactionContent =
  /** Represents the `:confused:` emoji. */
  | 'CONFUSED'
  /** Represents the `:eyes:` emoji. */
  | 'EYES'
  /** Represents the `:heart:` emoji. */
  | 'HEART'
  /** Represents the `:hooray:` emoji. */
  | 'HOORAY'
  /** Represents the `:laugh:` emoji. */
  | 'LAUGH'
  /** Represents the `:rocket:` emoji. */
  | 'ROCKET'
  /** Represents the `:-1:` emoji. */
  | 'THUMBS_DOWN'
  /** Represents the `:+1:` emoji. */
  | 'THUMBS_UP';

/** An edge in a connection. */
export type Github_ReactionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Reaction>;
};

/** A group of emoji reactions to a particular piece of content. */
export type Github_ReactionGroup = {
  /** Identifies the emoji reaction. */
  content: Github_ReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** Reactors to the reaction subject with the emotion represented by this reaction group. */
  reactors: Github_ReactorConnection;
  /** The subject that was reacted to. */
  subject: Github_Reactable;
  /**
   * Users who have reacted to the reaction subject with the emotion represented by this reaction group
   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.
   */
  users: Github_ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'];
};


/** A group of emoji reactions to a particular piece of content. */
export type Github_ReactionGroupreactorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A group of emoji reactions to a particular piece of content. */
export type Github_ReactionGroupusersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type Github_ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order reactions by. */
  field: Github_ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export type Github_ReactionOrderField =
  /** Allows ordering a list of reactions by when they were created. */
  | 'CREATED_AT';

/** Types that can be assigned to reactions. */
export type Github_Reactor = Github_Bot | Github_Mannequin | Github_Organization | Github_User;

/** The connection type for Reactor. */
export type Github_ReactorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReactorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Reactor>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents an author of a reaction. */
export type Github_ReactorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The author of the reaction. */
  node: Github_Reactor;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime'];
};

/** Represents a 'ready_for_review' event on a given pull request. */
export type Github_ReadyForReviewEvent = Github_Node & Github_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this ready for review event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this ready for review event. */
  url: Scalars['Github_URI'];
};

/** Represents a Git reference. */
export type Github_Ref = Github_Node & {
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: Github_PullRequestConnection;
  /** Branch protection rules for this ref */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */
  compare?: Maybe<Github_Comparison>;
  id: Scalars['ID'];
  /** The ref name. */
  name: Scalars['String'];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars['String'];
  /** Branch protection rules that are viewable by non-admins */
  refUpdateRule?: Maybe<Github_RefUpdateRule>;
  /** The repository the ref belongs to. */
  repository: Github_Repository;
  /** The object the ref points to. Returns null when object does not exist. */
  target?: Maybe<Github_GitObject>;
};


/** Represents a Git reference. */
export type Github_RefassociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};


/** Represents a Git reference. */
export type Github_RefcompareArgs = {
  headRef: Scalars['String'];
};

/** The connection type for Ref. */
export type Github_RefConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RefEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Ref>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RefEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Ref>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type Github_RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order refs by. */
  field: Github_RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export type Github_RefOrderField =
  /** Order refs by their alphanumeric name */
  | 'ALPHABETICAL'
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  | 'TAG_COMMIT_DATE';

/** A ref update */
export type Github_RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['Github_GitObjectID'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** Force a non fast-forward update. */
  force?: InputMaybe<Scalars['Boolean']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['Github_GitRefname'];
};

/** A ref update rules for a viewer. */
export type Github_RefUpdateRule = {
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean'];
  /** Can matching branches be created. */
  blocksCreations: Scalars['Boolean'];
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean'];
  /** Are commits required to be signed. */
  requiresSignatures: Scalars['Boolean'];
  /** Is the viewer allowed to dismiss reviews. */
  viewerAllowedToDismissReviews: Scalars['Boolean'];
  /** Can the viewer push to the branch */
  viewerCanPush: Scalars['Boolean'];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type Github_ReferencedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: Github_Repository;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars['Boolean'];
  /** Object referenced by event. */
  subject: Github_ReferencedSubject;
};

/** Any referencable object */
export type Github_ReferencedSubject = Github_Issue | Github_PullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type Github_RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars['ID'];
};

/** Autogenerated return type of RegenerateVerifiableDomainToken */
export type Github_RegenerateVerifiableDomainTokenPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verification token that was generated. */
  verificationToken?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RejectDeployments */
export type Github_RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Optional comment for rejecting deployments */
  comment?: InputMaybe<Scalars['String']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID'];
};

/** Autogenerated return type of RejectDeployments */
export type Github_RejectDeploymentsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Github_Deployment>>;
};

/** A release contains the content for a release. */
export type Github_Release = Github_Node & Github_Reactable & Github_UniformResourceLocatable & {
  /** The author of the release */
  author?: Maybe<Github_User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the release. */
  description?: Maybe<Scalars['String']>;
  /** The description of this release rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['Github_HTML']>;
  id: Scalars['ID'];
  /** Whether or not the release is a draft */
  isDraft: Scalars['Boolean'];
  /** Whether or not the release is the latest releast */
  isLatest: Scalars['Boolean'];
  /** Whether or not the release is a prerelease */
  isPrerelease: Scalars['Boolean'];
  /** A list of users mentioned in the release description */
  mentions?: Maybe<Github_UserConnection>;
  /** The title of the release. */
  name?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the release was created. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** List of releases assets which are dependent on this release. */
  releaseAssets: Github_ReleaseAssetConnection;
  /** The repository that the release belongs to. */
  repository: Github_Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['Github_URI'];
  /** A description of the release, rendered to HTML without any links in it. */
  shortDescriptionHTML?: Maybe<Scalars['Github_HTML']>;
  /** The Git tag the release points to */
  tag?: Maybe<Github_Ref>;
  /** The tag commit for this release. */
  tagCommit?: Maybe<Github_Commit>;
  /** The name of the release's Git tag */
  tagName: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue */
  url: Scalars['Github_URI'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
};


/** A release contains the content for a release. */
export type Github_ReleasementionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A release contains the content for a release. */
export type Github_ReleasereactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A release contains the content for a release. */
export type Github_ReleasereleaseAssetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};


/** A release contains the content for a release. */
export type Github_ReleaseshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** A release asset contains the content for a release asset. */
export type Github_ReleaseAsset = Github_Node & {
  /** The asset's content-type */
  contentType: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The number of times this asset was downloaded */
  downloadCount: Scalars['Int'];
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** Identifies the title of the release asset. */
  name: Scalars['String'];
  /** Release that the asset is associated with */
  release?: Maybe<Github_Release>;
  /** The size (in bytes) of the asset */
  size: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user that performed the upload */
  uploadedBy: Github_User;
  /** Identifies the URL of the release asset. */
  url: Scalars['Github_URI'];
};

/** The connection type for ReleaseAsset. */
export type Github_ReleaseAssetConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReleaseAssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ReleaseAsset>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReleaseAssetEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ReleaseAsset>;
};

/** The connection type for Release. */
export type Github_ReleaseConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Release>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReleaseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Release>;
};

/** Ways in which lists of releases can be ordered upon return. */
export type Github_ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order releases by. */
  field: Github_ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export type Github_ReleaseOrderField =
  /** Order releases by creation time */
  | 'CREATED_AT'
  /** Order releases alphabetically by name */
  | 'NAME';

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type Github_RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
export type Github_RemoveAssigneesFromAssignablePayload = {
  /** The item that was unassigned. */
  assignable?: Maybe<Github_Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type Github_RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String'];
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
export type Github_RemoveEnterpriseAdminPayload = {
  /** The user who was removed as an administrator. */
  admin?: Maybe<Github_User>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars['String']>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type Github_RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider */
export type Github_RemoveEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider that was removed from the enterprise. */
  identityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseMember */
export type Github_RemoveEnterpriseMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise from which the user should be removed. */
  enterpriseId: Scalars['ID'];
  /** The ID of the user to remove from the enterprise. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseMember */
export type Github_RemoveEnterpriseMemberPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
  /** The user that was removed from the enterprise. */
  user?: Maybe<Github_User>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type Github_RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
export type Github_RemoveEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<Github_Organization>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type Github_RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars['String'];
};

/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */
export type Github_RemoveEnterpriseSupportEntitlementPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of removing the support entitlement. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type Github_RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
export type Github_RemoveLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<Github_Labelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type Github_RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type Github_RemoveOutsideCollaboratorPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveReaction */
export type Github_RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the emoji reaction to remove. */
  content: Github_ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of RemoveReaction */
export type Github_RemoveReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reaction object. */
  reaction?: Maybe<Github_Reaction>;
  /** The reaction groups for the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** The reactable subject. */
  subject?: Maybe<Github_Reactable>;
};

/** Autogenerated input type of RemoveStar */
export type Github_RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID'];
};

/** Autogenerated return type of RemoveStar */
export type Github_RemoveStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The starrable. */
  starrable?: Maybe<Github_Starrable>;
};

/** Autogenerated input type of RemoveUpvote */
export type Github_RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of RemoveUpvote */
export type Github_RemoveUpvotePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The votable subject. */
  subject?: Maybe<Github_Votable>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type Github_RemovedFromProjectEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Represents a 'renamed' event on a given issue or pull request */
export type Github_RenamedTitleEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars['String'];
  id: Scalars['ID'];
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars['String'];
  /** Subject that was renamed. */
  subject: Github_RenamedTitleSubject;
};

/** An object which has a renamable title */
export type Github_RenamedTitleSubject = Github_Issue | Github_PullRequest;

/** Autogenerated input type of ReopenIssue */
export type Github_ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of ReopenIssue */
export type Github_ReopenIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was opened. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of ReopenPullRequest */
export type Github_ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ReopenPullRequest */
export type Github_ReopenPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was reopened. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
export type Github_ReopenedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Object that was reopened. */
  closable: Github_Closable;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The reason the issue state was changed to open. */
  stateReason?: Maybe<Github_IssueStateReason>;
};

/** Audit log entry for a repo.access event. */
export type Github_RepoAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoAccessAuditEntryVisibility>;
};

/** The privacy of a repository */
export type Github_RepoAccessAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.add_member event. */
export type Github_RepoAddMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoAddMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export type Github_RepoAddMemberAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.add_topic event. */
export type Github_RepoAddTopicAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TopicAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.archived event. */
export type Github_RepoArchivedAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoArchivedAuditEntryVisibility>;
};

/** The privacy of a repository */
export type Github_RepoArchivedAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.change_merge_setting event. */
export type Github_RepoChangeMergeSettingAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the change was to enable (true) or disable (false) the merge type */
  isEnabled?: Maybe<Scalars['Boolean']>;
  /** The merge method affected by the change */
  mergeType?: Maybe<Github_RepoChangeMergeSettingAuditEntryMergeType>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The merge options available for pull requests to this repository. */
export type Github_RepoChangeMergeSettingAuditEntryMergeType =
  /** The pull request is added to the base branch in a merge commit. */
  | 'MERGE'
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  | 'REBASE'
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  | 'SQUASH';

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type Github_RepoConfigDisableAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type Github_RepoConfigDisableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type Github_RepoConfigDisableContributorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type Github_RepoConfigDisableSockpuppetDisallowedAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type Github_RepoConfigEnableAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type Github_RepoConfigEnableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type Github_RepoConfigEnableContributorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type Github_RepoConfigEnableSockpuppetDisallowedAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type Github_RepoConfigLockAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type Github_RepoConfigUnlockAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.create event. */
export type Github_RepoCreateAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The name of the parent repository for this forked repository. */
  forkParentName?: Maybe<Scalars['String']>;
  /** The name of the root repository for this network. */
  forkSourceName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoCreateAuditEntryVisibility>;
};

/** The privacy of a repository */
export type Github_RepoCreateAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.destroy event. */
export type Github_RepoDestroyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoDestroyAuditEntryVisibility>;
};

/** The privacy of a repository */
export type Github_RepoDestroyAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.remove_member event. */
export type Github_RepoRemoveMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoRemoveMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export type Github_RepoRemoveMemberAuditEntryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repo.remove_topic event. */
export type Github_RepoRemoveTopicAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TopicAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The reasons a piece of content can be reported or minimized. */
export type Github_ReportedContentClassifiers =
  /** An abusive or harassing piece of content */
  | 'ABUSE'
  /** A duplicated piece of content */
  | 'DUPLICATE'
  /** An irrelevant piece of content */
  | 'OFF_TOPIC'
  /** An outdated piece of content */
  | 'OUTDATED'
  /** The content has been resolved */
  | 'RESOLVED'
  /** A spammy piece of content */
  | 'SPAM';

/** A repository contains the content for a project. */
export type Github_Repository = Github_Node & Github_PackageOwner & Github_ProjectOwner & Github_ProjectV2Recent & Github_RepositoryInfo & Github_Starrable & Github_Subscribable & Github_UniformResourceLocatable & {
  /**
   * Whether or not a pull request head branch that is behind its base branch can
   * always be updated even if it is not required to be up to date before merging.
   */
  allowUpdateBranch: Scalars['Boolean'];
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: Github_UserConnection;
  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */
  autoMergeAllowed: Scalars['Boolean'];
  /** A list of branch protection rules for this repository. */
  branchProtectionRules: Github_BranchProtectionRuleConnection;
  /** Returns the code of conduct for this repository */
  codeOfConduct?: Maybe<Github_CodeOfConduct>;
  /** Information extracted from the repository's `CODEOWNERS` file. */
  codeowners?: Maybe<Github_RepositoryCodeowners>;
  /** A list of collaborators associated with the repository. */
  collaborators?: Maybe<Github_RepositoryCollaboratorConnection>;
  /** A list of commit comments associated with the repository. */
  commitComments: Github_CommitCommentConnection;
  /** Returns a list of contact links associated to the repository */
  contactLinks?: Maybe<Array<Github_RepositoryContactLink>>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Maybe<Github_Ref>;
  /** Whether or not branches are automatically deleted when merged in this repository. */
  deleteBranchOnMerge: Scalars['Boolean'];
  /** A list of dependency manifests contained in the repository */
  dependencyGraphManifests?: Maybe<Github_DependencyGraphManifestConnection>;
  /** A list of deploy keys that are on this repository. */
  deployKeys: Github_DeployKeyConnection;
  /** Deployments associated with the repository */
  deployments: Github_DeploymentConnection;
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  /** Returns a single discussion from the current repository by number. */
  discussion?: Maybe<Github_Discussion>;
  /** A list of discussion categories that are available in the repository. */
  discussionCategories: Github_DiscussionCategoryConnection;
  /** A discussion category by slug. */
  discussionCategory?: Maybe<Github_DiscussionCategory>;
  /** A list of discussions that have been opened in the repository. */
  discussions: Github_DiscussionConnection;
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: Maybe<Scalars['Int']>;
  /** Returns a single active environment from the current repository by name. */
  environment?: Maybe<Github_Environment>;
  /** A list of environments that are in this repository. */
  environments: Github_EnvironmentConnection;
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** Whether this repository allows forks. */
  forkingAllowed: Scalars['Boolean'];
  /** A list of direct forked repositories. */
  forks: Github_RepositoryConnection;
  /** The funding links for this repository */
  fundingLinks: Array<Github_FundingLink>;
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Whether vulnerability alerts are enabled for the repository. */
  hasVulnerabilityAlertsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The interaction ability settings for this repository. */
  interactionAbility?: Maybe<Github_RepositoryInteractionAbility>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Returns true if blank issue creation is allowed */
  isBlankIssuesEnabled: Scalars['Boolean'];
  /** Returns whether or not this repository disabled. */
  isDisabled: Scalars['Boolean'];
  /** Returns whether or not this repository is empty. */
  isEmpty: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** Returns true if this repository has a security policy */
  isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']>;
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** Is this repository a user configuration repository? */
  isUserConfigurationRepository: Scalars['Boolean'];
  /** Returns a single issue from the current repository by number. */
  issue?: Maybe<Github_Issue>;
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: Maybe<Github_IssueOrPullRequest>;
  /** Returns a list of issue templates associated to the repository */
  issueTemplates?: Maybe<Array<Github_IssueTemplate>>;
  /** A list of issues that have been opened in the repository. */
  issues: Github_IssueConnection;
  /** Returns a single label by name */
  label?: Maybe<Github_Label>;
  /** A list of labels associated with the repository. */
  labels?: Maybe<Github_LabelConnection>;
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: Maybe<Github_LanguageConnection>;
  /** Get the latest release for the repository if one exists. */
  latestRelease?: Maybe<Github_Release>;
  /** The license associated with the repository */
  licenseInfo?: Maybe<Github_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<Github_RepositoryLockReason>;
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: Github_UserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: Scalars['Boolean'];
  /** How the default commit message will be generated when merging a pull request. */
  mergeCommitMessage: Github_MergeCommitMessage;
  /** How the default commit title will be generated when merging a pull request. */
  mergeCommitTitle: Github_MergeCommitTitle;
  /** Returns a single milestone from the current repository by number. */
  milestone?: Maybe<Github_Milestone>;
  /** A list of milestones associated with the repository. */
  milestones?: Maybe<Github_MilestoneConnection>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** A Git object in the repository */
  object?: Maybe<Github_GitObject>;
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['Github_URI'];
  /** The User owner of the repository. */
  owner: Github_RepositoryOwner;
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
  /** The repository parent, if this is a fork. */
  parent?: Maybe<Github_Repository>;
  /** A list of discussions that have been pinned in this repository. */
  pinnedDiscussions: Github_PinnedDiscussionConnection;
  /** A list of pinned issues for this repository. */
  pinnedIssues?: Maybe<Github_PinnedIssueConnection>;
  /** The primary language of the repository's code. */
  primaryLanguage?: Maybe<Github_Language>;
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** Finds and returns the Project according to the provided Project number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing the repository's projects */
  projectsUrl: Scalars['Github_URI'];
  /** List of projects linked to this repository. */
  projectsV2: Github_ProjectV2Connection;
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: Maybe<Github_PullRequest>;
  /** Returns a list of pull request templates associated to the repository */
  pullRequestTemplates?: Maybe<Array<Github_PullRequestTemplate>>;
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: Github_PullRequestConnection;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: Scalars['Boolean'];
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: Github_ProjectV2Connection;
  /** Fetch a given ref from the repository */
  ref?: Maybe<Github_Ref>;
  /** Fetch a list of refs from the repository */
  refs?: Maybe<Github_RefConnection>;
  /** Lookup a single release given various criteria. */
  release?: Maybe<Github_Release>;
  /** List of releases which are dependent on this repository. */
  releases: Github_ReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: Github_RepositoryTopicConnection;
  /** The HTTP path for this repository */
  resourcePath: Scalars['Github_URI'];
  /** The security policy URL. */
  securityPolicyUrl?: Maybe<Scalars['Github_URI']>;
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['Github_HTML'];
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: Scalars['Boolean'];
  /** How the default commit message will be generated when squash merging a pull request. */
  squashMergeCommitMessage: Github_SquashMergeCommitMessage;
  /** How the default commit title will be generated when squash merging a pull request. */
  squashMergeCommitTitle: Github_SquashMergeCommitTitle;
  /**
   * Whether a squash merge commit can use the pull request title as default.
   * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.
   */
  squashPrTitleUsedAsDefault: Scalars['Boolean'];
  /** The SSH URL to clone this repository */
  sshUrl: Scalars['Github_GitSSHRemote'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /**
   * Returns a list of all submodules in this repository parsed from the
   * .gitmodules file as of the default branch's HEAD commit.
   */
  submodules: Github_SubmoduleConnection;
  /** Temporary authentication token for cloning this repository. */
  tempCloneToken?: Maybe<Scalars['String']>;
  /** The repository from which this repository was generated, if any. */
  templateRepository?: Maybe<Github_Repository>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['Github_URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: Scalars['Boolean'];
  /** The last commit email for the viewer. */
  viewerDefaultCommitEmail?: Maybe<Scalars['String']>;
  /** The last used merge method by the viewer or the default for the repository. */
  viewerDefaultMergeMethod: Github_PullRequestMergeMethod;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: Maybe<Github_RepositoryPermission>;
  /** A list of emails this viewer can commit with. */
  viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']>>;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
  /** A list of vulnerability alerts that are on this repository. */
  vulnerabilityAlerts?: Maybe<Github_RepositoryVulnerabilityAlertConnection>;
  /** A list of users watching the repository. */
  watchers: Github_UserConnection;
  /** Whether contributors are required to sign off on web-based commits in this repository. */
  webCommitSignoffRequired: Scalars['Boolean'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryassignableUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorybranchProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorycodeownersArgs = {
  refName?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorycollaboratorsArgs = {
  affiliation?: InputMaybe<Github_CollaboratorAffiliation>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorycommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorydependencyGraphManifestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  dependenciesAfter?: InputMaybe<Scalars['String']>;
  dependenciesFirst?: InputMaybe<Scalars['Int']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  withDependencies?: InputMaybe<Scalars['Boolean']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorydeployKeysArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorydeploymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  environments?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DeploymentOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositorydiscussionArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositorydiscussionCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterByAssignable?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorydiscussionCategoryArgs = {
  slug: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositorydiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  categoryId?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryenvironmentArgs = {
  name: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryenvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryforksArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryissueArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryissueOrPullRequestArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryissuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositorylabelArgs = {
  name: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositorylabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorylanguagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LanguageOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositorymentionableUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorymilestoneArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositorymilestonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_MilestoneOrder>;
  query?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_MilestoneState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryobjectArgs = {
  expression?: InputMaybe<Scalars['String']>;
  oid?: InputMaybe<Scalars['Github_GitObjectID']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorypackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorypinnedDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorypinnedIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryprojectArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryprojectV2Args = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryprojectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorypullRequestArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositorypullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryrefArgs = {
  qualifiedName: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryrefsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  direction?: InputMaybe<Github_OrderDirection>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RefOrder>;
  query?: InputMaybe<Scalars['String']>;
  refPrefix: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryreleaseArgs = {
  tagName: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryreleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReleaseOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryrepositoryTopicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositorystargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositorysubmodulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryvulnerabilityAlertsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  dependencyScopes?: InputMaybe<Array<Github_RepositoryVulnerabilityAlertDependencyScope>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  states?: InputMaybe<Array<Github_RepositoryVulnerabilityAlertState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositorywatchersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The affiliation of a user to a repository */
export type Github_RepositoryAffiliation =
  /** Repositories that the user has been added to as a collaborator. */
  | 'COLLABORATOR'
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  | 'ORGANIZATION_MEMBER'
  /** Repositories that are owned by the authenticated user. */
  | 'OWNER';

/** Metadata for an audit entry with action repo.* */
export type Github_RepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
};

/** Information extracted from a repository's `CODEOWNERS` file. */
export type Github_RepositoryCodeowners = {
  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */
  errors: Array<Github_RepositoryCodeownersError>;
};

/** An error in a `CODEOWNERS` file. */
export type Github_RepositoryCodeownersError = {
  /** The column number where the error occurs. */
  column: Scalars['Int'];
  /** A short string describing the type of error. */
  kind: Scalars['String'];
  /** The line number where the error occurs. */
  line: Scalars['Int'];
  /** A complete description of the error, combining information from other fields. */
  message: Scalars['String'];
  /** The path to the file when the error occurs. */
  path: Scalars['String'];
  /** The content of the line where the error occurs. */
  source: Scalars['String'];
  /** A suggestion of how to fix the error. */
  suggestion?: Maybe<Scalars['String']>;
};

/** The connection type for User. */
export type Github_RepositoryCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user who is a collaborator of a repository. */
export type Github_RepositoryCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_User;
  /** The permission the user has on the repository. */
  permission: Github_RepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<Github_PermissionSource>>;
};

/** A list of repositories owned by the subject. */
export type Github_RepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** The total size in kilobytes of all repositories in the connection. */
  totalDiskUsage: Scalars['Int'];
};

/** A repository contact link. */
export type Github_RepositoryContactLink = {
  /** The contact link purpose. */
  about: Scalars['String'];
  /** The contact link name. */
  name: Scalars['String'];
  /** The contact link URL. */
  url: Scalars['Github_URI'];
};

/** The reason a repository is listed as 'contributed'. */
export type Github_RepositoryContributionType =
  /** Created a commit */
  | 'COMMIT'
  /** Created an issue */
  | 'ISSUE'
  /** Created a pull request */
  | 'PULL_REQUEST'
  /** Reviewed a pull request */
  | 'PULL_REQUEST_REVIEW'
  /** Created the repository */
  | 'REPOSITORY';

/** Represents an author of discussions in repositories. */
export type Github_RepositoryDiscussionAuthor = {
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
};


/** Represents an author of discussions in repositories. */
export type Github_RepositoryDiscussionAuthorrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Represents an author of discussion comments in repositories. */
export type Github_RepositoryDiscussionCommentAuthor = {
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
};


/** Represents an author of discussion comments in repositories. */
export type Github_RepositoryDiscussionCommentAuthorrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** An edge in a connection. */
export type Github_RepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Repository>;
};

/** A subset of repository info. */
export type Github_RepositoryInfo = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** Indicates if the repository has the Discussions feature enabled. */
  hasDiscussionsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['Github_URI']>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** The license associated with the repository */
  licenseInfo?: Maybe<Github_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<Github_RepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['Github_URI'];
  /** The User owner of the repository. */
  owner: Github_RepositoryOwner;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP path for this repository */
  resourcePath: Scalars['Github_URI'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['Github_HTML'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['Github_URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};


/** A subset of repository info. */
export type Github_RepositoryInfoshortDescriptionHTMLArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** Repository interaction limit that applies to this object. */
export type Github_RepositoryInteractionAbility = {
  /** The time the currently active limit expires. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  /** The current limit that is enabled on this object. */
  limit: Github_RepositoryInteractionLimit;
  /** The origin of the currently active interaction limit. */
  origin: Github_RepositoryInteractionLimitOrigin;
};

/** A repository interaction limit. */
export type Github_RepositoryInteractionLimit =
  /** Users that are not collaborators will not be able to interact with the repository. */
  | 'COLLABORATORS_ONLY'
  /** Users that have not previously committed to a repositorys default branch will be unable to interact with the repository. */
  | 'CONTRIBUTORS_ONLY'
  /** Users that have recently created their account will be unable to interact with the repository. */
  | 'EXISTING_USERS'
  /** No interaction limits are enabled. */
  | 'NO_LIMIT';

/** The length for a repository interaction limit to be enabled for. */
export type Github_RepositoryInteractionLimitExpiry =
  /** The interaction limit will expire after 1 day. */
  | 'ONE_DAY'
  /** The interaction limit will expire after 1 month. */
  | 'ONE_MONTH'
  /** The interaction limit will expire after 1 week. */
  | 'ONE_WEEK'
  /** The interaction limit will expire after 6 months. */
  | 'SIX_MONTHS'
  /** The interaction limit will expire after 3 days. */
  | 'THREE_DAYS';

/** Indicates where an interaction limit is configured. */
export type Github_RepositoryInteractionLimitOrigin =
  /** A limit that is configured at the organization level. */
  | 'ORGANIZATION'
  /** A limit that is configured at the repository level. */
  | 'REPOSITORY'
  /** A limit that is configured at the user-wide level. */
  | 'USER';

/** An invitation for a user to be added to a repository. */
export type Github_RepositoryInvitation = Github_Node & {
  /** The email address that received the invitation. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The user who received the invitation. */
  invitee?: Maybe<Github_User>;
  /** The user who created the invitation. */
  inviter: Github_User;
  /** The permalink for this repository invitation. */
  permalink: Scalars['Github_URI'];
  /** The permission granted on this repository by this invitation. */
  permission: Github_RepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: Maybe<Github_RepositoryInfo>;
};

/** A list of repository invitations. */
export type Github_RepositoryInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RepositoryInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
export type Github_RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repository invitations by. */
  field: Github_RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export type Github_RepositoryInvitationOrderField =
  /** Order repository invitations by creation time */
  | 'CREATED_AT';

/** The possible reasons a given repository could be in a locked state. */
export type Github_RepositoryLockReason =
  /** The repository is locked due to a billing related reason. */
  | 'BILLING'
  /** The repository is locked due to a migration. */
  | 'MIGRATING'
  /** The repository is locked due to a move. */
  | 'MOVING'
  /** The repository is locked due to a rename. */
  | 'RENAME'
  /** The repository is locked due to a trade controls related reason. */
  | 'TRADE_RESTRICTION';

/** A GitHub Enterprise Importer (GEI) repository migration. */
export type Github_RepositoryMigration = Github_Migration & Github_Node & {
  /** The migration flag to continue on error. */
  continueOnError: Scalars['Boolean'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['String']>;
  /** The reason the migration failed. */
  failureReason?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The URL for the migration log (expires 1 day after migration completes). */
  migrationLogUrl?: Maybe<Scalars['Github_URI']>;
  /** The migration source. */
  migrationSource: Github_MigrationSource;
  /** The target repository name. */
  repositoryName: Scalars['String'];
  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */
  sourceUrl: Scalars['Github_URI'];
  /** The migration state. */
  state: Github_MigrationState;
};

/** The connection type for RepositoryMigration. */
export type Github_RepositoryMigrationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryMigrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryMigration>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a repository migration. */
export type Github_RepositoryMigrationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryMigration>;
};

/** Ordering options for repository migrations. */
export type Github_RepositoryMigrationOrder = {
  /** The ordering direction. */
  direction: Github_RepositoryMigrationOrderDirection;
  /** The field to order repository migrations by. */
  field: Github_RepositoryMigrationOrderField;
};

/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */
export type Github_RepositoryMigrationOrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC';

/** Properties by which repository migrations can be ordered. */
export type Github_RepositoryMigrationOrderField =
  /** Order mannequins why when they were created. */
  | 'CREATED_AT';

/** Represents a object that belongs to a repository. */
export type Github_RepositoryNode = {
  /** The repository associated with this node. */
  repository: Github_Repository;
};

/** Ordering options for repository connections */
export type Github_RepositoryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repositories by. */
  field: Github_RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export type Github_RepositoryOrderField =
  /** Order repositories by creation time */
  | 'CREATED_AT'
  /** Order repositories by name */
  | 'NAME'
  /** Order repositories by push time */
  | 'PUSHED_AT'
  /** Order repositories by number of stargazers */
  | 'STARGAZERS'
  /** Order repositories by update time */
  | 'UPDATED_AT';

/** Represents an owner of a Repository. */
export type Github_RepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The username used to login. */
  login: Scalars['String'];
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the owner. */
  url: Scalars['Github_URI'];
};


/** Represents an owner of a Repository. */
export type Github_RepositoryOwneravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents an owner of a Repository. */
export type Github_RepositoryOwnerrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** Represents an owner of a Repository. */
export type Github_RepositoryOwnerrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};

/** The access level to a repository */
export type Github_RepositoryPermission =
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  | 'ADMIN'
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  | 'MAINTAIN'
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  | 'READ'
  /** Can read and clone this repository. Can also manage issues and pull requests */
  | 'TRIAGE'
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  | 'WRITE';

/** The privacy of a repository */
export type Github_RepositoryPrivacy =
  /** Private */
  | 'PRIVATE'
  /** Public */
  | 'PUBLIC';

/** A repository-topic connects a repository to a topic. */
export type Github_RepositoryTopic = Github_Node & Github_UniformResourceLocatable & {
  id: Scalars['ID'];
  /** The HTTP path for this repository-topic. */
  resourcePath: Scalars['Github_URI'];
  /** The topic. */
  topic: Github_Topic;
  /** The HTTP URL for this repository-topic. */
  url: Scalars['Github_URI'];
};

/** The connection type for RepositoryTopic. */
export type Github_RepositoryTopicConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RepositoryTopicEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryTopic>;
};

/** The repository's visibility level. */
export type Github_RepositoryVisibility =
  /** The repository is visible only to users in the same business. */
  | 'INTERNAL'
  /** The repository is visible only to those with explicit access. */
  | 'PRIVATE'
  /** The repository is visible to everyone. */
  | 'PUBLIC';

/** Audit log entry for a repository_visibility_change.disable event. */
export type Github_RepositoryVisibilityChangeDisableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repository_visibility_change.enable event. */
export type Github_RepositoryVisibilityChangeEnableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */
export type Github_RepositoryVulnerabilityAlert = Github_Node & Github_RepositoryNode & {
  /** When was the alert created? */
  createdAt: Scalars['DateTime'];
  /** The associated Dependabot update */
  dependabotUpdate?: Maybe<Github_DependabotUpdate>;
  /** The scope of an alert's dependency */
  dependencyScope?: Maybe<Github_RepositoryVulnerabilityAlertDependencyScope>;
  /** Comment explaining the reason the alert was dismissed */
  dismissComment?: Maybe<Scalars['String']>;
  /** The reason the alert was dismissed */
  dismissReason?: Maybe<Scalars['String']>;
  /** When was the alert dismissed? */
  dismissedAt?: Maybe<Scalars['DateTime']>;
  /** The user who dismissed the alert */
  dismisser?: Maybe<Github_User>;
  /**
   * The reason the alert was marked as fixed.
   * @deprecated The `fixReason` field is being removed. You can still use `fixedAt` and `dismissReason`. Removal on 2023-04-01 UTC.
   */
  fixReason?: Maybe<Scalars['String']>;
  /** When was the alert fixed? */
  fixedAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** Identifies the alert number. */
  number: Scalars['Int'];
  /** The associated repository */
  repository: Github_Repository;
  /** The associated security advisory */
  securityAdvisory?: Maybe<Github_SecurityAdvisory>;
  /** The associated security vulnerability */
  securityVulnerability?: Maybe<Github_SecurityVulnerability>;
  /** Identifies the state of the alert. */
  state: Github_RepositoryVulnerabilityAlertState;
  /** The vulnerable manifest filename */
  vulnerableManifestFilename: Scalars['String'];
  /** The vulnerable manifest path */
  vulnerableManifestPath: Scalars['String'];
  /** The vulnerable requirements */
  vulnerableRequirements?: Maybe<Scalars['String']>;
};

/** The connection type for RepositoryVulnerabilityAlert. */
export type Github_RepositoryVulnerabilityAlertConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The possible scopes of an alert's dependency. */
export type Github_RepositoryVulnerabilityAlertDependencyScope =
  /** A dependency that is only used in development */
  | 'DEVELOPMENT'
  /** A dependency that is leveraged during application runtime */
  | 'RUNTIME';

/** An edge in a connection. */
export type Github_RepositoryVulnerabilityAlertEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryVulnerabilityAlert>;
};

/** The possible states of an alert */
export type Github_RepositoryVulnerabilityAlertState =
  /** An alert that has been manually closed by a user. */
  | 'DISMISSED'
  /** An alert that has been resolved by a code change. */
  | 'FIXED'
  /** An alert that is still open. */
  | 'OPEN';

/** Autogenerated input type of RequestReviews */
export type Github_RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The Node IDs of the team to request. */
  teamIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Add users to the set rather than replace. */
  union?: InputMaybe<Scalars['Boolean']>;
  /** The Node IDs of the user to request. */
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of RequestReviews */
export type Github_RequestReviewsPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<Github_PullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<Github_UserEdge>;
};

/** The possible states that can be requested when creating a check run. */
export type Github_RequestableCheckStatusState =
  /** The check suite or run has been completed. */
  | 'COMPLETED'
  /** The check suite or run is in progress. */
  | 'IN_PROGRESS'
  /** The check suite or run is in pending state. */
  | 'PENDING'
  /** The check suite or run has been queued. */
  | 'QUEUED'
  /** The check suite or run is in waiting state. */
  | 'WAITING';

/** Types that can be requested reviewers. */
export type Github_RequestedReviewer = Github_Mannequin | Github_Team | Github_User;

/** The connection type for RequestedReviewer. */
export type Github_RequestedReviewerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RequestedReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RequestedReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RequestedReviewerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RequestedReviewer>;
};

/** Represents a type that can be required by a pull request for merging. */
export type Github_RequirableByPullRequest = {
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
};


/** Represents a type that can be required by a pull request for merging. */
export type Github_RequirableByPullRequestisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};

/** Represents a required status check for a protected branch, but not any specific run of that check. */
export type Github_RequiredStatusCheckDescription = {
  /** The App that must provide this status in order for it to be accepted. */
  app?: Maybe<Github_App>;
  /** The name of this status. */
  context: Scalars['String'];
};

/** Specifies the attributes for a new or updated required status check. */
export type Github_RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  appId?: InputMaybe<Scalars['ID']>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  context: Scalars['String'];
};

/** Autogenerated input type of RerequestCheckSuite */
export type Github_RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of RerequestCheckSuite */
export type Github_RerequestCheckSuitePayload = {
  /** The requested check suite. */
  checkSuite?: Maybe<Github_CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ResolveReviewThread */
export type Github_ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID'];
};

/** Autogenerated return type of ResolveReviewThread */
export type Github_ResolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The thread to resolve. */
  thread?: Maybe<Github_PullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
export type Github_RestrictedContribution = Github_Contribution & {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** Autogenerated input type of RetireSponsorsTier */
export type Github_RetireSponsorsTierInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the published tier to retire. */
  tierId: Scalars['ID'];
};

/** Autogenerated return type of RetireSponsorsTier */
export type Github_RetireSponsorsTierPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The tier that was retired. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
};

/** Autogenerated input type of RevertPullRequest */
export type Github_RevertPullRequestInput = {
  /** The description of the revert pull request. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates whether the revert pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the pull request to revert. */
  pullRequestId: Scalars['ID'];
  /** The title of the revert pull request. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RevertPullRequest */
export type Github_RevertPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was reverted. */
  pullRequest?: Maybe<Github_PullRequest>;
  /** The new pull request that reverts the input pull request. */
  revertPullRequest?: Maybe<Github_PullRequest>;
};

/** A user, team, or app who has the ability to dismiss a review on a protected branch. */
export type Github_ReviewDismissalAllowance = Github_Node & {
  /** The actor that can dismiss. */
  actor?: Maybe<Github_ReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user, team, or app. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** Types that can be an actor. */
export type Github_ReviewDismissalAllowanceActor = Github_App | Github_Team | Github_User;

/** The connection type for ReviewDismissalAllowance. */
export type Github_ReviewDismissalAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReviewDismissalAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type Github_ReviewDismissedEvent = Github_Node & Github_UniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  dismissalMessage?: Maybe<Scalars['String']>;
  /** Identifies the optional message associated with the event, rendered to HTML. */
  dismissalMessageHTML?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: Github_PullRequestReviewState;
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: Maybe<Github_PullRequestCommit>;
  /** The HTTP path for this review dismissed event. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: Maybe<Github_PullRequestReview>;
  /** The HTTP URL for this review dismissed event. */
  url: Scalars['Github_URI'];
};

/** A request for a user to review a pull request. */
export type Github_ReviewRequest = Github_Node & {
  /** Whether this request was created for a code owner */
  asCodeOwner: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Identifies the pull request associated with this review request. */
  pullRequest: Github_PullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<Github_RequestedReviewer>;
};

/** The connection type for ReviewRequest. */
export type Github_ReviewRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReviewRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ReviewRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReviewRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type Github_ReviewRequestRemovedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<Github_RequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
export type Github_ReviewRequestedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<Github_RequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
export type Github_ReviewStatusHovercardContext = Github_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** The current status of the pull request with respect to code review. */
  reviewDecision?: Maybe<Github_PullRequestReviewDecision>;
};

/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */
export type Github_RevokeEnterpriseOrganizationsMigratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */
  enterpriseId: Scalars['ID'];
  /** The login of the user to revoke the migrator role */
  login: Scalars['String'];
};

/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
export type Github_RevokeEnterpriseOrganizationsMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organizations that had the migrator role revoked for the given user. */
  organizations?: Maybe<Github_OrganizationConnection>;
};


/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */
export type Github_RevokeEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of RevokeMigratorRole */
export type Github_RevokeMigratorRoleInput = {
  /** The user login or Team slug to revoke the migrator role from. */
  actor: Scalars['String'];
  /** Specifies the type of the actor, can be either USER or TEAM. */
  actorType: Github_ActorType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization that the user/team belongs to. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of RevokeMigratorRole */
export type Github_RevokeMigratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Did the operation succeed? */
  success?: Maybe<Scalars['Boolean']>;
};

/** Possible roles a user may have in relation to an organization. */
export type Github_RoleInOrganization =
  /** A user who is a direct member of the organization. */
  | 'DIRECT_MEMBER'
  /** A user with full administrative access to the organization. */
  | 'OWNER'
  /** A user who is unaffiliated with the organization. */
  | 'UNAFFILIATED';

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export type Github_SamlDigestAlgorithm =
  /** SHA1 */
  | 'SHA1'
  /** SHA256 */
  | 'SHA256'
  /** SHA384 */
  | 'SHA384'
  /** SHA512 */
  | 'SHA512';

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export type Github_SamlSignatureAlgorithm =
  /** RSA-SHA1 */
  | 'RSA_SHA1'
  /** RSA-SHA256 */
  | 'RSA_SHA256'
  /** RSA-SHA384 */
  | 'RSA_SHA384'
  /** RSA-SHA512 */
  | 'RSA_SHA512';

/** A Saved Reply is text a user can use to reply quickly. */
export type Github_SavedReply = Github_Node & {
  /** The body of the saved reply. */
  body: Scalars['String'];
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The title of the saved reply. */
  title: Scalars['String'];
  /** The user that saved this reply. */
  user?: Maybe<Github_Actor>;
};

/** The connection type for SavedReply. */
export type Github_SavedReplyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SavedReplyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SavedReply>;
};

/** Ordering options for saved reply connections. */
export type Github_SavedReplyOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order saved replies by. */
  field: Github_SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export type Github_SavedReplyOrderField =
  /** Order saved reply by when they were updated. */
  | 'UPDATED_AT';

/** The results of a search. */
export type Github_SearchResultItem = Github_App | Github_Discussion | Github_Issue | Github_MarketplaceListing | Github_Organization | Github_PullRequest | Github_Repository | Github_User;

/**
 * A list of results that matched against a search query. Regardless of the number
 * of matches, a maximum of 1,000 results will be available across all types,
 * potentially split across many pages.
 */
export type Github_SearchResultItemConnection = {
  /**
   * The total number of pieces of code that matched the search query. Regardless
   * of the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  codeCount: Scalars['Int'];
  /**
   * The total number of discussions that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  discussionCount: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SearchResultItemEdge>>>;
  /**
   * The total number of issues that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  issueCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SearchResultItem>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /**
   * The total number of repositories that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  repositoryCount: Scalars['Int'];
  /**
   * The total number of users that matched the search query. Regardless of the
   * total number of matches, a maximum of 1,000 results will be available across all types.
   */
  userCount: Scalars['Int'];
  /**
   * The total number of wiki pages that matched the search query. Regardless of
   * the total number of matches, a maximum of 1,000 results will be available
   * across all types.
   */
  wikiCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SearchResultItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SearchResultItem>;
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<Github_TextMatch>>>;
};

/** Represents the individual results of a search. */
export type Github_SearchType =
  /** Returns matching discussions in repositories. */
  | 'DISCUSSION'
  /** Returns results matching issues in repositories. */
  | 'ISSUE'
  /** Returns results matching repositories. */
  | 'REPOSITORY'
  /** Returns results matching users and organizations on GitHub. */
  | 'USER';

/** A GitHub Security Advisory */
export type Github_SecurityAdvisory = Github_Node & {
  /** The classification of the advisory */
  classification: Github_SecurityAdvisoryClassification;
  /** The CVSS associated with this advisory */
  cvss: Github_CVSS;
  /** CWEs associated with this Advisory */
  cwes: Github_CWEConnection;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** This is a long plaintext description of the advisory */
  description: Scalars['String'];
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars['String'];
  id: Scalars['ID'];
  /** A list of identifiers for this advisory */
  identifiers: Array<Github_SecurityAdvisoryIdentifier>;
  /** The permalink for the advisory's dependabot alerts page */
  notificationsPermalink?: Maybe<Scalars['Github_URI']>;
  /** The organization that originated the advisory */
  origin: Scalars['String'];
  /** The permalink for the advisory */
  permalink?: Maybe<Scalars['Github_URI']>;
  /** When the advisory was published */
  publishedAt: Scalars['DateTime'];
  /** A list of references for this advisory */
  references: Array<Github_SecurityAdvisoryReference>;
  /** The severity of the advisory */
  severity: Github_SecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  summary: Scalars['String'];
  /** When the advisory was last updated */
  updatedAt: Scalars['DateTime'];
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: Github_SecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars['DateTime']>;
};


/** A GitHub Security Advisory */
export type Github_SecurityAdvisorycwesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A GitHub Security Advisory */
export type Github_SecurityAdvisoryvulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  classifications?: InputMaybe<Array<Github_SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<Github_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']>;
  severities?: InputMaybe<Array<Github_SecurityAdvisorySeverity>>;
};

/** Classification of the advisory. */
export type Github_SecurityAdvisoryClassification =
  /** Classification of general advisories. */
  | 'GENERAL'
  /** Classification of malware advisories. */
  | 'MALWARE';

/** The connection type for SecurityAdvisory. */
export type Github_SecurityAdvisoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SecurityAdvisory>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The possible ecosystems of a security vulnerability's package. */
export type Github_SecurityAdvisoryEcosystem =
  /** GitHub Actions */
  | 'ACTIONS'
  /** PHP packages hosted at packagist.org */
  | 'COMPOSER'
  /** Erlang/Elixir packages hosted at hex.pm */
  | 'ERLANG'
  /** Go modules */
  | 'GO'
  /** Java artifacts hosted at the Maven central repository */
  | 'MAVEN'
  /** JavaScript packages hosted at npmjs.com */
  | 'NPM'
  /** .NET packages hosted at the NuGet Gallery */
  | 'NUGET'
  /** Python packages hosted at PyPI.org */
  | 'PIP'
  /** Dart packages hosted at pub.dev */
  | 'PUB'
  /** Ruby gems hosted at RubyGems.org */
  | 'RUBYGEMS'
  /** Rust crates */
  | 'RUST';

/** An edge in a connection. */
export type Github_SecurityAdvisoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
export type Github_SecurityAdvisoryIdentifier = {
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars['String'];
  /** The identifier */
  value: Scalars['String'];
};

/** An advisory identifier to filter results on. */
export type Github_SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: Github_SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String'];
};

/** Identifier formats available for advisories. */
export type Github_SecurityAdvisoryIdentifierType =
  /** Common Vulnerabilities and Exposures Identifier. */
  | 'CVE'
  /** GitHub Security Advisory ID. */
  | 'GHSA';

/** Ordering options for security advisory connections */
export type Github_SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order security advisories by. */
  field: Github_SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export type Github_SecurityAdvisoryOrderField =
  /** Order advisories by publication time */
  | 'PUBLISHED_AT'
  /** Order advisories by update time */
  | 'UPDATED_AT';

/** An individual package */
export type Github_SecurityAdvisoryPackage = {
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: Github_SecurityAdvisoryEcosystem;
  /** The package name */
  name: Scalars['String'];
};

/** An individual package version */
export type Github_SecurityAdvisoryPackageVersion = {
  /** The package name or version */
  identifier: Scalars['String'];
};

/** A GitHub Security Advisory Reference */
export type Github_SecurityAdvisoryReference = {
  /** A publicly accessible reference */
  url: Scalars['Github_URI'];
};

/** Severity of the vulnerability. */
export type Github_SecurityAdvisorySeverity =
  /** Critical. */
  | 'CRITICAL'
  /** High. */
  | 'HIGH'
  /** Low. */
  | 'LOW'
  /** Moderate. */
  | 'MODERATE';

/** An individual vulnerability within an Advisory */
export type Github_SecurityVulnerability = {
  /** The Advisory associated with this Vulnerability */
  advisory: Github_SecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<Github_SecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  package: Github_SecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  severity: Github_SecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  updatedAt: Scalars['DateTime'];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  vulnerableVersionRange: Scalars['String'];
};

/** The connection type for SecurityVulnerability. */
export type Github_SecurityVulnerabilityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SecurityVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SecurityVulnerabilityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
export type Github_SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: Github_SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export type Github_SecurityVulnerabilityOrderField =
  /** Order vulnerability by update time */
  | 'UPDATED_AT';

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type Github_SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: Github_SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: InputMaybe<Scalars['String']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: Github_SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['Github_URI'];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider */
export type Github_SetEnterpriseIdentityProviderPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type Github_SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<Github_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: Github_RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of SetOrganizationInteractionLimit */
export type Github_SetOrganizationInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization that the interaction limit was set for. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type Github_SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<Github_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: Github_RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of SetRepositoryInteractionLimit */
export type Github_SetRepositoryInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that the interaction limit was set for. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of SetUserInteractionLimit */
export type Github_SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<Github_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: Github_RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of SetUserInteractionLimit */
export type Github_SetUserInteractionLimitPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that the interaction limit was set for. */
  user?: Maybe<Github_User>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type Github_SmimeSignature = Github_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Entities that can sponsor others via GitHub Sponsors */
export type Github_Sponsor = Github_Organization | Github_User;

/** The connection type for Sponsor. */
export type Github_SponsorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Sponsor>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */
export type Github_SponsorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Sponsor>;
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type Github_SponsorOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsor entities by. */
  field: Github_SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export type Github_SponsorOrderField =
  /** Order sponsorable entities by login (username). */
  | 'LOGIN'
  /** Order sponsors by their relevance to the viewer. */
  | 'RELEVANCE';

/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_Sponsorable = {
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']>;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorableisSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<Github_SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']>;
  until?: InputMaybe<Scalars['DateTime']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorablesponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']>>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** Entities that can sponsor or be sponsored through GitHub Sponsors. */
export type Github_SponsorabletotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']>>;
  until?: InputMaybe<Scalars['DateTime']>;
};

/** Entities that can be sponsored via GitHub Sponsors */
export type Github_SponsorableItem = Github_Organization | Github_User;

/** The connection type for SponsorableItem. */
export type Github_SponsorableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorableItem>;
};

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type Github_SponsorableOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsorable entities by. */
  field: Github_SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export type Github_SponsorableOrderField =
  /** Order sponsorable entities by login (username). */
  | 'LOGIN';

/** An event related to sponsorship activity. */
export type Github_SponsorsActivity = Github_Node & {
  /** What action this activity indicates took place. */
  action: Github_SponsorsActivityAction;
  id: Scalars['ID'];
  /** The tier that the sponsorship used to use, for tier change events. */
  previousSponsorsTier?: Maybe<Github_SponsorsTier>;
  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */
  sponsor?: Maybe<Github_Sponsor>;
  /** The user or organization that is being sponsored, the maintainer. */
  sponsorable: Github_Sponsorable;
  /** The associated sponsorship tier. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
  /** The timestamp of this event. */
  timestamp?: Maybe<Scalars['DateTime']>;
};

/** The possible actions that GitHub Sponsors activities can represent. */
export type Github_SponsorsActivityAction =
  /** The activity was cancelling a sponsorship. */
  | 'CANCELLED_SPONSORSHIP'
  /** The activity was starting a sponsorship. */
  | 'NEW_SPONSORSHIP'
  /** The activity was scheduling a downgrade or cancellation. */
  | 'PENDING_CHANGE'
  /** The activity was funds being refunded to the sponsor or GitHub. */
  | 'REFUND'
  /** The activity was disabling matching for a previously matched sponsorship. */
  | 'SPONSOR_MATCH_DISABLED'
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  | 'TIER_CHANGE';

/** The connection type for SponsorsActivity. */
export type Github_SponsorsActivityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorsActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorsActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorsActivityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorsActivity>;
};

/** Ordering options for GitHub Sponsors activity connections. */
export type Github_SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order activity by. */
  field: Github_SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export type Github_SponsorsActivityOrderField =
  /** Order activities by when they happened. */
  | 'TIMESTAMP';

/** The possible time periods for which Sponsors activities can be requested. */
export type Github_SponsorsActivityPeriod =
  /** Don't restrict the activity to any date range, include all activity. */
  | 'ALL'
  /** The previous calendar day. */
  | 'DAY'
  /** The previous thirty days. */
  | 'MONTH'
  /** The previous seven days. */
  | 'WEEK';

/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */
export type Github_SponsorsCountryOrRegionCode =
  /** Andorra */
  | 'AD'
  /** United Arab Emirates */
  | 'AE'
  /** Afghanistan */
  | 'AF'
  /** Antigua and Barbuda */
  | 'AG'
  /** Anguilla */
  | 'AI'
  /** Albania */
  | 'AL'
  /** Armenia */
  | 'AM'
  /** Angola */
  | 'AO'
  /** Antarctica */
  | 'AQ'
  /** Argentina */
  | 'AR'
  /** American Samoa */
  | 'AS'
  /** Austria */
  | 'AT'
  /** Australia */
  | 'AU'
  /** Aruba */
  | 'AW'
  /** land */
  | 'AX'
  /** Azerbaijan */
  | 'AZ'
  /** Bosnia and Herzegovina */
  | 'BA'
  /** Barbados */
  | 'BB'
  /** Bangladesh */
  | 'BD'
  /** Belgium */
  | 'BE'
  /** Burkina Faso */
  | 'BF'
  /** Bulgaria */
  | 'BG'
  /** Bahrain */
  | 'BH'
  /** Burundi */
  | 'BI'
  /** Benin */
  | 'BJ'
  /** Saint Barthlemy */
  | 'BL'
  /** Bermuda */
  | 'BM'
  /** Brunei Darussalam */
  | 'BN'
  /** Bolivia */
  | 'BO'
  /** Bonaire, Sint Eustatius and Saba */
  | 'BQ'
  /** Brazil */
  | 'BR'
  /** Bahamas */
  | 'BS'
  /** Bhutan */
  | 'BT'
  /** Bouvet Island */
  | 'BV'
  /** Botswana */
  | 'BW'
  /** Belarus */
  | 'BY'
  /** Belize */
  | 'BZ'
  /** Canada */
  | 'CA'
  /** Cocos (Keeling) Islands */
  | 'CC'
  /** Congo (Kinshasa) */
  | 'CD'
  /** Central African Republic */
  | 'CF'
  /** Congo (Brazzaville) */
  | 'CG'
  /** Switzerland */
  | 'CH'
  /** Cte d'Ivoire */
  | 'CI'
  /** Cook Islands */
  | 'CK'
  /** Chile */
  | 'CL'
  /** Cameroon */
  | 'CM'
  /** China */
  | 'CN'
  /** Colombia */
  | 'CO'
  /** Costa Rica */
  | 'CR'
  /** Cape Verde */
  | 'CV'
  /** Curaao */
  | 'CW'
  /** Christmas Island */
  | 'CX'
  /** Cyprus */
  | 'CY'
  /** Czech Republic */
  | 'CZ'
  /** Germany */
  | 'DE'
  /** Djibouti */
  | 'DJ'
  /** Denmark */
  | 'DK'
  /** Dominica */
  | 'DM'
  /** Dominican Republic */
  | 'DO'
  /** Algeria */
  | 'DZ'
  /** Ecuador */
  | 'EC'
  /** Estonia */
  | 'EE'
  /** Egypt */
  | 'EG'
  /** Western Sahara */
  | 'EH'
  /** Eritrea */
  | 'ER'
  /** Spain */
  | 'ES'
  /** Ethiopia */
  | 'ET'
  /** Finland */
  | 'FI'
  /** Fiji */
  | 'FJ'
  /** Falkland Islands */
  | 'FK'
  /** Micronesia */
  | 'FM'
  /** Faroe Islands */
  | 'FO'
  /** France */
  | 'FR'
  /** Gabon */
  | 'GA'
  /** United Kingdom */
  | 'GB'
  /** Grenada */
  | 'GD'
  /** Georgia */
  | 'GE'
  /** French Guiana */
  | 'GF'
  /** Guernsey */
  | 'GG'
  /** Ghana */
  | 'GH'
  /** Gibraltar */
  | 'GI'
  /** Greenland */
  | 'GL'
  /** Gambia */
  | 'GM'
  /** Guinea */
  | 'GN'
  /** Guadeloupe */
  | 'GP'
  /** Equatorial Guinea */
  | 'GQ'
  /** Greece */
  | 'GR'
  /** South Georgia and South Sandwich Islands */
  | 'GS'
  /** Guatemala */
  | 'GT'
  /** Guam */
  | 'GU'
  /** Guinea-Bissau */
  | 'GW'
  /** Guyana */
  | 'GY'
  /** Hong Kong */
  | 'HK'
  /** Heard and McDonald Islands */
  | 'HM'
  /** Honduras */
  | 'HN'
  /** Croatia */
  | 'HR'
  /** Haiti */
  | 'HT'
  /** Hungary */
  | 'HU'
  /** Indonesia */
  | 'ID'
  /** Ireland */
  | 'IE'
  /** Israel */
  | 'IL'
  /** Isle of Man */
  | 'IM'
  /** India */
  | 'IN'
  /** British Indian Ocean Territory */
  | 'IO'
  /** Iraq */
  | 'IQ'
  /** Iran */
  | 'IR'
  /** Iceland */
  | 'IS'
  /** Italy */
  | 'IT'
  /** Jersey */
  | 'JE'
  /** Jamaica */
  | 'JM'
  /** Jordan */
  | 'JO'
  /** Japan */
  | 'JP'
  /** Kenya */
  | 'KE'
  /** Kyrgyzstan */
  | 'KG'
  /** Cambodia */
  | 'KH'
  /** Kiribati */
  | 'KI'
  /** Comoros */
  | 'KM'
  /** Saint Kitts and Nevis */
  | 'KN'
  /** Korea, South */
  | 'KR'
  /** Kuwait */
  | 'KW'
  /** Cayman Islands */
  | 'KY'
  /** Kazakhstan */
  | 'KZ'
  /** Laos */
  | 'LA'
  /** Lebanon */
  | 'LB'
  /** Saint Lucia */
  | 'LC'
  /** Liechtenstein */
  | 'LI'
  /** Sri Lanka */
  | 'LK'
  /** Liberia */
  | 'LR'
  /** Lesotho */
  | 'LS'
  /** Lithuania */
  | 'LT'
  /** Luxembourg */
  | 'LU'
  /** Latvia */
  | 'LV'
  /** Libya */
  | 'LY'
  /** Morocco */
  | 'MA'
  /** Monaco */
  | 'MC'
  /** Moldova */
  | 'MD'
  /** Montenegro */
  | 'ME'
  /** Saint Martin (French part) */
  | 'MF'
  /** Madagascar */
  | 'MG'
  /** Marshall Islands */
  | 'MH'
  /** Macedonia */
  | 'MK'
  /** Mali */
  | 'ML'
  /** Myanmar */
  | 'MM'
  /** Mongolia */
  | 'MN'
  /** Macau */
  | 'MO'
  /** Northern Mariana Islands */
  | 'MP'
  /** Martinique */
  | 'MQ'
  /** Mauritania */
  | 'MR'
  /** Montserrat */
  | 'MS'
  /** Malta */
  | 'MT'
  /** Mauritius */
  | 'MU'
  /** Maldives */
  | 'MV'
  /** Malawi */
  | 'MW'
  /** Mexico */
  | 'MX'
  /** Malaysia */
  | 'MY'
  /** Mozambique */
  | 'MZ'
  /** Namibia */
  | 'NA'
  /** New Caledonia */
  | 'NC'
  /** Niger */
  | 'NE'
  /** Norfolk Island */
  | 'NF'
  /** Nigeria */
  | 'NG'
  /** Nicaragua */
  | 'NI'
  /** Netherlands */
  | 'NL'
  /** Norway */
  | 'NO'
  /** Nepal */
  | 'NP'
  /** Nauru */
  | 'NR'
  /** Niue */
  | 'NU'
  /** New Zealand */
  | 'NZ'
  /** Oman */
  | 'OM'
  /** Panama */
  | 'PA'
  /** Peru */
  | 'PE'
  /** French Polynesia */
  | 'PF'
  /** Papua New Guinea */
  | 'PG'
  /** Philippines */
  | 'PH'
  /** Pakistan */
  | 'PK'
  /** Poland */
  | 'PL'
  /** Saint Pierre and Miquelon */
  | 'PM'
  /** Pitcairn */
  | 'PN'
  /** Puerto Rico */
  | 'PR'
  /** Palestine */
  | 'PS'
  /** Portugal */
  | 'PT'
  /** Palau */
  | 'PW'
  /** Paraguay */
  | 'PY'
  /** Qatar */
  | 'QA'
  /** Reunion */
  | 'RE'
  /** Romania */
  | 'RO'
  /** Serbia */
  | 'RS'
  /** Russian Federation */
  | 'RU'
  /** Rwanda */
  | 'RW'
  /** Saudi Arabia */
  | 'SA'
  /** Solomon Islands */
  | 'SB'
  /** Seychelles */
  | 'SC'
  /** Sudan */
  | 'SD'
  /** Sweden */
  | 'SE'
  /** Singapore */
  | 'SG'
  /** Saint Helena */
  | 'SH'
  /** Slovenia */
  | 'SI'
  /** Svalbard and Jan Mayen Islands */
  | 'SJ'
  /** Slovakia */
  | 'SK'
  /** Sierra Leone */
  | 'SL'
  /** San Marino */
  | 'SM'
  /** Senegal */
  | 'SN'
  /** Somalia */
  | 'SO'
  /** Suriname */
  | 'SR'
  /** South Sudan */
  | 'SS'
  /** Sao Tome and Principe */
  | 'ST'
  /** El Salvador */
  | 'SV'
  /** Sint Maarten (Dutch part) */
  | 'SX'
  /** Swaziland */
  | 'SZ'
  /** Turks and Caicos Islands */
  | 'TC'
  /** Chad */
  | 'TD'
  /** French Southern Lands */
  | 'TF'
  /** Togo */
  | 'TG'
  /** Thailand */
  | 'TH'
  /** Tajikistan */
  | 'TJ'
  /** Tokelau */
  | 'TK'
  /** Timor-Leste */
  | 'TL'
  /** Turkmenistan */
  | 'TM'
  /** Tunisia */
  | 'TN'
  /** Tonga */
  | 'TO'
  /** Turkey */
  | 'TR'
  /** Trinidad and Tobago */
  | 'TT'
  /** Tuvalu */
  | 'TV'
  /** Taiwan */
  | 'TW'
  /** Tanzania */
  | 'TZ'
  /** Ukraine */
  | 'UA'
  /** Uganda */
  | 'UG'
  /** United States Minor Outlying Islands */
  | 'UM'
  /** United States of America */
  | 'US'
  /** Uruguay */
  | 'UY'
  /** Uzbekistan */
  | 'UZ'
  /** Vatican City */
  | 'VA'
  /** Saint Vincent and the Grenadines */
  | 'VC'
  /** Venezuela */
  | 'VE'
  /** Virgin Islands, British */
  | 'VG'
  /** Virgin Islands, U.S. */
  | 'VI'
  /** Vietnam */
  | 'VN'
  /** Vanuatu */
  | 'VU'
  /** Wallis and Futuna Islands */
  | 'WF'
  /** Samoa */
  | 'WS'
  /** Yemen */
  | 'YE'
  /** Mayotte */
  | 'YT'
  /** South Africa */
  | 'ZA'
  /** Zambia */
  | 'ZM'
  /** Zimbabwe */
  | 'ZW';

/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */
export type Github_SponsorsGoal = {
  /** A description of the goal from the maintainer. */
  description?: Maybe<Scalars['String']>;
  /** What the objective of this goal is. */
  kind: Github_SponsorsGoalKind;
  /** The percentage representing how complete this goal is, between 0-100. */
  percentComplete: Scalars['Int'];
  /**
   * What the goal amount is. Represents an amount in USD for monthly sponsorship
   * amount goals. Represents a count of unique sponsors for total sponsors count goals.
   */
  targetValue: Scalars['Int'];
  /** A brief summary of the kind and target value of this goal. */
  title: Scalars['String'];
};

/** The different kinds of goals a GitHub Sponsors member can have. */
export type Github_SponsorsGoalKind =
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  | 'MONTHLY_SPONSORSHIP_AMOUNT'
  /** The goal is about reaching a certain number of sponsors. */
  | 'TOTAL_SPONSORS_COUNT';

/** A GitHub Sponsors listing. */
export type Github_SponsorsListing = Github_Node & {
  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */
  activeGoal?: Maybe<Github_SponsorsGoal>;
  /**
   * The Stripe Connect account currently in use for payouts for this Sponsors
   * listing, if any. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  activeStripeConnectAccount?: Maybe<Github_StripeConnectAccount>;
  /**
   * The name of the country or region with the maintainer's bank account or fiscal
   * host. Will only return a value when queried by the maintainer themselves, or
   * by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars['String']>;
  /**
   * The email address used by GitHub to contact the sponsorable about their GitHub
   * Sponsors profile. Will only return a value when queried by the maintainer
   * themselves, or by an admin of the sponsorable organization.
   */
  contactEmailAddress?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */
  dashboardResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */
  dashboardUrl: Scalars['Github_URI'];
  /** The records featured on the GitHub Sponsors profile. */
  featuredItems: Array<Github_SponsorsListingFeaturedItem>;
  /**
   * The fiscal host used for payments, if any. Will only return a value when
   * queried by the maintainer themselves, or by an admin of the sponsorable organization.
   */
  fiscalHost?: Maybe<Github_Organization>;
  /** The full description of the listing. */
  fullDescription: Scalars['String'];
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** Whether this listing is publicly visible. */
  isPublic: Scalars['Boolean'];
  /** The listing's full name. */
  name: Scalars['String'];
  /** A future date on which this listing is eligible to receive a payout. */
  nextPayoutDate?: Maybe<Scalars['Date']>;
  /**
   * The name of the country or region where the maintainer resides. Will only
   * return a value when queried by the maintainer themselves, or by an admin of
   * the sponsorable organization.
   */
  residenceCountryOrRegion?: Maybe<Scalars['String']>;
  /** The HTTP path for this Sponsors listing. */
  resourcePath: Scalars['Github_URI'];
  /** The short description of the listing. */
  shortDescription: Scalars['String'];
  /** The short name of the listing. */
  slug: Scalars['String'];
  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */
  sponsorable: Github_Sponsorable;
  /** The tiers for this GitHub Sponsors profile. */
  tiers?: Maybe<Github_SponsorsTierConnection>;
  /** The HTTP URL for this Sponsors listing. */
  url: Scalars['Github_URI'];
};


/** A GitHub Sponsors listing. */
export type Github_SponsorsListingfeaturedItemsArgs = {
  featureableTypes?: InputMaybe<Array<Github_SponsorsListingFeaturedItemFeatureableType>>;
};


/** A GitHub Sponsors listing. */
export type Github_SponsorsListingtiersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeUnpublished?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsTierOrder>;
};

/** A record that can be featured on a GitHub Sponsors profile. */
export type Github_SponsorsListingFeatureableItem = Github_Repository | Github_User;

/** A record that is promoted on a GitHub Sponsors profile. */
export type Github_SponsorsListingFeaturedItem = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /**
   * Will either be a description from the sponsorable maintainer about why they
   * featured this item, or the item's description itself, such as a user's bio
   * from their GitHub profile page.
   */
  description?: Maybe<Scalars['String']>;
  /** The record that is featured on the GitHub Sponsors profile. */
  featureable: Github_SponsorsListingFeatureableItem;
  id: Scalars['ID'];
  /**
   * The position of this featured item on the GitHub Sponsors profile with a lower
   * position indicating higher precedence. Starts at 1.
   */
  position: Scalars['Int'];
  /** The GitHub Sponsors profile that features this record. */
  sponsorsListing: Github_SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */
export type Github_SponsorsListingFeaturedItemFeatureableType =
  /** A repository owned by the user or organization with the GitHub Sponsors profile. */
  | 'REPOSITORY'
  /** A user who belongs to the organization with the GitHub Sponsors profile. */
  | 'USER';

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type Github_SponsorsTier = Github_Node & {
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<Github_SponsorsTierAdminInfo>;
  /**
   * Get a different tier for this tier's maintainer that is at the same frequency
   * as this tier but with an equal or lesser cost. Returns the published tier with
   * the monthly price closest to this tier's without going over.
   */
  closestLesserValueTier?: Maybe<Github_SponsorsTier>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the tier. */
  description: Scalars['String'];
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /**
   * Whether this tier was chosen at checkout time by the sponsor rather than
   * defined ahead of time by the maintainer who manages the Sponsors listing.
   */
  isCustomAmount: Scalars['Boolean'];
  /** Whether this tier is only for use with one-time sponsorships. */
  isOneTime: Scalars['Boolean'];
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars['Int'];
  /** How much this tier costs per month in USD. */
  monthlyPriceInDollars: Scalars['Int'];
  /** The name of the tier. */
  name: Scalars['String'];
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: Github_SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type Github_SponsorsTierAdminInfo = {
  /**
   * Indicates whether this tier is still a work in progress by the sponsorable and
   * not yet published to the associated GitHub Sponsors profile. Draft tiers
   * cannot be used for new sponsorships and will not be in use on existing
   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the
   * GitHub Sponsors profile.
   */
  isDraft: Scalars['Boolean'];
  /**
   * Indicates whether this tier is published to the associated GitHub Sponsors
   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors
   * profile, and are available for use in sponsorships if the GitHub Sponsors
   * profile is publicly visible.
   */
  isPublished: Scalars['Boolean'];
  /**
   * Indicates whether this tier has been retired from the associated GitHub
   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors
   * profile and cannot be chosen for new sponsorships. Existing sponsorships may
   * still use retired tiers if the sponsor selected the tier before it was retired.
   */
  isRetired: Scalars['Boolean'];
  /** The sponsorships using this tier. */
  sponsorships: Github_SponsorshipConnection;
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type Github_SponsorsTierAdminInfosponsorshipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
export type Github_SponsorsTierConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorsTierEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorsTier>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorsTierEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
export type Github_SponsorsTierOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order tiers by. */
  field: Github_SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export type Github_SponsorsTierOrderField =
  /** Order tiers by creation time. */
  | 'CREATED_AT'
  /** Order tiers by their monthly price in cents */
  | 'MONTHLY_PRICE_IN_CENTS';

/** A sponsorship relationship between a sponsor and a maintainer */
export type Github_Sponsorship = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Whether the sponsorship is active. False implies the sponsor is a past sponsor
   * of the maintainer, while true implies they are a current sponsor.
   */
  isActive: Scalars['Boolean'];
  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */
  isOneTimePayment: Scalars['Boolean'];
  /**
   * Whether the sponsor has chosen to receive sponsorship update emails sent from
   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.
   */
  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']>;
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  maintainer: Github_User;
  /** The privacy level for this sponsorship. */
  privacyLevel: Github_SponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  sponsor?: Maybe<Github_User>;
  /** The user or organization that is sponsoring, if you have permission to view them. */
  sponsorEntity?: Maybe<Github_Sponsor>;
  /** The entity that is being sponsored */
  sponsorable: Github_Sponsorable;
  /** The associated sponsorship tier */
  tier?: Maybe<Github_SponsorsTier>;
  /** Identifies the date and time when the current tier was chosen for this sponsorship. */
  tierSelectedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for Sponsorship. */
export type Github_SponsorshipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorshipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Sponsorship>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /**
   * The total amount in cents of all recurring sponsorships in the connection
   * whose amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInCents: Scalars['Int'];
  /**
   * The total amount in USD of all recurring sponsorships in the connection whose
   * amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInDollars: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorshipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Sponsorship>;
};

/** An update sent to sponsors of a user or organization on GitHub Sponsors. */
export type Github_SponsorshipNewsletter = Github_Node & {
  /** The author of the newsletter. */
  author?: Maybe<Github_User>;
  /** The contents of the newsletter, the message the sponsorable wanted to give. */
  body: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Indicates if the newsletter has been made available to sponsors. */
  isPublished: Scalars['Boolean'];
  /** The user or organization this newsletter is from. */
  sponsorable: Github_Sponsorable;
  /** The subject of the newsletter, what it's about. */
  subject: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for SponsorshipNewsletter. */
export type Github_SponsorshipNewsletterConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorshipNewsletterEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorshipNewsletter>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorshipNewsletterEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorshipNewsletter>;
};

/** Ordering options for sponsorship newsletter connections. */
export type Github_SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: Github_SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export type Github_SponsorshipNewsletterOrderField =
  /** Order sponsorship newsletters by when they were created. */
  | 'CREATED_AT';

/** Ordering options for sponsorship connections. */
export type Github_SponsorshipOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsorship by. */
  field: Github_SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export type Github_SponsorshipOrderField =
  /** Order sponsorship by creation time. */
  | 'CREATED_AT';

/** The privacy of a sponsorship */
export type Github_SponsorshipPrivacy =
  /** Private */
  | 'PRIVATE'
  /** Public */
  | 'PUBLIC';

/** The possible default commit messages for squash merges. */
export type Github_SquashMergeCommitMessage =
  /** Default to a blank commit message. */
  | 'BLANK'
  /** Default to the branch's commit messages. */
  | 'COMMIT_MESSAGES'
  /** Default to the pull request's body. */
  | 'PR_BODY';

/** The possible default commit titles for squash merges. */
export type Github_SquashMergeCommitTitle =
  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */
  | 'COMMIT_OR_PR_TITLE'
  /** Default to the pull request's title. */
  | 'PR_TITLE';

/** Represents an SSH signature on a Commit or Tag. */
export type Github_SshSignature = Github_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Hex-encoded fingerprint of the key that signed this object. */
  keyFingerprint?: Maybe<Scalars['String']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Ways in which star connections can be ordered. */
export type Github_StarOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field in which to order nodes by. */
  field: Github_StarOrderField;
};

/** Properties by which star connections can be ordered. */
export type Github_StarOrderField =
  /** Allows ordering a list of stars by when they were created. */
  | 'STARRED_AT';

/** The connection type for User. */
export type Github_StargazerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_StargazerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user that's starred a repository. */
export type Github_StargazerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_User;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'];
};

/** Things that can be starred. */
export type Github_Starrable = {
  id: Scalars['ID'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** Things that can be starred. */
export type Github_StarrablestargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** The connection type for Repository. */
export type Github_StarredRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_StarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  isOverLimit: Scalars['Boolean'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a starred repository. */
export type Github_StarredRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_Repository;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'];
};

/** Autogenerated input type of StartOrganizationMigration */
export type Github_StartOrganizationMigrationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The migration source access token. */
  sourceAccessToken: Scalars['String'];
  /** The URL of the organization to migrate. */
  sourceOrgUrl: Scalars['Github_URI'];
  /** The ID of the enterprise the target organization belongs to. */
  targetEnterpriseId: Scalars['ID'];
  /** The name of the target organization. */
  targetOrgName: Scalars['String'];
};

/** Autogenerated return type of StartOrganizationMigration */
export type Github_StartOrganizationMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new organization migration. */
  orgMigration?: Maybe<Github_OrganizationMigration>;
};

/** Autogenerated input type of StartRepositoryMigration */
export type Github_StartRepositoryMigrationInput = {
  /** The migration source access token. */
  accessToken: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether to continue the migration on error. Defaults to `false`. */
  continueOnError?: InputMaybe<Scalars['Boolean']>;
  /** The signed URL to access the user-uploaded git archive. */
  gitArchiveUrl?: InputMaybe<Scalars['String']>;
  /** The GitHub personal access token of the user importing to the target repository. */
  githubPat?: InputMaybe<Scalars['String']>;
  /** Whether to lock the source repository. */
  lockSource?: InputMaybe<Scalars['Boolean']>;
  /** The signed URL to access the user-uploaded metadata archive. */
  metadataArchiveUrl?: InputMaybe<Scalars['String']>;
  /** The ID of the organization that will own the imported repository. */
  ownerId: Scalars['ID'];
  /** The name of the imported repository. */
  repositoryName: Scalars['String'];
  /** Whether to skip migrating releases for the repository. */
  skipReleases?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the migration source. */
  sourceId: Scalars['ID'];
  /** The URL of the source repository. */
  sourceRepositoryUrl: Scalars['Github_URI'];
  /** The visibility of the imported repository. */
  targetRepoVisibility?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of StartRepositoryMigration */
export type Github_StartRepositoryMigrationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository migration. */
  repositoryMigration?: Maybe<Github_RepositoryMigration>;
};

/** Represents a commit status. */
export type Github_Status = Github_Node & {
  /** A list of status contexts and check runs for this commit. */
  combinedContexts: Github_StatusCheckRollupContextConnection;
  /** The commit this status is attached to. */
  commit?: Maybe<Github_Commit>;
  /** Looks up an individual status context by context name. */
  context?: Maybe<Github_StatusContext>;
  /** The individual status contexts for this commit. */
  contexts: Array<Github_StatusContext>;
  id: Scalars['ID'];
  /** The combined commit status. */
  state: Github_StatusState;
};


/** Represents a commit status. */
export type Github_StatuscombinedContextsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a commit status. */
export type Github_StatuscontextArgs = {
  name: Scalars['String'];
};

/** Represents the rollup for both the check runs and status for a commit. */
export type Github_StatusCheckRollup = Github_Node & {
  /** The commit the status and check runs are attached to. */
  commit?: Maybe<Github_Commit>;
  /** A list of status contexts and check runs for this commit. */
  contexts: Github_StatusCheckRollupContextConnection;
  id: Scalars['ID'];
  /** The combined status for the commit. */
  state: Github_StatusState;
};


/** Represents the rollup for both the check runs and status for a commit. */
export type Github_StatusCheckRollupcontextsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Types that can be inside a StatusCheckRollup context. */
export type Github_StatusCheckRollupContext = Github_CheckRun | Github_StatusContext;

/** The connection type for StatusCheckRollupContext. */
export type Github_StatusCheckRollupContextConnection = {
  /** The number of check runs in this rollup. */
  checkRunCount: Scalars['Int'];
  /** Counts of check runs by state. */
  checkRunCountsByState?: Maybe<Array<Github_CheckRunStateCount>>;
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_StatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_StatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** The number of status contexts in this rollup. */
  statusContextCount: Scalars['Int'];
  /** Counts of status contexts by state. */
  statusContextCountsByState?: Maybe<Array<Github_StatusContextStateCount>>;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_StatusCheckRollupContextEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_StatusCheckRollupContext>;
};

/** Represents an individual commit status context */
export type Github_StatusContext = Github_Node & Github_RequirableByPullRequest & {
  /** The avatar of the OAuth application or the user that created the status */
  avatarUrl?: Maybe<Scalars['Github_URI']>;
  /** This commit this status context is attached to. */
  commit?: Maybe<Github_Commit>;
  /** The name of this status context. */
  context: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this status context. */
  creator?: Maybe<Github_Actor>;
  /** The description for this status context. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
  /** The state of this status context. */
  state: Github_StatusState;
  /** The URL for this status context. */
  targetUrl?: Maybe<Scalars['Github_URI']>;
};


/** Represents an individual commit status context */
export type Github_StatusContextavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents an individual commit status context */
export type Github_StatusContextisRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};

/** Represents a count of the state of a status context. */
export type Github_StatusContextStateCount = {
  /** The number of statuses with this state. */
  count: Scalars['Int'];
  /** The state of a status context. */
  state: Github_StatusState;
};

/** The possible commit status states. */
export type Github_StatusState =
  /** Status is errored. */
  | 'ERROR'
  /** Status is expected. */
  | 'EXPECTED'
  /** Status is failing. */
  | 'FAILURE'
  /** Status is pending. */
  | 'PENDING'
  /** Status is successful. */
  | 'SUCCESS';

/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */
export type Github_StripeConnectAccount = {
  /** The account number used to identify this Stripe Connect account. */
  accountId: Scalars['String'];
  /**
   * The name of the country or region of an external account, such as a bank
   * account, tied to the Stripe Connect account. Will only return a value when
   * queried by the maintainer of the associated GitHub Sponsors profile
   * themselves, or by an admin of the sponsorable organization.
   */
  billingCountryOrRegion?: Maybe<Scalars['String']>;
  /**
   * The name of the country or region of the Stripe Connect account. Will only
   * return a value when queried by the maintainer of the associated GitHub
   * Sponsors profile themselves, or by an admin of the sponsorable organization.
   */
  countryOrRegion?: Maybe<Scalars['String']>;
  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */
  isActive: Scalars['Boolean'];
  /** The GitHub Sponsors profile associated with this Stripe Connect account. */
  sponsorsListing: Github_SponsorsListing;
  /** The URL to access this Stripe Connect account on Stripe's website. */
  stripeDashboardUrl: Scalars['Github_URI'];
};

/** Autogenerated input type of SubmitPullRequestReview */
export type Github_SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The event to send to the Pull Request Review. */
  event: Github_PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: InputMaybe<Scalars['ID']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of SubmitPullRequestReview */
export type Github_SubmitPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
export type Github_Submodule = {
  /** The branch of the upstream submodule for tracking updates */
  branch?: Maybe<Scalars['String']>;
  /** The git URL of the submodule repository */
  gitUrl: Scalars['Github_URI'];
  /** The name of the submodule in .gitmodules */
  name: Scalars['String'];
  /** The name of the submodule in .gitmodules (Base64-encoded) */
  nameRaw: Scalars['Github_Base64String'];
  /** The path in the superproject that this submodule is located in */
  path: Scalars['String'];
  /** The path in the superproject that this submodule is located in (Base64-encoded) */
  pathRaw: Scalars['Github_Base64String'];
  /** The commit revision of the subproject repository being tracked by the submodule */
  subprojectCommitOid?: Maybe<Scalars['Github_GitObjectID']>;
};

/** The connection type for Submodule. */
export type Github_SubmoduleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SubmoduleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Submodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type Github_Subscribable = {
  id: Scalars['ID'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type Github_SubscribedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object referenced by event. */
  subscribable: Github_Subscribable;
};

/** The possible states of a subscription. */
export type Github_SubscriptionState =
  /** The User is never notified. */
  | 'IGNORED'
  /** The User is notified of all conversations. */
  | 'SUBSCRIBED'
  /** The User is only notified when participating or @mentioned. */
  | 'UNSUBSCRIBED';

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type Github_SuggestedReviewer = {
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars['Boolean'];
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars['Boolean'];
  /** Identifies the user suggested to review the pull request. */
  reviewer: Github_User;
};

/** Represents a Git tag. */
export type Github_Tag = Github_GitObject & Github_Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The Git tag message. */
  message?: Maybe<Scalars['String']>;
  /** The Git tag name. */
  name: Scalars['String'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
  /** Details about the tag author. */
  tagger?: Maybe<Github_GitActor>;
  /** The Git object the tag points to. */
  target: Github_GitObject;
};

/** A team of users in an organization. */
export type Github_Team = Github_MemberStatusable & Github_Node & Github_Subscribable & {
  /** A list of teams that are ancestors of this team. */
  ancestors: Github_TeamConnection;
  /** A URL pointing to the team's avatar. */
  avatarUrl?: Maybe<Scalars['Github_URI']>;
  /** List of child teams belonging to this team */
  childTeams: Github_TeamConnection;
  /** The slug corresponding to the organization and team. */
  combinedSlug: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the team. */
  description?: Maybe<Scalars['String']>;
  /** Find a team discussion by its number. */
  discussion?: Maybe<Github_TeamDiscussion>;
  /** A list of team discussions. */
  discussions: Github_TeamDiscussionConnection;
  /** The HTTP path for team discussions */
  discussionsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for team discussions */
  discussionsUrl: Scalars['Github_URI'];
  /** The HTTP path for editing this team */
  editTeamResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for editing this team */
  editTeamUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** A list of pending invitations for users to this team */
  invitations?: Maybe<Github_OrganizationInvitationConnection>;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
  /** A list of users who are members of this team. */
  members: Github_TeamMemberConnection;
  /** The HTTP path for the team' members */
  membersResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the team' members */
  membersUrl: Scalars['Github_URI'];
  /** The name of the team. */
  name: Scalars['String'];
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['Github_URI'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['Github_URI'];
  /** The organization that owns this team. */
  organization: Github_Organization;
  /** The parent team of the team. */
  parentTeam?: Maybe<Github_Team>;
  /** The level of privacy the team has. */
  privacy: Github_TeamPrivacy;
  /** Finds and returns the project according to the provided project number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** List of projects this team has collaborator access to. */
  projectsV2: Github_ProjectV2Connection;
  /** A list of repositories this team has access to. */
  repositories: Github_TeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: Scalars['Github_URI'];
  /** The HTTP path for this team */
  resourcePath: Scalars['Github_URI'];
  /** What algorithm is used for review assignment for this team */
  reviewRequestDelegationAlgorithm?: Maybe<Github_TeamReviewAssignmentAlgorithm>;
  /** True if review assignment is enabled for this team */
  reviewRequestDelegationEnabled: Scalars['Boolean'];
  /** How many team members are required for review assignment for this team */
  reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']>;
  /** When assigning team members via delegation, whether the entire team should be notified as well. */
  reviewRequestDelegationNotifyTeam: Scalars['Boolean'];
  /** The slug corresponding to the team. */
  slug: Scalars['String'];
  /** The HTTP path for this team's teams */
  teamsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this team's teams */
  teamsUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this team */
  url: Scalars['Github_URI'];
  /** Team is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A team of users in an organization. */
export type Github_TeamancestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type Github_TeamavatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type Github_TeamchildTeamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  immediateOnly?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamOrder>;
  userLogins?: InputMaybe<Array<Scalars['String']>>;
};


/** A team of users in an organization. */
export type Github_TeamdiscussionArgs = {
  number: Scalars['Int'];
};


/** A team of users in an organization. */
export type Github_TeamdiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isPinned?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamDiscussionOrder>;
};


/** A team of users in an organization. */
export type Github_TeaminvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type Github_TeammemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};


/** A team of users in an organization. */
export type Github_TeammembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membership?: InputMaybe<Github_TeamMembershipType>;
  orderBy?: InputMaybe<Github_TeamMemberOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_TeamMemberRole>;
};


/** A team of users in an organization. */
export type Github_TeamprojectV2Args = {
  number: Scalars['Int'];
};


/** A team of users in an organization. */
export type Github_TeamprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_ProjectV2Filters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};


/** A team of users in an organization. */
export type Github_TeamrepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamRepositoryOrder>;
  query?: InputMaybe<Scalars['String']>;
};

/** Audit log entry for a team.add_member event. */
export type Github_TeamAddMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a team.add_repository event. */
export type Github_TeamAddRepositoryAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Metadata for an audit entry with action team.* */
export type Github_TeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a team.change_parent_team event. */
export type Github_TeamChangeParentTeamAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The new parent team. */
  parentTeam?: Maybe<Github_Team>;
  /** The name of the new parent team */
  parentTeamName?: Maybe<Scalars['String']>;
  /** The name of the former parent team */
  parentTeamNameWas?: Maybe<Scalars['String']>;
  /** The HTTP path for the parent team */
  parentTeamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the parent team */
  parentTeamUrl?: Maybe<Scalars['Github_URI']>;
  /** The former parent team. */
  parentTeamWas?: Maybe<Github_Team>;
  /** The HTTP path for the previous parent team */
  parentTeamWasResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the previous parent team */
  parentTeamWasUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for Team. */
export type Github_TeamConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Team>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A team discussion. */
export type Github_TeamDiscussion = Github_Comment & Github_Deletable & Github_Node & Github_Reactable & Github_Subscribable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the discussion's team. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the discussion body hash. */
  bodyVersion: Scalars['String'];
  /** A list of comments on this discussion. */
  comments: Github_TeamDiscussionCommentConnection;
  /** The HTTP path for discussion comments */
  commentsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for discussion comments */
  commentsUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Whether or not the discussion is pinned. */
  isPinned: Scalars['Boolean'];
  /** Whether or not the discussion is only visible to team members and org admins. */
  isPrivate: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the discussion within its team. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The HTTP path for this discussion */
  resourcePath: Scalars['Github_URI'];
  /** The team that defines the context of this discussion. */
  team: Github_Team;
  /** The title of the discussion */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this discussion */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Whether or not the current viewer can pin this discussion. */
  viewerCanPin: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A team discussion. */
export type Github_TeamDiscussioncommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  fromComment?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamDiscussionCommentOrder>;
};


/** A team discussion. */
export type Github_TeamDiscussionreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A team discussion. */
export type Github_TeamDiscussionuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A comment on a team discussion. */
export type Github_TeamDiscussionComment = Github_Comment & Github_Deletable & Github_Node & Github_Reactable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the comment's team. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The discussion this comment is about. */
  discussion: Github_TeamDiscussion;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the comment number. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The HTTP path for this comment */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this comment */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A comment on a team discussion. */
export type Github_TeamDiscussionCommentreactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A comment on a team discussion. */
export type Github_TeamDiscussionCommentuserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for TeamDiscussionComment. */
export type Github_TeamDiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_TeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_TeamDiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_TeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
export type Github_TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field by which to order nodes. */
  field: Github_TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export type Github_TeamDiscussionCommentOrderField =
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  | 'NUMBER';

/** The connection type for TeamDiscussion. */
export type Github_TeamDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_TeamDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_TeamDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_TeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
export type Github_TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field by which to order nodes. */
  field: Github_TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export type Github_TeamDiscussionOrderField =
  /** Allows chronological ordering of team discussions. */
  | 'CREATED_AT';

/** An edge in a connection. */
export type Github_TeamEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Team>;
};

/** The connection type for User. */
export type Github_TeamMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user who is a member of a team. */
export type Github_TeamMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars['Github_URI'];
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars['Github_URI'];
  node: Github_User;
  /** The role the member has on the team. */
  role: Github_TeamMemberRole;
};

/** Ordering options for team member connections */
export type Github_TeamMemberOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order team members by. */
  field: Github_TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export type Github_TeamMemberOrderField =
  /** Order team members by creation time */
  | 'CREATED_AT'
  /** Order team members by login */
  | 'LOGIN';

/** The possible team member roles; either 'maintainer' or 'member'. */
export type Github_TeamMemberRole =
  /** A team maintainer has permission to add and remove team members. */
  | 'MAINTAINER'
  /** A team member has no administrative permissions on the team. */
  | 'MEMBER';

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export type Github_TeamMembershipType =
  /** Includes immediate and child team members for the team. */
  | 'ALL'
  /** Includes only child team members for the team. */
  | 'CHILD_TEAM'
  /** Includes only immediate members of the team. */
  | 'IMMEDIATE';

/** Ways in which team connections can be ordered. */
export type Github_TeamOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field in which to order nodes by. */
  field: Github_TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export type Github_TeamOrderField =
  /** Allows ordering a list of teams by name. */
  | 'NAME';

/** The possible team privacy values. */
export type Github_TeamPrivacy =
  /** A secret team can only be seen by its members. */
  | 'SECRET'
  /** A visible team can be seen and @mentioned by every member of the organization. */
  | 'VISIBLE';

/** Audit log entry for a team.remove_member event. */
export type Github_TeamRemoveMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a team.remove_repository event. */
export type Github_TeamRemoveRepositoryAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for Repository. */
export type Github_TeamRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a team repository. */
export type Github_TeamRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_Repository;
  /** The permission level the team has on the repository */
  permission: Github_RepositoryPermission;
};

/** Ordering options for team repository connections */
export type Github_TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repositories by. */
  field: Github_TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export type Github_TeamRepositoryOrderField =
  /** Order repositories by creation time */
  | 'CREATED_AT'
  /** Order repositories by name */
  | 'NAME'
  /** Order repositories by permission */
  | 'PERMISSION'
  /** Order repositories by push time */
  | 'PUSHED_AT'
  /** Order repositories by number of stargazers */
  | 'STARGAZERS'
  /** Order repositories by update time */
  | 'UPDATED_AT';

/** The possible team review assignment algorithms */
export type Github_TeamReviewAssignmentAlgorithm =
  /** Balance review load across the entire team */
  | 'LOAD_BALANCE'
  /** Alternate reviews between each team member */
  | 'ROUND_ROBIN';

/** The role of a user on a team. */
export type Github_TeamRole =
  /** User has admin rights on the team. */
  | 'ADMIN'
  /** User is a member of the team. */
  | 'MEMBER';

/** A text match within a search result. */
export type Github_TextMatch = {
  /** The specific text fragment within the property matched on. */
  fragment: Scalars['String'];
  /** Highlights within the matched fragment. */
  highlights: Array<Github_TextMatchHighlight>;
  /** The property matched on. */
  property: Scalars['String'];
};

/** Represents a single highlight in a search result match. */
export type Github_TextMatchHighlight = {
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars['Int'];
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars['Int'];
  /** The text matched. */
  text: Scalars['String'];
};

/** A topic aggregates entities that are related to a subject. */
export type Github_Topic = Github_Node & Github_Starrable & {
  id: Scalars['ID'];
  /** The topic's name. */
  name: Scalars['String'];
  /**
   * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
   */
  relatedTopics: Array<Github_Topic>;
  /** A list of repositories. */
  repositories: Github_RepositoryConnection;
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** A topic aggregates entities that are related to a subject. */
export type Github_TopicrelatedTopicsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** A topic aggregates entities that are related to a subject. */
export type Github_TopicrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
  sponsorableOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A topic aggregates entities that are related to a subject. */
export type Github_TopicstargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** Metadata for an audit entry with a topic. */
export type Github_TopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
};

/** Reason that the suggested topic is declined. */
export type Github_TopicSuggestionDeclineReason =
  /** The suggested topic is not relevant to the repository. */
  | 'NOT_RELEVANT'
  /** The viewer does not like the suggested topic. */
  | 'PERSONAL_PREFERENCE'
  /** The suggested topic is too general for the repository. */
  | 'TOO_GENERAL'
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  | 'TOO_SPECIFIC';

/** The possible states of a tracked issue. */
export type Github_TrackedIssueStates =
  /** The tracked issue is closed */
  | 'CLOSED'
  /** The tracked issue is open */
  | 'OPEN';

/** Autogenerated input type of TransferEnterpriseOrganization */
export type Github_TransferEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise where the organization should be transferred. */
  destinationEnterpriseId: Scalars['ID'];
  /** The ID of the organization to transfer. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of TransferEnterpriseOrganization */
export type Github_TransferEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization for which a transfer was initiated. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of TransferIssue */
export type Github_TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether to create labels if they don't exist in the target repository (matched by name) */
  createLabelsIfMissing?: InputMaybe<Scalars['Boolean']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of TransferIssue */
export type Github_TransferIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was transferred */
  issue?: Maybe<Github_Issue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type Github_TransferredEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The repository this came from */
  fromRepository?: Maybe<Github_Repository>;
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: Github_Issue;
};

/** Represents a Git tree. */
export type Github_Tree = Github_GitObject & Github_Node & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  /** A list of tree entries. */
  entries?: Maybe<Array<Github_TreeEntry>>;
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
};

/** Represents a Git tree entry. */
export type Github_TreeEntry = {
  /** The extension of the file */
  extension?: Maybe<Scalars['String']>;
  /** Whether or not this tree entry is generated */
  isGenerated: Scalars['Boolean'];
  /** The programming language this file is written in. */
  language?: Maybe<Github_Language>;
  /** Number of lines in the file. */
  lineCount?: Maybe<Scalars['Int']>;
  /** Entry file mode. */
  mode: Scalars['Int'];
  /** Entry file name. */
  name: Scalars['String'];
  /** Entry file name. (Base64-encoded) */
  nameRaw: Scalars['Github_Base64String'];
  /** Entry file object. */
  object?: Maybe<Github_GitObject>;
  /** Entry file Git object ID. */
  oid: Scalars['Github_GitObjectID'];
  /** The full path of the file. */
  path?: Maybe<Scalars['String']>;
  /** The full path of the file. (Base64-encoded) */
  pathRaw?: Maybe<Scalars['Github_Base64String']>;
  /** The Repository the tree entry belongs to */
  repository: Github_Repository;
  /** Entry byte size */
  size: Scalars['Int'];
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  submodule?: Maybe<Github_Submodule>;
  /** Entry file type. */
  type: Scalars['String'];
};

/** Autogenerated input type of UnarchiveProjectV2Item */
export type Github_UnarchiveProjectV2ItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the ProjectV2Item to unarchive. */
  itemId: Scalars['ID'];
  /** The ID of the Project to archive the item from. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of UnarchiveProjectV2Item */
export type Github_UnarchiveProjectV2ItemPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item unarchived from the project. */
  item?: Maybe<Github_ProjectV2Item>;
};

/** Autogenerated input type of UnarchiveRepository */
export type Github_UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnarchiveRepository */
export type Github_UnarchiveRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was unarchived. */
  repository?: Maybe<Github_Repository>;
};

/** Represents an 'unassigned' event on any assignable object. */
export type Github_UnassignedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Github_Assignable;
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<Github_Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<Github_User>;
};

/** Autogenerated input type of UnfollowOrganization */
export type Github_UnfollowOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the organization to unfollow. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of UnfollowOrganization */
export type Github_UnfollowOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization that was unfollowed. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of UnfollowUser */
export type Github_UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of UnfollowUser */
export type Github_UnfollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was unfollowed. */
  user?: Maybe<Github_User>;
};

/** Represents a type that can be retrieved by a URL. */
export type Github_UniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** The URL to this resource. */
  url: Scalars['Github_URI'];
};

/** Represents an unknown signature on a Commit or Tag. */
export type Github_UnknownSignature = Github_GitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type Github_UnlabeledEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the label associated with the 'unlabeled' event. */
  label: Github_Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Github_Labelable;
};

/** Autogenerated input type of UnlinkProjectV2FromRepository */
export type Github_UnlinkProjectV2FromRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the project to unlink from the repository. */
  projectId: Scalars['ID'];
  /** The ID of the repository to unlink from the project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnlinkProjectV2FromRepository */
export type Github_UnlinkProjectV2FromRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository the project is no longer linked to. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UnlinkProjectV2FromTeam */
export type Github_UnlinkProjectV2FromTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the project to unlink from the team. */
  projectId: Scalars['ID'];
  /** The ID of the team to unlink from the project. */
  teamId: Scalars['ID'];
};

/** Autogenerated return type of UnlinkProjectV2FromTeam */
export type Github_UnlinkProjectV2FromTeamPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The team the project is unlinked from */
  team?: Maybe<Github_Team>;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type Github_UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
export type Github_UnlinkRepositoryFromProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The linked Project. */
  project?: Maybe<Github_Project>;
  /** The linked Repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UnlockLockable */
export type Github_UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars['ID'];
};

/** Autogenerated return type of UnlockLockable */
export type Github_UnlockLockablePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<Github_Lockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type Github_UnlockedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object that was unlocked. */
  lockable: Github_Lockable;
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type Github_UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */
export type Github_UnmarkDiscussionCommentAsAnswerPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that includes the comment. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type Github_UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The path of the file to mark as unviewed */
  path: Scalars['String'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of UnmarkFileAsViewed */
export type Github_UnmarkFileAsViewedPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type Github_UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID'];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
export type Github_UnmarkIssueAsDuplicatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<Github_IssueOrPullRequest>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
export type Github_UnmarkedAsDuplicateEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<Github_IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<Github_IssueOrPullRequest>;
  id: Scalars['ID'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean'];
};

/** Autogenerated input type of UnminimizeComment */
export type Github_UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of UnminimizeComment */
export type Github_UnminimizeCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was unminimized. */
  unminimizedComment?: Maybe<Github_Minimizable>;
};

/** Autogenerated input type of UnpinIssue */
export type Github_UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of UnpinIssue */
export type Github_UnpinIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was unpinned */
  issue?: Maybe<Github_Issue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type Github_UnpinnedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: Github_Issue;
};

/** Autogenerated input type of UnresolveReviewThread */
export type Github_UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID'];
};

/** Autogenerated return type of UnresolveReviewThread */
export type Github_UnresolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The thread to resolve. */
  thread?: Maybe<Github_PullRequestReviewThread>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type Github_UnsubscribedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object referenced by event. */
  subscribable: Github_Subscribable;
};

/** Entities that can be updated. */
export type Github_Updatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};

/** Comments that can be updated. */
export type Github_UpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type Github_UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']>;
  /** Is branch creation a protected operation. */
  blocksCreations?: InputMaybe<Scalars['Boolean']>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID'];
  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']>;
  /**
   * Whether users can pull changes from upstream when the branch is locked. Set to
   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.
   */
  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']>;
  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */
  lockBranch?: InputMaybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: InputMaybe<Scalars['String']>;
  /** A list of User, Team, or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Whether the most recent push must be approved by someone other than the person who pushed it */
  requireLastPushApproval?: InputMaybe<Scalars['Boolean']>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<Github_RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']>;
  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule */
export type Github_UpdateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCheckRun */
export type Github_UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<Github_CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<Github_CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['Github_URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']>;
  /** The name of the check. */
  name?: InputMaybe<Scalars['String']>;
  /** Descriptive details about the run. */
  output?: InputMaybe<Github_CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']>;
  /** The current status. */
  status?: InputMaybe<Github_RequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun */
export type Github_UpdateCheckRunPayload = {
  /** The updated check run. */
  checkRun?: Maybe<Github_CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type Github_UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<Github_CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UpdateCheckSuitePreferences */
export type Github_UpdateCheckSuitePreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UpdateDiscussionComment */
export type Github_UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars['ID'];
};

/** Autogenerated return type of UpdateDiscussionComment */
export type Github_UpdateDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The modified discussion comment. */
  comment?: Maybe<Github_DiscussionComment>;
};

/** Autogenerated input type of UpdateDiscussion */
export type Github_UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: InputMaybe<Scalars['String']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars['ID'];
  /** The new discussion title. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateDiscussion */
export type Github_UpdateDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The modified discussion. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type Github_UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String'];
  /** The new role for the Enterprise administrator. */
  role: Github_EnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
export type Github_UpdateEnterpriseAdministratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the allow private repository forking policy on the enterprise. */
  policyValue?: InputMaybe<Github_EnterpriseAllowPrivateRepositoryForkingPolicyValue>;
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: Github_EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated base repository permission setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the base repository permission setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can change repository visibility setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can change repository visibility setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']>;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: InputMaybe<Github_EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: Github_EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type Github_UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
export type Github_UpdateEnterpriseOrganizationProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */
export type Github_UpdateEnterpriseOwnerOrganizationRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the owner belongs to. */
  enterpriseId: Scalars['ID'];
  /** The ID of the organization for membership change. */
  organizationId: Scalars['ID'];
  /** The role to assume in the organization. */
  organizationRole: Github_RoleInOrganization;
};

/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */
export type Github_UpdateEnterpriseOwnerOrganizationRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of changing the owner's organization role. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type Github_UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the enterprise. */
  description?: InputMaybe<Scalars['String']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID'];
  /** The location of the enterprise. */
  location?: InputMaybe<Scalars['String']>;
  /** The name of the enterprise. */
  name?: InputMaybe<Scalars['String']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateEnterpriseProfile */
export type Github_UpdateEnterpriseProfilePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type Github_UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
export type Github_UpdateEnterpriseRepositoryProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type Github_UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
export type Github_UpdateEnterpriseTeamDiscussionsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnvironment */
export type Github_UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the environment. */
  environmentId: Scalars['ID'];
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: InputMaybe<Array<Scalars['ID']>>;
  /** The wait timer in minutes. */
  waitTimer?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateEnvironment */
export type Github_UpdateEnvironmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated environment. */
  environment?: Maybe<Github_Environment>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type Github_UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list enabled setting. */
  settingValue: Github_IpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting */
export type Github_UpdateIpAllowListEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<Github_IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type Github_UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIpAllowListEntry */
export type Github_UpdateIpAllowListEntryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was updated. */
  ipAllowListEntry?: Maybe<Github_IpAllowListEntry>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the owner. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: Github_IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<Github_IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIssueComment */
export type Github_UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateIssueComment */
export type Github_UpdateIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  issueComment?: Maybe<Github_IssueComment>;
};

/** Autogenerated input type of UpdateIssue */
export type Github_UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The desired issue state. */
  state?: InputMaybe<Github_IssueState>;
  /** The title for the issue. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIssue */
export type Github_UpdateIssuePayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of UpdateLabel */
export type Github_UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: InputMaybe<Scalars['String']>;
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID'];
  /** The updated name of the label. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateLabel */
export type Github_UpdateLabelPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated label. */
  label?: Maybe<Github_Label>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type Github_UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars['ID'];
  /** The value for the restrict notifications setting. */
  settingValue: Github_NotificationRestrictionSettingValue;
};

/** Autogenerated return type of UpdateNotificationRestrictionSetting */
export type Github_UpdateNotificationRestrictionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The owner on which the setting was updated. */
  owner?: Maybe<Github_VerifiableDomainOwner>;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Enable forking of private repositories in the organization? */
  forkingEnabled: Scalars['Boolean'];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']>;
  /** The organization with the updated allow private repository forking setting. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */
export type Github_UpdateOrganizationWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization on which to set the web commit signoff setting. */
  organizationId: Scalars['ID'];
  /** Enable signoff on web-based commits for repositories in the organization? */
  webCommitSignoffRequired: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting */
export type Github_UpdateOrganizationWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars['String']>;
  /** The organization with the updated web commit signoff setting. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of UpdateProjectCard */
export type Github_UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: InputMaybe<Scalars['Boolean']>;
  /** The note of ProjectCard. */
  note?: InputMaybe<Scalars['String']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectCard */
export type Github_UpdateProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<Github_ProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
export type Github_UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of project column. */
  name: Scalars['String'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectColumn */
export type Github_UpdateProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated project column. */
  projectColumn?: Maybe<Github_ProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
export type Github_UpdateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of project. */
  name?: InputMaybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
  /** Whether the project is public or not. */
  public?: InputMaybe<Scalars['Boolean']>;
  /** Whether the project is open or closed. */
  state?: InputMaybe<Github_ProjectState>;
};

/** Autogenerated return type of UpdateProject */
export type Github_UpdateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated project. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of UpdateProjectV2DraftIssue */
export type Github_UpdateProjectV2DraftIssueInput = {
  /** The IDs of the assignees of the draft issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The body of the draft issue. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the draft issue to update. */
  draftIssueId: Scalars['ID'];
  /** The title of the draft issue. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateProjectV2DraftIssue */
export type Github_UpdateProjectV2DraftIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The draft issue updated in the project. */
  draftIssue?: Maybe<Github_DraftIssue>;
};

/** Autogenerated input type of UpdateProjectV2 */
export type Github_UpdateProjectV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Set the project to closed or open. */
  closed?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the Project to update. */
  projectId: Scalars['ID'];
  /** Set the project to public or private. */
  public?: InputMaybe<Scalars['Boolean']>;
  /** Set the readme description of the project. */
  readme?: InputMaybe<Scalars['String']>;
  /** Set the short description of the project. */
  shortDescription?: InputMaybe<Scalars['String']>;
  /** Set the title of the project. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateProjectV2ItemFieldValue */
export type Github_UpdateProjectV2ItemFieldValueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the field to be updated. */
  fieldId: Scalars['ID'];
  /** The ID of the item to be updated. */
  itemId: Scalars['ID'];
  /** The ID of the Project. */
  projectId: Scalars['ID'];
  /** The value which will be set on the field. */
  value: Github_ProjectV2FieldValue;
};

/** Autogenerated return type of UpdateProjectV2ItemFieldValue */
export type Github_UpdateProjectV2ItemFieldValuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated item. */
  projectV2Item?: Maybe<Github_ProjectV2Item>;
};

/** Autogenerated input type of UpdateProjectV2ItemPosition */
export type Github_UpdateProjectV2ItemPositionInput = {
  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */
  afterId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the item to be moved. */
  itemId: Scalars['ID'];
  /** The ID of the Project. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectV2ItemPosition */
export type Github_UpdateProjectV2ItemPositionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The items in the new order */
  items?: Maybe<Github_ProjectV2ItemConnection>;
};


/** Autogenerated return type of UpdateProjectV2ItemPosition */
export type Github_UpdateProjectV2ItemPositionPayloaditemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateProjectV2 */
export type Github_UpdateProjectV2Payload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated Project. */
  projectV2?: Maybe<Github_ProjectV2>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
export type Github_UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The head ref oid for the upstream branch. */
  expectedHeadOid?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestBranch */
export type Github_UpdatePullRequestBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of UpdatePullRequest */
export type Github_UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: InputMaybe<Scalars['String']>;
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
  /** The target state of the pull request. */
  state?: InputMaybe<Github_PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdatePullRequest */
export type Github_UpdatePullRequestPayload = {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type Github_UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type Github_UpdatePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<Github_PullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type Github_UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestReview */
export type Github_UpdatePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
export type Github_UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: InputMaybe<Scalars['Boolean']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['Github_GitObjectID'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRef */
export type Github_UpdateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated Ref. */
  ref?: Maybe<Github_Ref>;
};

/** Autogenerated input type of UpdateRefs */
export type Github_UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A list of ref updates. */
  refUpdates: Array<Github_RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRefs */
export type Github_UpdateRefsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateRepository */
export type Github_UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: InputMaybe<Scalars['String']>;
  /** Indicates if the repository should have the discussions feature enabled. */
  hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: InputMaybe<Scalars['Github_URI']>;
  /** The new name of the repository. */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateRepository */
export type Github_UpdateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */
export type Github_UpdateRepositoryWebCommitSignoffSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID'];
  /** Indicates if the repository should require signoff on web-based commits. */
  webCommitSignoffRequired: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting */
export type Github_UpdateRepositoryWebCommitSignoffSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of updating the web commit signoff setting. */
  message?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type Github_UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<Github_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateSponsorshipPreferences */
export type Github_UpdateSponsorshipPreferencesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The sponsorship that was updated. */
  sponsorship?: Maybe<Github_Sponsorship>;
};

/** Autogenerated input type of UpdateSubscription */
export type Github_UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The new state of the subscription. */
  state: Github_SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID'];
};

/** Autogenerated return type of UpdateSubscription */
export type Github_UpdateSubscriptionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The input subscribable entity. */
  subscribable?: Maybe<Github_Subscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type Github_UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
export type Github_UpdateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  teamDiscussionComment?: Maybe<Github_TeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type Github_UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: InputMaybe<Scalars['String']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: InputMaybe<Scalars['Boolean']>;
  /** The updated title of the discussion. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateTeamDiscussion */
export type Github_UpdateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated discussion. */
  teamDiscussion?: Maybe<Github_TeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type Github_UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: InputMaybe<Github_TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars['ID'];
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: InputMaybe<Scalars['Boolean']>;
  /** The number of team members to assign */
  teamMemberCount?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment */
export type Github_UpdateTeamReviewAssignmentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The team that was modified */
  team?: Maybe<Github_Team>;
};

/** Autogenerated input type of UpdateTeamsRepository */
export type Github_UpdateTeamsRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Permission that should be granted to the teams. */
  permission: Github_RepositoryPermission;
  /** Repository ID being granted access to. */
  repositoryId: Scalars['ID'];
  /** A list of teams being granted access. Limit: 10 */
  teamIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of UpdateTeamsRepository */
export type Github_UpdateTeamsRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was updated. */
  repository?: Maybe<Github_Repository>;
  /** The teams granted permission on the repository. */
  teams?: Maybe<Array<Github_Team>>;
};

/** Autogenerated input type of UpdateTopics */
export type Github_UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']>;
};

/** Autogenerated return type of UpdateTopics */
export type Github_UpdateTopicsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars['String']>>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_User = Github_Actor & Github_Node & Github_PackageOwner & Github_ProfileOwner & Github_ProjectOwner & Github_ProjectV2Owner & Github_ProjectV2Recent & Github_RepositoryDiscussionAuthor & Github_RepositoryDiscussionCommentAuthor & Github_RepositoryOwner & Github_Sponsorable & Github_UniformResourceLocatable & {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** A URL pointing to the user's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The user's public profile bio. */
  bio?: Maybe<Scalars['String']>;
  /** The user's public profile bio as HTML. */
  bioHTML: Scalars['Github_HTML'];
  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */
  canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean'];
  /** A list of commit comments made by this user. */
  commitComments: Github_CommitCommentConnection;
  /** The user's public profile company. */
  company?: Maybe<Scalars['String']>;
  /** The user's public profile company as HTML. */
  companyHTML: Scalars['Github_HTML'];
  /** The collection of contributions this user has made to different repositories. */
  contributionsCollection: Github_ContributionsCollection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The user's publicly visible profile email. */
  email: Scalars['String'];
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** A list of users the given user is followed by. */
  followers: Github_FollowerConnection;
  /** A list of users the given user is following. */
  following: Github_FollowingConnection;
  /** Find gist by repo name. */
  gist?: Maybe<Github_Gist>;
  /** A list of gist comments made by this user. */
  gistComments: Github_GistCommentConnection;
  /** A list of the Gists the user has created. */
  gists: Github_GistConnection;
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  /** The hovercard information for this user in a given context */
  hovercard: Github_Hovercard;
  id: Scalars['ID'];
  /** The interaction ability settings for this user. */
  interactionAbility?: Maybe<Github_RepositoryInteractionAbility>;
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: Scalars['Boolean'];
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: Scalars['Boolean'];
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: Scalars['Boolean'];
  /** Whether or not this user is a GitHub employee. */
  isEmployee: Scalars['Boolean'];
  /** Whether or not this user is following the viewer. Inverse of viewer_is_following */
  isFollowingViewer: Scalars['Boolean'];
  /** Whether or not this user is a member of the GitHub Stars Program. */
  isGitHubStar: Scalars['Boolean'];
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: Scalars['Boolean'];
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: Scalars['Boolean'];
  /** Whether the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** Whether or not this user is the viewing user. */
  isViewer: Scalars['Boolean'];
  /** A list of issue comments made by this user. */
  issueComments: Github_IssueCommentConnection;
  /** A list of issues associated with this user. */
  issues: Github_IssueConnection;
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The user's public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** The user's public profile name. */
  name?: Maybe<Scalars['String']>;
  /** Find an organization by its login that the user belongs to. */
  organization?: Maybe<Github_Organization>;
  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
  organizationVerifiedDomainEmails: Array<Scalars['String']>;
  /** A list of organizations the user belongs to. */
  organizations: Github_OrganizationConnection;
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** Find a project by number. */
  projectV2?: Maybe<Github_ProjectV2>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing user's projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing user's projects */
  projectsUrl: Scalars['Github_URI'];
  /** A list of projects under the owner. */
  projectsV2: Github_ProjectV2Connection;
  /** A list of public keys associated with this user. */
  publicKeys: Github_PublicKeyConnection;
  /** A list of pull requests associated with this user. */
  pullRequests: Github_PullRequestConnection;
  /** Recent projects that this user has modified in the context of the owner. */
  recentProjects: Github_ProjectV2Connection;
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
  /** The HTTP path for this user */
  resourcePath: Scalars['Github_URI'];
  /** Replies this user has saved */
  savedReplies?: Maybe<Github_SavedReplyConnection>;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** The sponsorships where this user or organization is the maintainer receiving the funds. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** The sponsorships where this user or organization is the funder. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /** Repositories the user has starred. */
  starredRepositories: Github_StarredRepositoryConnection;
  /** The user's description of what they're currently doing. */
  status?: Maybe<Github_UserStatus>;
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  topRepositories: Github_RepositoryConnection;
  /**
   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has
   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the
   * user themselves or by a user who can manage sponsorships for the requested organization.
   */
  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']>;
  /** The user's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this user */
  url: Scalars['Github_URI'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: Scalars['Boolean'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** Whether or not this user is followed by the viewer. Inverse of is_following_viewer. */
  viewerIsFollowing: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
  /** A list of repositories the given user is watching. */
  watching: Github_RepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UseranyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UseravatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsercanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsercommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsercontributionsCollectionArgs = {
  from?: InputMaybe<Scalars['DateTime']>;
  organizationID?: InputMaybe<Scalars['ID']>;
  to?: InputMaybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserfollowersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserfollowingArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsergistArgs = {
  name: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsergistCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsergistsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_GistOrder>;
  privacy?: InputMaybe<Github_GistPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserhovercardArgs = {
  primarySubjectId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserisSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserissueCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueCommentOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserissuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserorganizationArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserorganizationVerifiedDomainEmailsArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserorganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserpackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserpinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserpinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserprojectArgs = {
  number: Scalars['Int'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserprojectV2Args = {
  number: Scalars['Int'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserprojectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserprojectsV2Args = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectV2Order>;
  query?: InputMaybe<Scalars['String']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserpublicKeysArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserpullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserrecentProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserrepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserrepositoriesContributedToArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  contributionTypes?: InputMaybe<Array<InputMaybe<Github_RepositoryContributionType>>>;
  first?: InputMaybe<Scalars['Int']>;
  includeUserRepositories?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserrepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserrepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SavedReplyOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorsActivitiesArgs = {
  actions?: InputMaybe<Array<Github_SponsorsActivityAction>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAsSponsor?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
  since?: InputMaybe<Scalars['DateTime']>;
  until?: InputMaybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorshipForViewerAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorshipForViewerAsSponsorableArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorshipsAsMaintainerArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsersponsorshipsAsSponsorArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  maintainerLogins?: InputMaybe<Array<Scalars['String']>>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserstarredRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
  ownedByViewer?: InputMaybe<Scalars['Boolean']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsertopRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy: Github_RepositoryOrder;
  since?: InputMaybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UsertotalSponsorshipAmountAsSponsorInCentsArgs = {
  since?: InputMaybe<Scalars['DateTime']>;
  sponsorableLogins?: InputMaybe<Array<Scalars['String']>>;
  until?: InputMaybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserwatchingArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};

/** The possible durations that a user can be blocked for. */
export type Github_UserBlockDuration =
  /** The user was blocked for 1 day */
  | 'ONE_DAY'
  /** The user was blocked for 30 days */
  | 'ONE_MONTH'
  /** The user was blocked for 7 days */
  | 'ONE_WEEK'
  /** The user was blocked permanently */
  | 'PERMANENT'
  /** The user was blocked for 3 days */
  | 'THREE_DAYS';

/** Represents a 'user_blocked' event on a given user. */
export type Github_UserBlockedEvent = Github_Node & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Number of days that the user was blocked for. */
  blockDuration: Github_UserBlockDuration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The user who was blocked. */
  subject?: Maybe<Github_User>;
};

/** The connection type for User. */
export type Github_UserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edit on user content */
export type Github_UserContentEdit = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars['DateTime']>;
  /** The actor who deleted this content */
  deletedBy?: Maybe<Github_Actor>;
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars['String']>;
  /** When this content was edited */
  editedAt: Scalars['DateTime'];
  /** The actor who edited this content */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** A list of edits to content. */
export type Github_UserContentEditConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserContentEditEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_UserContentEdit>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_UserContentEditEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_UserContentEdit>;
};

/** Represents a user. */
export type Github_UserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
};

/** Email attributes from External Identity */
export type Github_UserEmailMetadata = {
  /** Boolean to identify primary emails */
  primary?: Maybe<Scalars['Boolean']>;
  /** Type of email */
  type?: Maybe<Scalars['String']>;
  /** Email id */
  value: Scalars['String'];
};

/** The user's description of what they're currently doing. */
export type Github_UserStatus = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars['String']>;
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars['Github_HTML']>;
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars['Boolean'];
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars['String']>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<Github_Organization>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user who has this status. */
  user: Github_User;
};

/** The connection type for UserStatus. */
export type Github_UserStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_UserStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_UserStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_UserStatus>;
};

/** Ordering options for user status connections. */
export type Github_UserStatusOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order user statuses by. */
  field: Github_UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export type Github_UserStatusOrderField =
  /** Order user statuses by when they were updated. */
  | 'UPDATED_AT';

/** A domain that can be verified or approved for an organization or an enterprise. */
export type Github_VerifiableDomain = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The DNS host name that should be used for verification. */
  dnsHostName?: Maybe<Scalars['Github_URI']>;
  /** The unicode encoded domain. */
  domain: Scalars['Github_URI'];
  /** Whether a TXT record for verification with the expected host name was found. */
  hasFoundHostName: Scalars['Boolean'];
  /** Whether a TXT record for verification with the expected verification token was found. */
  hasFoundVerificationToken: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Whether or not the domain is approved. */
  isApproved: Scalars['Boolean'];
  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */
  isRequiredForPolicyEnforcement: Scalars['Boolean'];
  /** Whether or not the domain is verified. */
  isVerified: Scalars['Boolean'];
  /** The owner of the domain. */
  owner: Github_VerifiableDomainOwner;
  /** The punycode encoded domain. */
  punycodeEncodedDomain: Scalars['Github_URI'];
  /** The time that the current verification token will expire. */
  tokenExpirationTime?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The current verification token for the domain. */
  verificationToken?: Maybe<Scalars['String']>;
};

/** The connection type for VerifiableDomain. */
export type Github_VerifiableDomainConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_VerifiableDomainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_VerifiableDomain>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_VerifiableDomainEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_VerifiableDomain>;
};

/** Ordering options for verifiable domain connections. */
export type Github_VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order verifiable domains by. */
  field: Github_VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export type Github_VerifiableDomainOrderField =
  /** Order verifiable domains by their creation date. */
  | 'CREATED_AT'
  /** Order verifiable domains by the domain name. */
  | 'DOMAIN';

/** Types that can own a verifiable domain. */
export type Github_VerifiableDomainOwner = Github_Enterprise | Github_Organization;

/** Autogenerated input type of VerifyVerifiableDomain */
export type Github_VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of VerifyVerifiableDomain */
export type Github_VerifyVerifiableDomainPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verifiable domain that was verified. */
  domain?: Maybe<Github_VerifiableDomain>;
};

/** A hovercard context with a message describing how the viewer is related. */
export type Github_ViewerHovercardContext = Github_HovercardContext & {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Identifies the user who is related to this context. */
  viewer: Github_User;
};

/** A subject that may be upvoted. */
export type Github_Votable = {
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
};

/** A workflow contains meta information about an Actions workflow file. */
export type Github_Workflow = Github_Node & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The name of the workflow. */
  name: Scalars['String'];
  /** The runs of the workflow. */
  runs: Github_WorkflowRunConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** A workflow contains meta information about an Actions workflow file. */
export type Github_WorkflowrunsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_WorkflowRunOrder>;
};

/** A workflow run. */
export type Github_WorkflowRun = Github_Node & Github_UniformResourceLocatable & {
  /** The check suite this workflow run belongs to. */
  checkSuite: Github_CheckSuite;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The log of deployment reviews */
  deploymentReviews: Github_DeploymentReviewConnection;
  id: Scalars['ID'];
  /** The pending deployment requests of all check runs in this workflow run */
  pendingDeploymentRequests: Github_DeploymentRequestConnection;
  /** The HTTP path for this workflow run */
  resourcePath: Scalars['Github_URI'];
  /** A number that uniquely identifies this workflow run in its parent workflow. */
  runNumber: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this workflow run */
  url: Scalars['Github_URI'];
  /** The workflow executed in this workflow run. */
  workflow: Github_Workflow;
};


/** A workflow run. */
export type Github_WorkflowRundeploymentReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A workflow run. */
export type Github_WorkflowRunpendingDeploymentRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for WorkflowRun. */
export type Github_WorkflowRunConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_WorkflowRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_WorkflowRun>>>;
  /** Information to aid in pagination. */
  pageInfo: Github_PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_WorkflowRunEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_WorkflowRun>;
};

/** Ways in which lists of workflow runs can be ordered upon return. */
export type Github_WorkflowRunOrder = {
  /** The direction in which to order workflow runs by the specified field. */
  direction: Github_OrderDirection;
  /** The field by which to order workflows. */
  field: Github_WorkflowRunOrderField;
};

/** Properties by which workflow run connections can be ordered. */
export type Github_WorkflowRunOrderField =
  /** Order workflow runs by most recently created */
  | 'CREATED_AT';

export type github_1Query = {
  /** Look up a code of conduct by its key */
  codeOfConduct?: Maybe<Github_CodeOfConduct>;
  /** Look up a code of conduct by its key */
  codesOfConduct?: Maybe<Array<Maybe<Github_CodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  enterprise?: Maybe<Github_Enterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  enterpriseAdministratorInvitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  enterpriseAdministratorInvitationByToken?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** Look up an open source license by its key */
  license?: Maybe<Github_License>;
  /** Return a list of known open source licenses */
  licenses: Array<Maybe<Github_License>>;
  /** Get alphabetically sorted list of Marketplace categories */
  marketplaceCategories: Array<Github_MarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  marketplaceCategory?: Maybe<Github_MarketplaceCategory>;
  /** Look up a single Marketplace listing */
  marketplaceListing?: Maybe<Github_MarketplaceListing>;
  /** Look up Marketplace listings */
  marketplaceListings: Github_MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  meta: Github_GitHubMetadata;
  /** Fetches an object given its ID. */
  node?: Maybe<Github_Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Github_Node>>;
  /** Lookup a organization by login. */
  organization?: Maybe<Github_Organization>;
  /** The client's rate limit information. */
  rateLimit?: Maybe<Github_RateLimit>;
  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
  relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  repository?: Maybe<Github_Repository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  repositoryOwner?: Maybe<Github_RepositoryOwner>;
  /** Lookup resource by a URL. */
  resource?: Maybe<Github_UniformResourceLocatable>;
  /** Perform a search across resources, returning a maximum of 1,000 results. */
  search: Github_SearchResultItemConnection;
  /** GitHub Security Advisories */
  securityAdvisories: Github_SecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  securityAdvisory?: Maybe<Github_SecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  securityVulnerabilities: Github_SecurityVulnerabilityConnection;
  /** Users and organizations who can be sponsored via GitHub Sponsors. */
  sponsorables: Github_SponsorableItemConnection;
  /** Look up a topic by name. */
  topic?: Maybe<Github_Topic>;
  /** Lookup a user by login. */
  user?: Maybe<Github_User>;
  /** The currently authenticated user. */
  viewer: Github_User;
};


export type github_1QuerycodeOfConductArgs = {
  key: Scalars['String'];
};


export type github_1QueryenterpriseArgs = {
  invitationToken?: InputMaybe<Scalars['String']>;
  slug: Scalars['String'];
};


export type github_1QueryenterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars['String'];
  role: Github_EnterpriseAdministratorRole;
  userLogin: Scalars['String'];
};


export type github_1QueryenterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars['String'];
};


export type github_1QuerylicenseArgs = {
  key: Scalars['String'];
};


export type github_1QuerymarketplaceCategoriesArgs = {
  excludeEmpty?: InputMaybe<Scalars['Boolean']>;
  excludeSubcategories?: InputMaybe<Scalars['Boolean']>;
  includeCategories?: InputMaybe<Array<Scalars['String']>>;
};


export type github_1QuerymarketplaceCategoryArgs = {
  slug: Scalars['String'];
  useTopicAliases?: InputMaybe<Scalars['Boolean']>;
};


export type github_1QuerymarketplaceListingArgs = {
  slug: Scalars['String'];
};


export type github_1QuerymarketplaceListingsArgs = {
  adminId?: InputMaybe<Scalars['ID']>;
  after?: InputMaybe<Scalars['String']>;
  allStates?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  categorySlug?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  organizationId?: InputMaybe<Scalars['ID']>;
  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']>;
  slugs?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  useTopicAliases?: InputMaybe<Scalars['Boolean']>;
  viewerCanAdmin?: InputMaybe<Scalars['Boolean']>;
  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']>;
};


export type github_1QuerynodeArgs = {
  id: Scalars['ID'];
};


export type github_1QuerynodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type github_1QueryorganizationArgs = {
  login: Scalars['String'];
};


export type github_1QueryrateLimitArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']>;
};


export type github_1QueryrepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
  owner: Scalars['String'];
};


export type github_1QueryrepositoryOwnerArgs = {
  login: Scalars['String'];
};


export type github_1QueryresourceArgs = {
  url: Scalars['Github_URI'];
};


export type github_1QuerysearchArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query: Scalars['String'];
  type: Github_SearchType;
};


export type github_1QuerysecurityAdvisoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  classifications?: InputMaybe<Array<Github_SecurityAdvisoryClassification>>;
  first?: InputMaybe<Scalars['Int']>;
  identifier?: InputMaybe<Github_SecurityAdvisoryIdentifierFilter>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SecurityAdvisoryOrder>;
  publishedSince?: InputMaybe<Scalars['DateTime']>;
  updatedSince?: InputMaybe<Scalars['DateTime']>;
};


export type github_1QuerysecurityAdvisoryArgs = {
  ghsaId: Scalars['String'];
};


export type github_1QuerysecurityVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  classifications?: InputMaybe<Array<Github_SecurityAdvisoryClassification>>;
  ecosystem?: InputMaybe<Github_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']>;
  severities?: InputMaybe<Array<Github_SecurityAdvisorySeverity>>;
};


export type github_1QuerysponsorablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  dependencyEcosystem?: InputMaybe<Github_SecurityAdvisoryEcosystem>;
  ecosystem?: InputMaybe<Github_DependencyGraphEcosystem>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyDependencies?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<Github_SponsorableOrder>;
  orgLoginForDependencies?: InputMaybe<Scalars['String']>;
};


export type github_1QuerytopicArgs = {
  name: Scalars['String'];
};


export type github_1QueryuserArgs = {
  login: Scalars['String'];
};

export type github_1Mutation = {
  /** Clear all of a customer's queued migrations */
  abortQueuedMigrations?: Maybe<Github_AbortQueuedMigrationsPayload>;
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  acceptEnterpriseAdministratorInvitation?: Maybe<Github_AcceptEnterpriseAdministratorInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  acceptTopicSuggestion?: Maybe<Github_AcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  addAssigneesToAssignable?: Maybe<Github_AddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  addComment?: Maybe<Github_AddCommentPayload>;
  /** Adds a comment to a Discussion, possibly as a reply to another comment. */
  addDiscussionComment?: Maybe<Github_AddDiscussionCommentPayload>;
  /** Vote for an option in a discussion poll. */
  addDiscussionPollVote?: Maybe<Github_AddDiscussionPollVotePayload>;
  /** Adds enterprise members to an organization within the enterprise. */
  addEnterpriseOrganizationMember?: Maybe<Github_AddEnterpriseOrganizationMemberPayload>;
  /** Adds a support entitlement to an enterprise member. */
  addEnterpriseSupportEntitlement?: Maybe<Github_AddEnterpriseSupportEntitlementPayload>;
  /** Adds labels to a labelable object. */
  addLabelsToLabelable?: Maybe<Github_AddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  addProjectCard?: Maybe<Github_AddProjectCardPayload>;
  /** Adds a column to a Project. */
  addProjectColumn?: Maybe<Github_AddProjectColumnPayload>;
  /** Creates a new draft issue and add it to a Project. */
  addProjectV2DraftIssue?: Maybe<Github_AddProjectV2DraftIssuePayload>;
  /** Links an existing content instance to a Project. */
  addProjectV2ItemById?: Maybe<Github_AddProjectV2ItemByIdPayload>;
  /** Adds a review to a Pull Request. */
  addPullRequestReview?: Maybe<Github_AddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  addPullRequestReviewComment?: Maybe<Github_AddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  addPullRequestReviewThread?: Maybe<Github_AddPullRequestReviewThreadPayload>;
  /** Adds a reaction to a subject. */
  addReaction?: Maybe<Github_AddReactionPayload>;
  /** Adds a star to a Starrable. */
  addStar?: Maybe<Github_AddStarPayload>;
  /** Add an upvote to a discussion or discussion comment. */
  addUpvote?: Maybe<Github_AddUpvotePayload>;
  /** Adds a verifiable domain to an owning account. */
  addVerifiableDomain?: Maybe<Github_AddVerifiableDomainPayload>;
  /** Approve all pending deployments under one or more environments */
  approveDeployments?: Maybe<Github_ApproveDeploymentsPayload>;
  /** Approve a verifiable domain for notification delivery. */
  approveVerifiableDomain?: Maybe<Github_ApproveVerifiableDomainPayload>;
  /** Archives a ProjectV2Item */
  archiveProjectV2Item?: Maybe<Github_ArchiveProjectV2ItemPayload>;
  /** Marks a repository as archived. */
  archiveRepository?: Maybe<Github_ArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  cancelEnterpriseAdminInvitation?: Maybe<Github_CancelEnterpriseAdminInvitationPayload>;
  /** Cancel an active sponsorship. */
  cancelSponsorship?: Maybe<Github_CancelSponsorshipPayload>;
  /** Update your status on GitHub. */
  changeUserStatus?: Maybe<Github_ChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  clearLabelsFromLabelable?: Maybe<Github_ClearLabelsFromLabelablePayload>;
  /**
   * This mutation clears the value of a field for an item in a Project. Currently
   * only text, number, date, assignees, labels, single-select, iteration and
   * milestone fields are supported.
   */
  clearProjectV2ItemFieldValue?: Maybe<Github_ClearProjectV2ItemFieldValuePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  cloneProject?: Maybe<Github_CloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  cloneTemplateRepository?: Maybe<Github_CloneTemplateRepositoryPayload>;
  /** Close an issue. */
  closeIssue?: Maybe<Github_CloseIssuePayload>;
  /** Close a pull request. */
  closePullRequest?: Maybe<Github_ClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  convertProjectCardNoteToIssue?: Maybe<Github_ConvertProjectCardNoteToIssuePayload>;
  /** Converts a pull request to draft */
  convertPullRequestToDraft?: Maybe<Github_ConvertPullRequestToDraftPayload>;
  /** Copy a project. */
  copyProjectV2?: Maybe<Github_CopyProjectV2Payload>;
  /** Invites a user to claim reattributable data */
  createAttributionInvitation?: Maybe<Github_CreateAttributionInvitationPayload>;
  /** Create a new branch protection rule */
  createBranchProtectionRule?: Maybe<Github_CreateBranchProtectionRulePayload>;
  /** Create a check run. */
  createCheckRun?: Maybe<Github_CreateCheckRunPayload>;
  /** Create a check suite */
  createCheckSuite?: Maybe<Github_CreateCheckSuitePayload>;
  /**
   * Appends a commit to the given branch as the authenticated user.
   *
   * This mutation creates a commit whose parent is the HEAD of the provided
   * branch and also updates that branch to point to the new commit.
   * It can be thought of as similar to `git commit`.
   *
   * ### Locating a Branch
   *
   * Commits are appended to a `branch` of type `Ref`.
   * This must refer to a git branch (i.e.  the fully qualified path must
   * begin with `refs/heads/`, although including this prefix is optional.
   *
   * Callers may specify the `branch` to commit to either by its global node
   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For
   * more details see the documentation for `CommittableBranch`.
   *
   * ### Describing Changes
   *
   * `fileChanges` are specified as a `FilesChanges` object describing
   * `FileAdditions` and `FileDeletions`.
   *
   * Please see the documentation for `FileChanges` for more information on
   * how to use this argument to describe any set of file changes.
   *
   * ### Authorship
   *
   * Similar to the web commit interface, this mutation does not support
   * specifying the author or committer of the commit and will not add
   * support for this in the future.
   *
   * A commit created by a successful execution of this mutation will be
   * authored by the owner of the credential which authenticates the API
   * request.  The committer will be identical to that of commits authored
   * using the web interface.
   *
   * If you need full control over author and committer information, please
   * use the Git Database REST API instead.
   *
   * ### Commit Signing
   *
   * Commits made using this mutation are automatically signed by GitHub if
   * supported and will be marked as verified in the user interface.
   */
  createCommitOnBranch?: Maybe<Github_CreateCommitOnBranchPayload>;
  /** Creates a new deployment event. */
  createDeployment?: Maybe<Github_CreateDeploymentPayload>;
  /** Create a deployment status. */
  createDeploymentStatus?: Maybe<Github_CreateDeploymentStatusPayload>;
  /** Create a discussion. */
  createDiscussion?: Maybe<Github_CreateDiscussionPayload>;
  /** Creates an organization as part of an enterprise account. */
  createEnterpriseOrganization?: Maybe<Github_CreateEnterpriseOrganizationPayload>;
  /** Creates an environment or simply returns it if already exists. */
  createEnvironment?: Maybe<Github_CreateEnvironmentPayload>;
  /** Creates a new IP allow list entry. */
  createIpAllowListEntry?: Maybe<Github_CreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  createIssue?: Maybe<Github_CreateIssuePayload>;
  /** Creates a new label. */
  createLabel?: Maybe<Github_CreateLabelPayload>;
  /** Create a branch linked to an issue. */
  createLinkedBranch?: Maybe<Github_CreateLinkedBranchPayload>;
  /** Creates a GitHub Enterprise Importer (GEI) migration source. */
  createMigrationSource?: Maybe<Github_CreateMigrationSourcePayload>;
  /** Creates a new project. */
  createProject?: Maybe<Github_CreateProjectPayload>;
  /** Creates a new project. */
  createProjectV2?: Maybe<Github_CreateProjectV2Payload>;
  /** Create a new pull request */
  createPullRequest?: Maybe<Github_CreatePullRequestPayload>;
  /** Create a new Git Ref. */
  createRef?: Maybe<Github_CreateRefPayload>;
  /** Create a new repository. */
  createRepository?: Maybe<Github_CreateRepositoryPayload>;
  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */
  createSponsorsListing?: Maybe<Github_CreateSponsorsListingPayload>;
  /** Create a new payment tier for your GitHub Sponsors profile. */
  createSponsorsTier?: Maybe<Github_CreateSponsorsTierPayload>;
  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */
  createSponsorship?: Maybe<Github_CreateSponsorshipPayload>;
  /** Creates a new team discussion. */
  createTeamDiscussion?: Maybe<Github_CreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  createTeamDiscussionComment?: Maybe<Github_CreateTeamDiscussionCommentPayload>;
  /** Rejects a suggested topic for the repository. */
  declineTopicSuggestion?: Maybe<Github_DeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  deleteBranchProtectionRule?: Maybe<Github_DeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  deleteDeployment?: Maybe<Github_DeleteDeploymentPayload>;
  /** Delete a discussion and all of its replies. */
  deleteDiscussion?: Maybe<Github_DeleteDiscussionPayload>;
  /** Delete a discussion comment. If it has replies, wipe it instead. */
  deleteDiscussionComment?: Maybe<Github_DeleteDiscussionCommentPayload>;
  /** Deletes an environment */
  deleteEnvironment?: Maybe<Github_DeleteEnvironmentPayload>;
  /** Deletes an IP allow list entry. */
  deleteIpAllowListEntry?: Maybe<Github_DeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  deleteIssue?: Maybe<Github_DeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  deleteIssueComment?: Maybe<Github_DeleteIssueCommentPayload>;
  /** Deletes a label. */
  deleteLabel?: Maybe<Github_DeleteLabelPayload>;
  /** Unlink a branch from an issue. */
  deleteLinkedBranch?: Maybe<Github_DeleteLinkedBranchPayload>;
  /** Delete a package version. */
  deletePackageVersion?: Maybe<Github_DeletePackageVersionPayload>;
  /** Deletes a project. */
  deleteProject?: Maybe<Github_DeleteProjectPayload>;
  /** Deletes a project card. */
  deleteProjectCard?: Maybe<Github_DeleteProjectCardPayload>;
  /** Deletes a project column. */
  deleteProjectColumn?: Maybe<Github_DeleteProjectColumnPayload>;
  /** Delete a project. */
  deleteProjectV2?: Maybe<Github_DeleteProjectV2Payload>;
  /** Deletes an item from a Project. */
  deleteProjectV2Item?: Maybe<Github_DeleteProjectV2ItemPayload>;
  /** Deletes a pull request review. */
  deletePullRequestReview?: Maybe<Github_DeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  deletePullRequestReviewComment?: Maybe<Github_DeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  deleteRef?: Maybe<Github_DeleteRefPayload>;
  /** Deletes a team discussion. */
  deleteTeamDiscussion?: Maybe<Github_DeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  deleteTeamDiscussionComment?: Maybe<Github_DeleteTeamDiscussionCommentPayload>;
  /** Deletes a verifiable domain. */
  deleteVerifiableDomain?: Maybe<Github_DeleteVerifiableDomainPayload>;
  /** Disable auto merge on the given pull request */
  disablePullRequestAutoMerge?: Maybe<Github_DisablePullRequestAutoMergePayload>;
  /** Dismisses an approved or rejected pull request review. */
  dismissPullRequestReview?: Maybe<Github_DismissPullRequestReviewPayload>;
  /** Dismisses the Dependabot alert. */
  dismissRepositoryVulnerabilityAlert?: Maybe<Github_DismissRepositoryVulnerabilityAlertPayload>;
  /** Enable the default auto-merge on a pull request. */
  enablePullRequestAutoMerge?: Maybe<Github_EnablePullRequestAutoMergePayload>;
  /** Follow an organization. */
  followOrganization?: Maybe<Github_FollowOrganizationPayload>;
  /** Follow a user. */
  followUser?: Maybe<Github_FollowUserPayload>;
  /** Grant the migrator role to a user for all organizations under an enterprise account. */
  grantEnterpriseOrganizationsMigratorRole?: Maybe<Github_GrantEnterpriseOrganizationsMigratorRolePayload>;
  /** Grant the migrator role to a user or a team. */
  grantMigratorRole?: Maybe<Github_GrantMigratorRolePayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  importProject?: Maybe<Github_ImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  inviteEnterpriseAdmin?: Maybe<Github_InviteEnterpriseAdminPayload>;
  /** Links a project to a repository. */
  linkProjectV2ToRepository?: Maybe<Github_LinkProjectV2ToRepositoryPayload>;
  /** Links a project to a team. */
  linkProjectV2ToTeam?: Maybe<Github_LinkProjectV2ToTeamPayload>;
  /** Creates a repository link for a project. */
  linkRepositoryToProject?: Maybe<Github_LinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  lockLockable?: Maybe<Github_LockLockablePayload>;
  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */
  markDiscussionCommentAsAnswer?: Maybe<Github_MarkDiscussionCommentAsAnswerPayload>;
  /** Mark a pull request file as viewed */
  markFileAsViewed?: Maybe<Github_MarkFileAsViewedPayload>;
  /** Marks a pull request ready for review. */
  markPullRequestReadyForReview?: Maybe<Github_MarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  mergeBranch?: Maybe<Github_MergeBranchPayload>;
  /** Merge a pull request. */
  mergePullRequest?: Maybe<Github_MergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  minimizeComment?: Maybe<Github_MinimizeCommentPayload>;
  /** Moves a project card to another place. */
  moveProjectCard?: Maybe<Github_MoveProjectCardPayload>;
  /** Moves a project column to another place. */
  moveProjectColumn?: Maybe<Github_MoveProjectColumnPayload>;
  /** Pin an issue to a repository */
  pinIssue?: Maybe<Github_PinIssuePayload>;
  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */
  publishSponsorsTier?: Maybe<Github_PublishSponsorsTierPayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Regenerates a verifiable domain's verification token. */
  regenerateVerifiableDomainToken?: Maybe<Github_RegenerateVerifiableDomainTokenPayload>;
  /** Reject all pending deployments under one or more environments */
  rejectDeployments?: Maybe<Github_RejectDeploymentsPayload>;
  /** Removes assignees from an assignable object. */
  removeAssigneesFromAssignable?: Maybe<Github_RemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  removeEnterpriseAdmin?: Maybe<Github_RemoveEnterpriseAdminPayload>;
  /** Removes the identity provider from an enterprise */
  removeEnterpriseIdentityProvider?: Maybe<Github_RemoveEnterpriseIdentityProviderPayload>;
  /** Removes a user from all organizations within the enterprise */
  removeEnterpriseMember?: Maybe<Github_RemoveEnterpriseMemberPayload>;
  /** Removes an organization from the enterprise */
  removeEnterpriseOrganization?: Maybe<Github_RemoveEnterpriseOrganizationPayload>;
  /** Removes a support entitlement from an enterprise member. */
  removeEnterpriseSupportEntitlement?: Maybe<Github_RemoveEnterpriseSupportEntitlementPayload>;
  /** Removes labels from a Labelable object. */
  removeLabelsFromLabelable?: Maybe<Github_RemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  removeOutsideCollaborator?: Maybe<Github_RemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  removeReaction?: Maybe<Github_RemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  removeStar?: Maybe<Github_RemoveStarPayload>;
  /** Remove an upvote to a discussion or discussion comment. */
  removeUpvote?: Maybe<Github_RemoveUpvotePayload>;
  /** Reopen a issue. */
  reopenIssue?: Maybe<Github_ReopenIssuePayload>;
  /** Reopen a pull request. */
  reopenPullRequest?: Maybe<Github_ReopenPullRequestPayload>;
  /** Set review requests on a pull request. */
  requestReviews?: Maybe<Github_RequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  rerequestCheckSuite?: Maybe<Github_RerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  resolveReviewThread?: Maybe<Github_ResolveReviewThreadPayload>;
  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */
  retireSponsorsTier?: Maybe<Github_RetireSponsorsTierPayload>;
  /** Create a pull request that reverts the changes from a merged pull request. */
  revertPullRequest?: Maybe<Github_RevertPullRequestPayload>;
  /** Revoke the migrator role to a user for all organizations under an enterprise account. */
  revokeEnterpriseOrganizationsMigratorRole?: Maybe<Github_RevokeEnterpriseOrganizationsMigratorRolePayload>;
  /** Revoke the migrator role from a user or a team. */
  revokeMigratorRole?: Maybe<Github_RevokeMigratorRolePayload>;
  /** Creates or updates the identity provider for an enterprise. */
  setEnterpriseIdentityProvider?: Maybe<Github_SetEnterpriseIdentityProviderPayload>;
  /** Set an organization level interaction limit for an organization's public repositories. */
  setOrganizationInteractionLimit?: Maybe<Github_SetOrganizationInteractionLimitPayload>;
  /** Sets an interaction limit setting for a repository. */
  setRepositoryInteractionLimit?: Maybe<Github_SetRepositoryInteractionLimitPayload>;
  /** Set a user level interaction limit for an user's public repositories. */
  setUserInteractionLimit?: Maybe<Github_SetUserInteractionLimitPayload>;
  /** Starts a GitHub Enterprise Importer organization migration. */
  startOrganizationMigration?: Maybe<Github_StartOrganizationMigrationPayload>;
  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */
  startRepositoryMigration?: Maybe<Github_StartRepositoryMigrationPayload>;
  /** Submits a pending pull request review. */
  submitPullRequestReview?: Maybe<Github_SubmitPullRequestReviewPayload>;
  /** Transfer an organization from one enterprise to another enterprise. */
  transferEnterpriseOrganization?: Maybe<Github_TransferEnterpriseOrganizationPayload>;
  /** Transfer an issue to a different repository */
  transferIssue?: Maybe<Github_TransferIssuePayload>;
  /** Unarchives a ProjectV2Item */
  unarchiveProjectV2Item?: Maybe<Github_UnarchiveProjectV2ItemPayload>;
  /** Unarchives a repository. */
  unarchiveRepository?: Maybe<Github_UnarchiveRepositoryPayload>;
  /** Unfollow an organization. */
  unfollowOrganization?: Maybe<Github_UnfollowOrganizationPayload>;
  /** Unfollow a user. */
  unfollowUser?: Maybe<Github_UnfollowUserPayload>;
  /** Unlinks a project from a repository. */
  unlinkProjectV2FromRepository?: Maybe<Github_UnlinkProjectV2FromRepositoryPayload>;
  /** Unlinks a project to a team. */
  unlinkProjectV2FromTeam?: Maybe<Github_UnlinkProjectV2FromTeamPayload>;
  /** Deletes a repository link from a project. */
  unlinkRepositoryFromProject?: Maybe<Github_UnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  unlockLockable?: Maybe<Github_UnlockLockablePayload>;
  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */
  unmarkDiscussionCommentAsAnswer?: Maybe<Github_UnmarkDiscussionCommentAsAnswerPayload>;
  /** Unmark a pull request file as viewed */
  unmarkFileAsViewed?: Maybe<Github_UnmarkFileAsViewedPayload>;
  /** Unmark an issue as a duplicate of another issue. */
  unmarkIssueAsDuplicate?: Maybe<Github_UnmarkIssueAsDuplicatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  unminimizeComment?: Maybe<Github_UnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  unpinIssue?: Maybe<Github_UnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  unresolveReviewThread?: Maybe<Github_UnresolveReviewThreadPayload>;
  /** Update a branch protection rule */
  updateBranchProtectionRule?: Maybe<Github_UpdateBranchProtectionRulePayload>;
  /** Update a check run */
  updateCheckRun?: Maybe<Github_UpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  updateCheckSuitePreferences?: Maybe<Github_UpdateCheckSuitePreferencesPayload>;
  /** Update a discussion */
  updateDiscussion?: Maybe<Github_UpdateDiscussionPayload>;
  /** Update the contents of a comment on a Discussion */
  updateDiscussionComment?: Maybe<Github_UpdateDiscussionCommentPayload>;
  /** Updates the role of an enterprise administrator. */
  updateEnterpriseAdministratorRole?: Maybe<Github_UpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the base repository permission for organizations in an enterprise. */
  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization admin can make purchases. */
  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  updateEnterpriseOrganizationProjectsSetting?: Maybe<Github_UpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates the role of an enterprise owner with an organization. */
  updateEnterpriseOwnerOrganizationRole?: Maybe<Github_UpdateEnterpriseOwnerOrganizationRolePayload>;
  /** Updates an enterprise's profile. */
  updateEnterpriseProfile?: Maybe<Github_UpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  updateEnterpriseRepositoryProjectsSetting?: Maybe<Github_UpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  updateEnterpriseTeamDiscussionsSetting?: Maybe<Github_UpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Updates an environment. */
  updateEnvironment?: Maybe<Github_UpdateEnvironmentPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  updateIpAllowListEnabledSetting?: Maybe<Github_UpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  updateIpAllowListEntry?: Maybe<Github_UpdateIpAllowListEntryPayload>;
  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */
  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;
  /** Updates an Issue. */
  updateIssue?: Maybe<Github_UpdateIssuePayload>;
  /** Updates an IssueComment object. */
  updateIssueComment?: Maybe<Github_UpdateIssueCommentPayload>;
  /** Updates an existing label. */
  updateLabel?: Maybe<Github_UpdateLabelPayload>;
  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */
  updateNotificationRestrictionSetting?: Maybe<Github_UpdateNotificationRestrictionSettingPayload>;
  /** Sets whether private repository forks are enabled for an organization. */
  updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */
  updateOrganizationWebCommitSignoffSetting?: Maybe<Github_UpdateOrganizationWebCommitSignoffSettingPayload>;
  /** Updates an existing project. */
  updateProject?: Maybe<Github_UpdateProjectPayload>;
  /** Updates an existing project card. */
  updateProjectCard?: Maybe<Github_UpdateProjectCardPayload>;
  /** Updates an existing project column. */
  updateProjectColumn?: Maybe<Github_UpdateProjectColumnPayload>;
  /** Updates an existing project (beta). */
  updateProjectV2?: Maybe<Github_UpdateProjectV2Payload>;
  /** Updates a draft issue within a Project. */
  updateProjectV2DraftIssue?: Maybe<Github_UpdateProjectV2DraftIssuePayload>;
  /**
   * This mutation updates the value of a field for an item in a Project. Currently
   * only single-select, text, number, date, and iteration fields are supported.
   */
  updateProjectV2ItemFieldValue?: Maybe<Github_UpdateProjectV2ItemFieldValuePayload>;
  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */
  updateProjectV2ItemPosition?: Maybe<Github_UpdateProjectV2ItemPositionPayload>;
  /** Update a pull request */
  updatePullRequest?: Maybe<Github_UpdatePullRequestPayload>;
  /** Merge or Rebase HEAD from upstream branch into pull request branch */
  updatePullRequestBranch?: Maybe<Github_UpdatePullRequestBranchPayload>;
  /** Updates the body of a pull request review. */
  updatePullRequestReview?: Maybe<Github_UpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  updatePullRequestReviewComment?: Maybe<Github_UpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  updateRef?: Maybe<Github_UpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   *
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   *
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   *
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   *
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  updateRefs?: Maybe<Github_UpdateRefsPayload>;
  /** Update information about a repository. */
  updateRepository?: Maybe<Github_UpdateRepositoryPayload>;
  /** Sets whether contributors are required to sign off on web-based commits for a repository. */
  updateRepositoryWebCommitSignoffSetting?: Maybe<Github_UpdateRepositoryWebCommitSignoffSettingPayload>;
  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */
  updateSponsorshipPreferences?: Maybe<Github_UpdateSponsorshipPreferencesPayload>;
  /** Updates the state for subscribable subjects. */
  updateSubscription?: Maybe<Github_UpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  updateTeamDiscussion?: Maybe<Github_UpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  updateTeamDiscussionComment?: Maybe<Github_UpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  updateTeamReviewAssignment?: Maybe<Github_UpdateTeamReviewAssignmentPayload>;
  /** Update team repository. */
  updateTeamsRepository?: Maybe<Github_UpdateTeamsRepositoryPayload>;
  /** Replaces the repository's topics with the given topics. */
  updateTopics?: Maybe<Github_UpdateTopicsPayload>;
  /** Verify that a verifiable domain has the expected DNS record. */
  verifyVerifiableDomain?: Maybe<Github_VerifyVerifiableDomainPayload>;
};


export type github_1MutationabortQueuedMigrationsArgs = {
  input: Github_AbortQueuedMigrationsInput;
};


export type github_1MutationacceptEnterpriseAdministratorInvitationArgs = {
  input: Github_AcceptEnterpriseAdministratorInvitationInput;
};


export type github_1MutationacceptTopicSuggestionArgs = {
  input: Github_AcceptTopicSuggestionInput;
};


export type github_1MutationaddAssigneesToAssignableArgs = {
  input: Github_AddAssigneesToAssignableInput;
};


export type github_1MutationaddCommentArgs = {
  input: Github_AddCommentInput;
};


export type github_1MutationaddDiscussionCommentArgs = {
  input: Github_AddDiscussionCommentInput;
};


export type github_1MutationaddDiscussionPollVoteArgs = {
  input: Github_AddDiscussionPollVoteInput;
};


export type github_1MutationaddEnterpriseOrganizationMemberArgs = {
  input: Github_AddEnterpriseOrganizationMemberInput;
};


export type github_1MutationaddEnterpriseSupportEntitlementArgs = {
  input: Github_AddEnterpriseSupportEntitlementInput;
};


export type github_1MutationaddLabelsToLabelableArgs = {
  input: Github_AddLabelsToLabelableInput;
};


export type github_1MutationaddProjectCardArgs = {
  input: Github_AddProjectCardInput;
};


export type github_1MutationaddProjectColumnArgs = {
  input: Github_AddProjectColumnInput;
};


export type github_1MutationaddProjectV2DraftIssueArgs = {
  input: Github_AddProjectV2DraftIssueInput;
};


export type github_1MutationaddProjectV2ItemByIdArgs = {
  input: Github_AddProjectV2ItemByIdInput;
};


export type github_1MutationaddPullRequestReviewArgs = {
  input: Github_AddPullRequestReviewInput;
};


export type github_1MutationaddPullRequestReviewCommentArgs = {
  input: Github_AddPullRequestReviewCommentInput;
};


export type github_1MutationaddPullRequestReviewThreadArgs = {
  input: Github_AddPullRequestReviewThreadInput;
};


export type github_1MutationaddReactionArgs = {
  input: Github_AddReactionInput;
};


export type github_1MutationaddStarArgs = {
  input: Github_AddStarInput;
};


export type github_1MutationaddUpvoteArgs = {
  input: Github_AddUpvoteInput;
};


export type github_1MutationaddVerifiableDomainArgs = {
  input: Github_AddVerifiableDomainInput;
};


export type github_1MutationapproveDeploymentsArgs = {
  input: Github_ApproveDeploymentsInput;
};


export type github_1MutationapproveVerifiableDomainArgs = {
  input: Github_ApproveVerifiableDomainInput;
};


export type github_1MutationarchiveProjectV2ItemArgs = {
  input: Github_ArchiveProjectV2ItemInput;
};


export type github_1MutationarchiveRepositoryArgs = {
  input: Github_ArchiveRepositoryInput;
};


export type github_1MutationcancelEnterpriseAdminInvitationArgs = {
  input: Github_CancelEnterpriseAdminInvitationInput;
};


export type github_1MutationcancelSponsorshipArgs = {
  input: Github_CancelSponsorshipInput;
};


export type github_1MutationchangeUserStatusArgs = {
  input: Github_ChangeUserStatusInput;
};


export type github_1MutationclearLabelsFromLabelableArgs = {
  input: Github_ClearLabelsFromLabelableInput;
};


export type github_1MutationclearProjectV2ItemFieldValueArgs = {
  input: Github_ClearProjectV2ItemFieldValueInput;
};


export type github_1MutationcloneProjectArgs = {
  input: Github_CloneProjectInput;
};


export type github_1MutationcloneTemplateRepositoryArgs = {
  input: Github_CloneTemplateRepositoryInput;
};


export type github_1MutationcloseIssueArgs = {
  input: Github_CloseIssueInput;
};


export type github_1MutationclosePullRequestArgs = {
  input: Github_ClosePullRequestInput;
};


export type github_1MutationconvertProjectCardNoteToIssueArgs = {
  input: Github_ConvertProjectCardNoteToIssueInput;
};


export type github_1MutationconvertPullRequestToDraftArgs = {
  input: Github_ConvertPullRequestToDraftInput;
};


export type github_1MutationcopyProjectV2Args = {
  input: Github_CopyProjectV2Input;
};


export type github_1MutationcreateAttributionInvitationArgs = {
  input: Github_CreateAttributionInvitationInput;
};


export type github_1MutationcreateBranchProtectionRuleArgs = {
  input: Github_CreateBranchProtectionRuleInput;
};


export type github_1MutationcreateCheckRunArgs = {
  input: Github_CreateCheckRunInput;
};


export type github_1MutationcreateCheckSuiteArgs = {
  input: Github_CreateCheckSuiteInput;
};


export type github_1MutationcreateCommitOnBranchArgs = {
  input: Github_CreateCommitOnBranchInput;
};


export type github_1MutationcreateDeploymentArgs = {
  input: Github_CreateDeploymentInput;
};


export type github_1MutationcreateDeploymentStatusArgs = {
  input: Github_CreateDeploymentStatusInput;
};


export type github_1MutationcreateDiscussionArgs = {
  input: Github_CreateDiscussionInput;
};


export type github_1MutationcreateEnterpriseOrganizationArgs = {
  input: Github_CreateEnterpriseOrganizationInput;
};


export type github_1MutationcreateEnvironmentArgs = {
  input: Github_CreateEnvironmentInput;
};


export type github_1MutationcreateIpAllowListEntryArgs = {
  input: Github_CreateIpAllowListEntryInput;
};


export type github_1MutationcreateIssueArgs = {
  input: Github_CreateIssueInput;
};


export type github_1MutationcreateLabelArgs = {
  input: Github_CreateLabelInput;
};


export type github_1MutationcreateLinkedBranchArgs = {
  input: Github_CreateLinkedBranchInput;
};


export type github_1MutationcreateMigrationSourceArgs = {
  input: Github_CreateMigrationSourceInput;
};


export type github_1MutationcreateProjectArgs = {
  input: Github_CreateProjectInput;
};


export type github_1MutationcreateProjectV2Args = {
  input: Github_CreateProjectV2Input;
};


export type github_1MutationcreatePullRequestArgs = {
  input: Github_CreatePullRequestInput;
};


export type github_1MutationcreateRefArgs = {
  input: Github_CreateRefInput;
};


export type github_1MutationcreateRepositoryArgs = {
  input: Github_CreateRepositoryInput;
};


export type github_1MutationcreateSponsorsListingArgs = {
  input: Github_CreateSponsorsListingInput;
};


export type github_1MutationcreateSponsorsTierArgs = {
  input: Github_CreateSponsorsTierInput;
};


export type github_1MutationcreateSponsorshipArgs = {
  input: Github_CreateSponsorshipInput;
};


export type github_1MutationcreateTeamDiscussionArgs = {
  input: Github_CreateTeamDiscussionInput;
};


export type github_1MutationcreateTeamDiscussionCommentArgs = {
  input: Github_CreateTeamDiscussionCommentInput;
};


export type github_1MutationdeclineTopicSuggestionArgs = {
  input: Github_DeclineTopicSuggestionInput;
};


export type github_1MutationdeleteBranchProtectionRuleArgs = {
  input: Github_DeleteBranchProtectionRuleInput;
};


export type github_1MutationdeleteDeploymentArgs = {
  input: Github_DeleteDeploymentInput;
};


export type github_1MutationdeleteDiscussionArgs = {
  input: Github_DeleteDiscussionInput;
};


export type github_1MutationdeleteDiscussionCommentArgs = {
  input: Github_DeleteDiscussionCommentInput;
};


export type github_1MutationdeleteEnvironmentArgs = {
  input: Github_DeleteEnvironmentInput;
};


export type github_1MutationdeleteIpAllowListEntryArgs = {
  input: Github_DeleteIpAllowListEntryInput;
};


export type github_1MutationdeleteIssueArgs = {
  input: Github_DeleteIssueInput;
};


export type github_1MutationdeleteIssueCommentArgs = {
  input: Github_DeleteIssueCommentInput;
};


export type github_1MutationdeleteLabelArgs = {
  input: Github_DeleteLabelInput;
};


export type github_1MutationdeleteLinkedBranchArgs = {
  input: Github_DeleteLinkedBranchInput;
};


export type github_1MutationdeletePackageVersionArgs = {
  input: Github_DeletePackageVersionInput;
};


export type github_1MutationdeleteProjectArgs = {
  input: Github_DeleteProjectInput;
};


export type github_1MutationdeleteProjectCardArgs = {
  input: Github_DeleteProjectCardInput;
};


export type github_1MutationdeleteProjectColumnArgs = {
  input: Github_DeleteProjectColumnInput;
};


export type github_1MutationdeleteProjectV2Args = {
  input: Github_DeleteProjectV2Input;
};


export type github_1MutationdeleteProjectV2ItemArgs = {
  input: Github_DeleteProjectV2ItemInput;
};


export type github_1MutationdeletePullRequestReviewArgs = {
  input: Github_DeletePullRequestReviewInput;
};


export type github_1MutationdeletePullRequestReviewCommentArgs = {
  input: Github_DeletePullRequestReviewCommentInput;
};


export type github_1MutationdeleteRefArgs = {
  input: Github_DeleteRefInput;
};


export type github_1MutationdeleteTeamDiscussionArgs = {
  input: Github_DeleteTeamDiscussionInput;
};


export type github_1MutationdeleteTeamDiscussionCommentArgs = {
  input: Github_DeleteTeamDiscussionCommentInput;
};


export type github_1MutationdeleteVerifiableDomainArgs = {
  input: Github_DeleteVerifiableDomainInput;
};


export type github_1MutationdisablePullRequestAutoMergeArgs = {
  input: Github_DisablePullRequestAutoMergeInput;
};


export type github_1MutationdismissPullRequestReviewArgs = {
  input: Github_DismissPullRequestReviewInput;
};


export type github_1MutationdismissRepositoryVulnerabilityAlertArgs = {
  input: Github_DismissRepositoryVulnerabilityAlertInput;
};


export type github_1MutationenablePullRequestAutoMergeArgs = {
  input: Github_EnablePullRequestAutoMergeInput;
};


export type github_1MutationfollowOrganizationArgs = {
  input: Github_FollowOrganizationInput;
};


export type github_1MutationfollowUserArgs = {
  input: Github_FollowUserInput;
};


export type github_1MutationgrantEnterpriseOrganizationsMigratorRoleArgs = {
  input: Github_GrantEnterpriseOrganizationsMigratorRoleInput;
};


export type github_1MutationgrantMigratorRoleArgs = {
  input: Github_GrantMigratorRoleInput;
};


export type github_1MutationimportProjectArgs = {
  input: Github_ImportProjectInput;
};


export type github_1MutationinviteEnterpriseAdminArgs = {
  input: Github_InviteEnterpriseAdminInput;
};


export type github_1MutationlinkProjectV2ToRepositoryArgs = {
  input: Github_LinkProjectV2ToRepositoryInput;
};


export type github_1MutationlinkProjectV2ToTeamArgs = {
  input: Github_LinkProjectV2ToTeamInput;
};


export type github_1MutationlinkRepositoryToProjectArgs = {
  input: Github_LinkRepositoryToProjectInput;
};


export type github_1MutationlockLockableArgs = {
  input: Github_LockLockableInput;
};


export type github_1MutationmarkDiscussionCommentAsAnswerArgs = {
  input: Github_MarkDiscussionCommentAsAnswerInput;
};


export type github_1MutationmarkFileAsViewedArgs = {
  input: Github_MarkFileAsViewedInput;
};


export type github_1MutationmarkPullRequestReadyForReviewArgs = {
  input: Github_MarkPullRequestReadyForReviewInput;
};


export type github_1MutationmergeBranchArgs = {
  input: Github_MergeBranchInput;
};


export type github_1MutationmergePullRequestArgs = {
  input: Github_MergePullRequestInput;
};


export type github_1MutationminimizeCommentArgs = {
  input: Github_MinimizeCommentInput;
};


export type github_1MutationmoveProjectCardArgs = {
  input: Github_MoveProjectCardInput;
};


export type github_1MutationmoveProjectColumnArgs = {
  input: Github_MoveProjectColumnInput;
};


export type github_1MutationpinIssueArgs = {
  input: Github_PinIssueInput;
};


export type github_1MutationpublishSponsorsTierArgs = {
  input: Github_PublishSponsorsTierInput;
};


export type github_1MutationregenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};


export type github_1MutationregenerateVerifiableDomainTokenArgs = {
  input: Github_RegenerateVerifiableDomainTokenInput;
};


export type github_1MutationrejectDeploymentsArgs = {
  input: Github_RejectDeploymentsInput;
};


export type github_1MutationremoveAssigneesFromAssignableArgs = {
  input: Github_RemoveAssigneesFromAssignableInput;
};


export type github_1MutationremoveEnterpriseAdminArgs = {
  input: Github_RemoveEnterpriseAdminInput;
};


export type github_1MutationremoveEnterpriseIdentityProviderArgs = {
  input: Github_RemoveEnterpriseIdentityProviderInput;
};


export type github_1MutationremoveEnterpriseMemberArgs = {
  input: Github_RemoveEnterpriseMemberInput;
};


export type github_1MutationremoveEnterpriseOrganizationArgs = {
  input: Github_RemoveEnterpriseOrganizationInput;
};


export type github_1MutationremoveEnterpriseSupportEntitlementArgs = {
  input: Github_RemoveEnterpriseSupportEntitlementInput;
};


export type github_1MutationremoveLabelsFromLabelableArgs = {
  input: Github_RemoveLabelsFromLabelableInput;
};


export type github_1MutationremoveOutsideCollaboratorArgs = {
  input: Github_RemoveOutsideCollaboratorInput;
};


export type github_1MutationremoveReactionArgs = {
  input: Github_RemoveReactionInput;
};


export type github_1MutationremoveStarArgs = {
  input: Github_RemoveStarInput;
};


export type github_1MutationremoveUpvoteArgs = {
  input: Github_RemoveUpvoteInput;
};


export type github_1MutationreopenIssueArgs = {
  input: Github_ReopenIssueInput;
};


export type github_1MutationreopenPullRequestArgs = {
  input: Github_ReopenPullRequestInput;
};


export type github_1MutationrequestReviewsArgs = {
  input: Github_RequestReviewsInput;
};


export type github_1MutationrerequestCheckSuiteArgs = {
  input: Github_RerequestCheckSuiteInput;
};


export type github_1MutationresolveReviewThreadArgs = {
  input: Github_ResolveReviewThreadInput;
};


export type github_1MutationretireSponsorsTierArgs = {
  input: Github_RetireSponsorsTierInput;
};


export type github_1MutationrevertPullRequestArgs = {
  input: Github_RevertPullRequestInput;
};


export type github_1MutationrevokeEnterpriseOrganizationsMigratorRoleArgs = {
  input: Github_RevokeEnterpriseOrganizationsMigratorRoleInput;
};


export type github_1MutationrevokeMigratorRoleArgs = {
  input: Github_RevokeMigratorRoleInput;
};


export type github_1MutationsetEnterpriseIdentityProviderArgs = {
  input: Github_SetEnterpriseIdentityProviderInput;
};


export type github_1MutationsetOrganizationInteractionLimitArgs = {
  input: Github_SetOrganizationInteractionLimitInput;
};


export type github_1MutationsetRepositoryInteractionLimitArgs = {
  input: Github_SetRepositoryInteractionLimitInput;
};


export type github_1MutationsetUserInteractionLimitArgs = {
  input: Github_SetUserInteractionLimitInput;
};


export type github_1MutationstartOrganizationMigrationArgs = {
  input: Github_StartOrganizationMigrationInput;
};


export type github_1MutationstartRepositoryMigrationArgs = {
  input: Github_StartRepositoryMigrationInput;
};


export type github_1MutationsubmitPullRequestReviewArgs = {
  input: Github_SubmitPullRequestReviewInput;
};


export type github_1MutationtransferEnterpriseOrganizationArgs = {
  input: Github_TransferEnterpriseOrganizationInput;
};


export type github_1MutationtransferIssueArgs = {
  input: Github_TransferIssueInput;
};


export type github_1MutationunarchiveProjectV2ItemArgs = {
  input: Github_UnarchiveProjectV2ItemInput;
};


export type github_1MutationunarchiveRepositoryArgs = {
  input: Github_UnarchiveRepositoryInput;
};


export type github_1MutationunfollowOrganizationArgs = {
  input: Github_UnfollowOrganizationInput;
};


export type github_1MutationunfollowUserArgs = {
  input: Github_UnfollowUserInput;
};


export type github_1MutationunlinkProjectV2FromRepositoryArgs = {
  input: Github_UnlinkProjectV2FromRepositoryInput;
};


export type github_1MutationunlinkProjectV2FromTeamArgs = {
  input: Github_UnlinkProjectV2FromTeamInput;
};


export type github_1MutationunlinkRepositoryFromProjectArgs = {
  input: Github_UnlinkRepositoryFromProjectInput;
};


export type github_1MutationunlockLockableArgs = {
  input: Github_UnlockLockableInput;
};


export type github_1MutationunmarkDiscussionCommentAsAnswerArgs = {
  input: Github_UnmarkDiscussionCommentAsAnswerInput;
};


export type github_1MutationunmarkFileAsViewedArgs = {
  input: Github_UnmarkFileAsViewedInput;
};


export type github_1MutationunmarkIssueAsDuplicateArgs = {
  input: Github_UnmarkIssueAsDuplicateInput;
};


export type github_1MutationunminimizeCommentArgs = {
  input: Github_UnminimizeCommentInput;
};


export type github_1MutationunpinIssueArgs = {
  input: Github_UnpinIssueInput;
};


export type github_1MutationunresolveReviewThreadArgs = {
  input: Github_UnresolveReviewThreadInput;
};


export type github_1MutationupdateBranchProtectionRuleArgs = {
  input: Github_UpdateBranchProtectionRuleInput;
};


export type github_1MutationupdateCheckRunArgs = {
  input: Github_UpdateCheckRunInput;
};


export type github_1MutationupdateCheckSuitePreferencesArgs = {
  input: Github_UpdateCheckSuitePreferencesInput;
};


export type github_1MutationupdateDiscussionArgs = {
  input: Github_UpdateDiscussionInput;
};


export type github_1MutationupdateDiscussionCommentArgs = {
  input: Github_UpdateDiscussionCommentInput;
};


export type github_1MutationupdateEnterpriseAdministratorRoleArgs = {
  input: Github_UpdateEnterpriseAdministratorRoleInput;
};


export type github_1MutationupdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};


export type github_1MutationupdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  input: Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
};


export type github_1MutationupdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  input: Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
};


export type github_1MutationupdateEnterpriseOrganizationProjectsSettingArgs = {
  input: Github_UpdateEnterpriseOrganizationProjectsSettingInput;
};


export type github_1MutationupdateEnterpriseOwnerOrganizationRoleArgs = {
  input: Github_UpdateEnterpriseOwnerOrganizationRoleInput;
};


export type github_1MutationupdateEnterpriseProfileArgs = {
  input: Github_UpdateEnterpriseProfileInput;
};


export type github_1MutationupdateEnterpriseRepositoryProjectsSettingArgs = {
  input: Github_UpdateEnterpriseRepositoryProjectsSettingInput;
};


export type github_1MutationupdateEnterpriseTeamDiscussionsSettingArgs = {
  input: Github_UpdateEnterpriseTeamDiscussionsSettingInput;
};


export type github_1MutationupdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  input: Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
};


export type github_1MutationupdateEnvironmentArgs = {
  input: Github_UpdateEnvironmentInput;
};


export type github_1MutationupdateIpAllowListEnabledSettingArgs = {
  input: Github_UpdateIpAllowListEnabledSettingInput;
};


export type github_1MutationupdateIpAllowListEntryArgs = {
  input: Github_UpdateIpAllowListEntryInput;
};


export type github_1MutationupdateIpAllowListForInstalledAppsEnabledSettingArgs = {
  input: Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
};


export type github_1MutationupdateIssueArgs = {
  input: Github_UpdateIssueInput;
};


export type github_1MutationupdateIssueCommentArgs = {
  input: Github_UpdateIssueCommentInput;
};


export type github_1MutationupdateLabelArgs = {
  input: Github_UpdateLabelInput;
};


export type github_1MutationupdateNotificationRestrictionSettingArgs = {
  input: Github_UpdateNotificationRestrictionSettingInput;
};


export type github_1MutationupdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {
  input: Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
};


export type github_1MutationupdateOrganizationWebCommitSignoffSettingArgs = {
  input: Github_UpdateOrganizationWebCommitSignoffSettingInput;
};


export type github_1MutationupdateProjectArgs = {
  input: Github_UpdateProjectInput;
};


export type github_1MutationupdateProjectCardArgs = {
  input: Github_UpdateProjectCardInput;
};


export type github_1MutationupdateProjectColumnArgs = {
  input: Github_UpdateProjectColumnInput;
};


export type github_1MutationupdateProjectV2Args = {
  input: Github_UpdateProjectV2Input;
};


export type github_1MutationupdateProjectV2DraftIssueArgs = {
  input: Github_UpdateProjectV2DraftIssueInput;
};


export type github_1MutationupdateProjectV2ItemFieldValueArgs = {
  input: Github_UpdateProjectV2ItemFieldValueInput;
};


export type github_1MutationupdateProjectV2ItemPositionArgs = {
  input: Github_UpdateProjectV2ItemPositionInput;
};


export type github_1MutationupdatePullRequestArgs = {
  input: Github_UpdatePullRequestInput;
};


export type github_1MutationupdatePullRequestBranchArgs = {
  input: Github_UpdatePullRequestBranchInput;
};


export type github_1MutationupdatePullRequestReviewArgs = {
  input: Github_UpdatePullRequestReviewInput;
};


export type github_1MutationupdatePullRequestReviewCommentArgs = {
  input: Github_UpdatePullRequestReviewCommentInput;
};


export type github_1MutationupdateRefArgs = {
  input: Github_UpdateRefInput;
};


export type github_1MutationupdateRefsArgs = {
  input: Github_UpdateRefsInput;
};


export type github_1MutationupdateRepositoryArgs = {
  input: Github_UpdateRepositoryInput;
};


export type github_1MutationupdateRepositoryWebCommitSignoffSettingArgs = {
  input: Github_UpdateRepositoryWebCommitSignoffSettingInput;
};


export type github_1MutationupdateSponsorshipPreferencesArgs = {
  input: Github_UpdateSponsorshipPreferencesInput;
};


export type github_1MutationupdateSubscriptionArgs = {
  input: Github_UpdateSubscriptionInput;
};


export type github_1MutationupdateTeamDiscussionArgs = {
  input: Github_UpdateTeamDiscussionInput;
};


export type github_1MutationupdateTeamDiscussionCommentArgs = {
  input: Github_UpdateTeamDiscussionCommentInput;
};


export type github_1MutationupdateTeamReviewAssignmentArgs = {
  input: Github_UpdateTeamReviewAssignmentInput;
};


export type github_1MutationupdateTeamsRepositoryArgs = {
  input: Github_UpdateTeamsRepositoryInput;
};


export type github_1MutationupdateTopicsArgs = {
  input: Github_UpdateTopicsInput;
};


export type github_1MutationverifyVerifiableDomainArgs = {
  input: Github_VerifyVerifiableDomainInput;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Query: ResolverTypeWrapper<{}>;
  AWSLambda_ListFunctionsResponse: ResolverTypeWrapper<AWSLambda_ListFunctionsResponse>;
  AWSLambda_FunctionsListItem: ResolverTypeWrapper<AWSLambda_FunctionsListItem>;
  String: ResolverTypeWrapper<Scalars['String']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  AWSLambda_DeadLetterConfig: ResolverTypeWrapper<AWSLambda_DeadLetterConfig>;
  AWSLambda_Environment: ResolverTypeWrapper<AWSLambda_Environment>;
  AWSLambda_Error: ResolverTypeWrapper<AWSLambda_Error>;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  AWSLambda_FileSystemConfigsListItem: ResolverTypeWrapper<AWSLambda_FileSystemConfigsListItem>;
  AWSLambda_ImageConfigResponse: ResolverTypeWrapper<AWSLambda_ImageConfigResponse>;
  AWSLambda_Error2: ResolverTypeWrapper<AWSLambda_Error2>;
  AWSLambda_ImageConfig: ResolverTypeWrapper<AWSLambda_ImageConfig>;
  AWSLambda_LastUpdateStatus: AWSLambda_LastUpdateStatus;
  AWSLambda_LastUpdateStatusReasonCode: AWSLambda_LastUpdateStatusReasonCode;
  AWSLambda_LayersListItem: ResolverTypeWrapper<AWSLambda_LayersListItem>;
  AWSLambda_PackageType: AWSLambda_PackageType;
  AWSLambda_Runtime: AWSLambda_Runtime;
  AWSLambda_State: AWSLambda_State;
  AWSLambda_StateReasonCode: AWSLambda_StateReasonCode;
  AWSLambda_TracingConfig: ResolverTypeWrapper<AWSLambda_TracingConfig>;
  AWSLambda_Mode: AWSLambda_Mode;
  AWSLambda_VpcConfig: ResolverTypeWrapper<AWSLambda_VpcConfig>;
  AWSLambda_FunctionVersion: AWSLambda_FunctionVersion;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  aws_lambda_1Query: ResolverTypeWrapper<aws_lambda_1Query>;
  Mutation: ResolverTypeWrapper<{}>;
  Github_AbortQueuedMigrationsInput: Github_AbortQueuedMigrationsInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Github_AbortQueuedMigrationsPayload: ResolverTypeWrapper<Github_AbortQueuedMigrationsPayload>;
  Github_AcceptEnterpriseAdministratorInvitationInput: Github_AcceptEnterpriseAdministratorInvitationInput;
  Github_AcceptEnterpriseAdministratorInvitationPayload: ResolverTypeWrapper<Github_AcceptEnterpriseAdministratorInvitationPayload>;
  Github_AcceptTopicSuggestionInput: Github_AcceptTopicSuggestionInput;
  Github_AcceptTopicSuggestionPayload: ResolverTypeWrapper<Github_AcceptTopicSuggestionPayload>;
  Github_Actor: ResolversTypes['Github_Bot'] | ResolversTypes['Github_EnterpriseUserAccount'] | ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_ActorLocation: ResolverTypeWrapper<Github_ActorLocation>;
  Github_ActorType: Github_ActorType;
  Github_AddAssigneesToAssignableInput: Github_AddAssigneesToAssignableInput;
  Github_AddAssigneesToAssignablePayload: ResolverTypeWrapper<Github_AddAssigneesToAssignablePayload>;
  Github_AddCommentInput: Github_AddCommentInput;
  Github_AddCommentPayload: ResolverTypeWrapper<Github_AddCommentPayload>;
  Github_AddDiscussionCommentInput: Github_AddDiscussionCommentInput;
  Github_AddDiscussionCommentPayload: ResolverTypeWrapper<Github_AddDiscussionCommentPayload>;
  Github_AddDiscussionPollVoteInput: Github_AddDiscussionPollVoteInput;
  Github_AddDiscussionPollVotePayload: ResolverTypeWrapper<Github_AddDiscussionPollVotePayload>;
  Github_AddEnterpriseOrganizationMemberInput: Github_AddEnterpriseOrganizationMemberInput;
  Github_AddEnterpriseOrganizationMemberPayload: ResolverTypeWrapper<Github_AddEnterpriseOrganizationMemberPayload>;
  Github_AddEnterpriseSupportEntitlementInput: Github_AddEnterpriseSupportEntitlementInput;
  Github_AddEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<Github_AddEnterpriseSupportEntitlementPayload>;
  Github_AddLabelsToLabelableInput: Github_AddLabelsToLabelableInput;
  Github_AddLabelsToLabelablePayload: ResolverTypeWrapper<Github_AddLabelsToLabelablePayload>;
  Github_AddProjectCardInput: Github_AddProjectCardInput;
  Github_AddProjectCardPayload: ResolverTypeWrapper<Github_AddProjectCardPayload>;
  Github_AddProjectColumnInput: Github_AddProjectColumnInput;
  Github_AddProjectColumnPayload: ResolverTypeWrapper<Github_AddProjectColumnPayload>;
  Github_AddProjectV2DraftIssueInput: Github_AddProjectV2DraftIssueInput;
  Github_AddProjectV2DraftIssuePayload: ResolverTypeWrapper<Github_AddProjectV2DraftIssuePayload>;
  Github_AddProjectV2ItemByIdInput: Github_AddProjectV2ItemByIdInput;
  Github_AddProjectV2ItemByIdPayload: ResolverTypeWrapper<Github_AddProjectV2ItemByIdPayload>;
  Github_AddPullRequestReviewCommentInput: Github_AddPullRequestReviewCommentInput;
  Github_AddPullRequestReviewCommentPayload: ResolverTypeWrapper<Github_AddPullRequestReviewCommentPayload>;
  Github_AddPullRequestReviewInput: Github_AddPullRequestReviewInput;
  Github_AddPullRequestReviewPayload: ResolverTypeWrapper<Github_AddPullRequestReviewPayload>;
  Github_AddPullRequestReviewThreadInput: Github_AddPullRequestReviewThreadInput;
  Github_AddPullRequestReviewThreadPayload: ResolverTypeWrapper<Github_AddPullRequestReviewThreadPayload>;
  Github_AddReactionInput: Github_AddReactionInput;
  Github_AddReactionPayload: ResolverTypeWrapper<Github_AddReactionPayload>;
  Github_AddStarInput: Github_AddStarInput;
  Github_AddStarPayload: ResolverTypeWrapper<Github_AddStarPayload>;
  Github_AddUpvoteInput: Github_AddUpvoteInput;
  Github_AddUpvotePayload: ResolverTypeWrapper<Github_AddUpvotePayload>;
  Github_AddVerifiableDomainInput: Github_AddVerifiableDomainInput;
  Github_AddVerifiableDomainPayload: ResolverTypeWrapper<Github_AddVerifiableDomainPayload>;
  Github_AddedToProjectEvent: ResolverTypeWrapper<Github_AddedToProjectEvent>;
  Github_AnnouncementBanner: ResolversTypes['Github_Enterprise'] | ResolversTypes['Github_Organization'];
  Github_App: ResolverTypeWrapper<Github_App>;
  Github_ApproveDeploymentsInput: Github_ApproveDeploymentsInput;
  Github_ApproveDeploymentsPayload: ResolverTypeWrapper<Github_ApproveDeploymentsPayload>;
  Github_ApproveVerifiableDomainInput: Github_ApproveVerifiableDomainInput;
  Github_ApproveVerifiableDomainPayload: ResolverTypeWrapper<Github_ApproveVerifiableDomainPayload>;
  Github_ArchiveProjectV2ItemInput: Github_ArchiveProjectV2ItemInput;
  Github_ArchiveProjectV2ItemPayload: ResolverTypeWrapper<Github_ArchiveProjectV2ItemPayload>;
  Github_ArchiveRepositoryInput: Github_ArchiveRepositoryInput;
  Github_ArchiveRepositoryPayload: ResolverTypeWrapper<Github_ArchiveRepositoryPayload>;
  Github_Assignable: ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_AssignedEvent: ResolverTypeWrapper<Omit<Github_AssignedEvent, 'assignee'> & { assignee?: Maybe<ResolversTypes['Github_Assignee']> }>;
  Github_Assignee: ResolversTypes['Github_Bot'] | ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_AuditEntry: ResolversTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversTypes['Github_OrgAddMemberAuditEntry'] | ResolversTypes['Github_OrgBlockUserAuditEntry'] | ResolversTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgCreateAuditEntry'] | ResolversTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgDisableSamlAuditEntry'] | ResolversTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgEnableSamlAuditEntry'] | ResolversTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgInviteMemberAuditEntry'] | ResolversTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversTypes['Github_OrgUnblockUserAuditEntry'] | ResolversTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversTypes['Github_RepoAccessAuditEntry'] | ResolversTypes['Github_RepoAddMemberAuditEntry'] | ResolversTypes['Github_RepoAddTopicAuditEntry'] | ResolversTypes['Github_RepoArchivedAuditEntry'] | ResolversTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoCreateAuditEntry'] | ResolversTypes['Github_RepoDestroyAuditEntry'] | ResolversTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversTypes['Github_TeamAddMemberAuditEntry'] | ResolversTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_AuditEntryActor: ResolversTypes['Github_Bot'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_AuditLogOrder: Github_AuditLogOrder;
  Github_AuditLogOrderField: Github_AuditLogOrderField;
  Github_AutoMergeDisabledEvent: ResolverTypeWrapper<Github_AutoMergeDisabledEvent>;
  Github_AutoMergeEnabledEvent: ResolverTypeWrapper<Github_AutoMergeEnabledEvent>;
  Github_AutoMergeRequest: ResolverTypeWrapper<Github_AutoMergeRequest>;
  Github_AutoRebaseEnabledEvent: ResolverTypeWrapper<Github_AutoRebaseEnabledEvent>;
  Github_AutoSquashEnabledEvent: ResolverTypeWrapper<Github_AutoSquashEnabledEvent>;
  Github_AutomaticBaseChangeFailedEvent: ResolverTypeWrapper<Github_AutomaticBaseChangeFailedEvent>;
  Github_AutomaticBaseChangeSucceededEvent: ResolverTypeWrapper<Github_AutomaticBaseChangeSucceededEvent>;
  Github_Base64String: ResolverTypeWrapper<Scalars['Github_Base64String']>;
  Github_BaseRefChangedEvent: ResolverTypeWrapper<Github_BaseRefChangedEvent>;
  Github_BaseRefDeletedEvent: ResolverTypeWrapper<Github_BaseRefDeletedEvent>;
  Github_BaseRefForcePushedEvent: ResolverTypeWrapper<Github_BaseRefForcePushedEvent>;
  Github_Blame: ResolverTypeWrapper<Github_Blame>;
  Github_BlameRange: ResolverTypeWrapper<Github_BlameRange>;
  Github_Blob: ResolverTypeWrapper<Github_Blob>;
  Github_Bot: ResolverTypeWrapper<Github_Bot>;
  Github_BranchActorAllowanceActor: ResolversTypes['Github_App'] | ResolversTypes['Github_Team'] | ResolversTypes['Github_User'];
  Github_BranchProtectionRule: ResolverTypeWrapper<Github_BranchProtectionRule>;
  Github_BranchProtectionRuleConflict: ResolverTypeWrapper<Github_BranchProtectionRuleConflict>;
  Github_BranchProtectionRuleConflictConnection: ResolverTypeWrapper<Github_BranchProtectionRuleConflictConnection>;
  Github_BranchProtectionRuleConflictEdge: ResolverTypeWrapper<Github_BranchProtectionRuleConflictEdge>;
  Github_BranchProtectionRuleConnection: ResolverTypeWrapper<Github_BranchProtectionRuleConnection>;
  Github_BranchProtectionRuleEdge: ResolverTypeWrapper<Github_BranchProtectionRuleEdge>;
  Github_BypassForcePushAllowance: ResolverTypeWrapper<Omit<Github_BypassForcePushAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['Github_BranchActorAllowanceActor']> }>;
  Github_BypassForcePushAllowanceConnection: ResolverTypeWrapper<Github_BypassForcePushAllowanceConnection>;
  Github_BypassForcePushAllowanceEdge: ResolverTypeWrapper<Github_BypassForcePushAllowanceEdge>;
  Github_BypassPullRequestAllowance: ResolverTypeWrapper<Omit<Github_BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['Github_BranchActorAllowanceActor']> }>;
  Github_BypassPullRequestAllowanceConnection: ResolverTypeWrapper<Github_BypassPullRequestAllowanceConnection>;
  Github_BypassPullRequestAllowanceEdge: ResolverTypeWrapper<Github_BypassPullRequestAllowanceEdge>;
  Github_CVSS: ResolverTypeWrapper<Github_CVSS>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  Github_CWE: ResolverTypeWrapper<Github_CWE>;
  Github_CWEConnection: ResolverTypeWrapper<Github_CWEConnection>;
  Github_CWEEdge: ResolverTypeWrapper<Github_CWEEdge>;
  Github_CancelEnterpriseAdminInvitationInput: Github_CancelEnterpriseAdminInvitationInput;
  Github_CancelEnterpriseAdminInvitationPayload: ResolverTypeWrapper<Github_CancelEnterpriseAdminInvitationPayload>;
  Github_CancelSponsorshipInput: Github_CancelSponsorshipInput;
  Github_CancelSponsorshipPayload: ResolverTypeWrapper<Github_CancelSponsorshipPayload>;
  Github_ChangeUserStatusInput: Github_ChangeUserStatusInput;
  Github_ChangeUserStatusPayload: ResolverTypeWrapper<Github_ChangeUserStatusPayload>;
  Github_CheckAnnotation: ResolverTypeWrapper<Github_CheckAnnotation>;
  Github_CheckAnnotationConnection: ResolverTypeWrapper<Github_CheckAnnotationConnection>;
  Github_CheckAnnotationData: Github_CheckAnnotationData;
  Github_CheckAnnotationEdge: ResolverTypeWrapper<Github_CheckAnnotationEdge>;
  Github_CheckAnnotationLevel: Github_CheckAnnotationLevel;
  Github_CheckAnnotationPosition: ResolverTypeWrapper<Github_CheckAnnotationPosition>;
  Github_CheckAnnotationRange: Github_CheckAnnotationRange;
  Github_CheckAnnotationSpan: ResolverTypeWrapper<Github_CheckAnnotationSpan>;
  Github_CheckConclusionState: Github_CheckConclusionState;
  Github_CheckRun: ResolverTypeWrapper<Github_CheckRun>;
  Github_CheckRunAction: Github_CheckRunAction;
  Github_CheckRunConnection: ResolverTypeWrapper<Github_CheckRunConnection>;
  Github_CheckRunEdge: ResolverTypeWrapper<Github_CheckRunEdge>;
  Github_CheckRunFilter: Github_CheckRunFilter;
  Github_CheckRunOutput: Github_CheckRunOutput;
  Github_CheckRunOutputImage: Github_CheckRunOutputImage;
  Github_CheckRunState: Github_CheckRunState;
  Github_CheckRunStateCount: ResolverTypeWrapper<Github_CheckRunStateCount>;
  Github_CheckRunType: Github_CheckRunType;
  Github_CheckStatusState: Github_CheckStatusState;
  Github_CheckStep: ResolverTypeWrapper<Github_CheckStep>;
  Github_CheckStepConnection: ResolverTypeWrapper<Github_CheckStepConnection>;
  Github_CheckStepEdge: ResolverTypeWrapper<Github_CheckStepEdge>;
  Github_CheckSuite: ResolverTypeWrapper<Github_CheckSuite>;
  Github_CheckSuiteAutoTriggerPreference: Github_CheckSuiteAutoTriggerPreference;
  Github_CheckSuiteConnection: ResolverTypeWrapper<Github_CheckSuiteConnection>;
  Github_CheckSuiteEdge: ResolverTypeWrapper<Github_CheckSuiteEdge>;
  Github_CheckSuiteFilter: Github_CheckSuiteFilter;
  Github_Claimable: ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_User'];
  Github_ClearLabelsFromLabelableInput: Github_ClearLabelsFromLabelableInput;
  Github_ClearLabelsFromLabelablePayload: ResolverTypeWrapper<Github_ClearLabelsFromLabelablePayload>;
  Github_ClearProjectV2ItemFieldValueInput: Github_ClearProjectV2ItemFieldValueInput;
  Github_ClearProjectV2ItemFieldValuePayload: ResolverTypeWrapper<Github_ClearProjectV2ItemFieldValuePayload>;
  Github_CloneProjectInput: Github_CloneProjectInput;
  Github_CloneProjectPayload: ResolverTypeWrapper<Github_CloneProjectPayload>;
  Github_CloneTemplateRepositoryInput: Github_CloneTemplateRepositoryInput;
  Github_CloneTemplateRepositoryPayload: ResolverTypeWrapper<Github_CloneTemplateRepositoryPayload>;
  Github_Closable: ResolversTypes['Github_Discussion'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_Milestone'] | ResolversTypes['Github_Project'] | ResolversTypes['Github_ProjectV2'] | ResolversTypes['Github_PullRequest'];
  Github_CloseIssueInput: Github_CloseIssueInput;
  Github_CloseIssuePayload: ResolverTypeWrapper<Github_CloseIssuePayload>;
  Github_ClosePullRequestInput: Github_ClosePullRequestInput;
  Github_ClosePullRequestPayload: ResolverTypeWrapper<Github_ClosePullRequestPayload>;
  Github_ClosedEvent: ResolverTypeWrapper<Omit<Github_ClosedEvent, 'closer'> & { closer?: Maybe<ResolversTypes['Github_Closer']> }>;
  Github_Closer: ResolversTypes['Github_Commit'] | ResolversTypes['Github_PullRequest'];
  Github_CodeOfConduct: ResolverTypeWrapper<Github_CodeOfConduct>;
  Github_CollaboratorAffiliation: Github_CollaboratorAffiliation;
  Github_Comment: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_GistComment'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'];
  Github_CommentAuthorAssociation: Github_CommentAuthorAssociation;
  Github_CommentCannotUpdateReason: Github_CommentCannotUpdateReason;
  Github_CommentDeletedEvent: ResolverTypeWrapper<Github_CommentDeletedEvent>;
  Github_Commit: ResolverTypeWrapper<Github_Commit>;
  Github_CommitAuthor: Github_CommitAuthor;
  Github_CommitComment: ResolverTypeWrapper<Github_CommitComment>;
  Github_CommitCommentConnection: ResolverTypeWrapper<Github_CommitCommentConnection>;
  Github_CommitCommentEdge: ResolverTypeWrapper<Github_CommitCommentEdge>;
  Github_CommitCommentThread: ResolverTypeWrapper<Github_CommitCommentThread>;
  Github_CommitConnection: ResolverTypeWrapper<Github_CommitConnection>;
  Github_CommitContributionOrder: Github_CommitContributionOrder;
  Github_CommitContributionOrderField: Github_CommitContributionOrderField;
  Github_CommitContributionsByRepository: ResolverTypeWrapper<Github_CommitContributionsByRepository>;
  Github_CommitEdge: ResolverTypeWrapper<Github_CommitEdge>;
  Github_CommitHistoryConnection: ResolverTypeWrapper<Github_CommitHistoryConnection>;
  Github_CommitMessage: Github_CommitMessage;
  Github_CommittableBranch: Github_CommittableBranch;
  Github_Comparison: ResolverTypeWrapper<Github_Comparison>;
  Github_ComparisonCommitConnection: ResolverTypeWrapper<Github_ComparisonCommitConnection>;
  Github_ComparisonStatus: Github_ComparisonStatus;
  Github_ConnectedEvent: ResolverTypeWrapper<Omit<Github_ConnectedEvent, 'source' | 'subject'> & { source: ResolversTypes['Github_ReferencedSubject'], subject: ResolversTypes['Github_ReferencedSubject'] }>;
  Github_Contribution: ResolversTypes['Github_CreatedCommitContribution'] | ResolversTypes['Github_CreatedIssueContribution'] | ResolversTypes['Github_CreatedPullRequestContribution'] | ResolversTypes['Github_CreatedPullRequestReviewContribution'] | ResolversTypes['Github_CreatedRepositoryContribution'] | ResolversTypes['Github_JoinedGitHubContribution'] | ResolversTypes['Github_RestrictedContribution'];
  Github_ContributionCalendar: ResolverTypeWrapper<Github_ContributionCalendar>;
  Github_ContributionCalendarDay: ResolverTypeWrapper<Github_ContributionCalendarDay>;
  Github_ContributionCalendarMonth: ResolverTypeWrapper<Github_ContributionCalendarMonth>;
  Github_ContributionCalendarWeek: ResolverTypeWrapper<Github_ContributionCalendarWeek>;
  Github_ContributionLevel: Github_ContributionLevel;
  Github_ContributionOrder: Github_ContributionOrder;
  Github_ContributionsCollection: ResolverTypeWrapper<Omit<Github_ContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<ResolversTypes['Github_CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<ResolversTypes['Github_CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<ResolversTypes['Github_CreatedRepositoryOrRestrictedContribution']> }>;
  Github_ConvertProjectCardNoteToIssueInput: Github_ConvertProjectCardNoteToIssueInput;
  Github_ConvertProjectCardNoteToIssuePayload: ResolverTypeWrapper<Github_ConvertProjectCardNoteToIssuePayload>;
  Github_ConvertPullRequestToDraftInput: Github_ConvertPullRequestToDraftInput;
  Github_ConvertPullRequestToDraftPayload: ResolverTypeWrapper<Github_ConvertPullRequestToDraftPayload>;
  Github_ConvertToDraftEvent: ResolverTypeWrapper<Github_ConvertToDraftEvent>;
  Github_ConvertedNoteToIssueEvent: ResolverTypeWrapper<Github_ConvertedNoteToIssueEvent>;
  Github_ConvertedToDiscussionEvent: ResolverTypeWrapper<Github_ConvertedToDiscussionEvent>;
  Github_CopyProjectV2Input: Github_CopyProjectV2Input;
  Github_CopyProjectV2Payload: ResolverTypeWrapper<Github_CopyProjectV2Payload>;
  Github_CreateAttributionInvitationInput: Github_CreateAttributionInvitationInput;
  Github_CreateAttributionInvitationPayload: ResolverTypeWrapper<Omit<Github_CreateAttributionInvitationPayload, 'source' | 'target'> & { source?: Maybe<ResolversTypes['Github_Claimable']>, target?: Maybe<ResolversTypes['Github_Claimable']> }>;
  Github_CreateBranchProtectionRuleInput: Github_CreateBranchProtectionRuleInput;
  Github_CreateBranchProtectionRulePayload: ResolverTypeWrapper<Github_CreateBranchProtectionRulePayload>;
  Github_CreateCheckRunInput: Github_CreateCheckRunInput;
  Github_CreateCheckRunPayload: ResolverTypeWrapper<Github_CreateCheckRunPayload>;
  Github_CreateCheckSuiteInput: Github_CreateCheckSuiteInput;
  Github_CreateCheckSuitePayload: ResolverTypeWrapper<Github_CreateCheckSuitePayload>;
  Github_CreateCommitOnBranchInput: Github_CreateCommitOnBranchInput;
  Github_CreateCommitOnBranchPayload: ResolverTypeWrapper<Github_CreateCommitOnBranchPayload>;
  Github_CreateDeploymentInput: Github_CreateDeploymentInput;
  Github_CreateDeploymentPayload: ResolverTypeWrapper<Github_CreateDeploymentPayload>;
  Github_CreateDeploymentStatusInput: Github_CreateDeploymentStatusInput;
  Github_CreateDeploymentStatusPayload: ResolverTypeWrapper<Github_CreateDeploymentStatusPayload>;
  Github_CreateDiscussionInput: Github_CreateDiscussionInput;
  Github_CreateDiscussionPayload: ResolverTypeWrapper<Github_CreateDiscussionPayload>;
  Github_CreateEnterpriseOrganizationInput: Github_CreateEnterpriseOrganizationInput;
  Github_CreateEnterpriseOrganizationPayload: ResolverTypeWrapper<Github_CreateEnterpriseOrganizationPayload>;
  Github_CreateEnvironmentInput: Github_CreateEnvironmentInput;
  Github_CreateEnvironmentPayload: ResolverTypeWrapper<Github_CreateEnvironmentPayload>;
  Github_CreateIpAllowListEntryInput: Github_CreateIpAllowListEntryInput;
  Github_CreateIpAllowListEntryPayload: ResolverTypeWrapper<Github_CreateIpAllowListEntryPayload>;
  Github_CreateIssueInput: Github_CreateIssueInput;
  Github_CreateIssuePayload: ResolverTypeWrapper<Github_CreateIssuePayload>;
  Github_CreateLabelInput: Github_CreateLabelInput;
  Github_CreateLabelPayload: ResolverTypeWrapper<Github_CreateLabelPayload>;
  Github_CreateLinkedBranchInput: Github_CreateLinkedBranchInput;
  Github_CreateLinkedBranchPayload: ResolverTypeWrapper<Github_CreateLinkedBranchPayload>;
  Github_CreateMigrationSourceInput: Github_CreateMigrationSourceInput;
  Github_CreateMigrationSourcePayload: ResolverTypeWrapper<Github_CreateMigrationSourcePayload>;
  Github_CreateProjectInput: Github_CreateProjectInput;
  Github_CreateProjectPayload: ResolverTypeWrapper<Github_CreateProjectPayload>;
  Github_CreateProjectV2Input: Github_CreateProjectV2Input;
  Github_CreateProjectV2Payload: ResolverTypeWrapper<Github_CreateProjectV2Payload>;
  Github_CreatePullRequestInput: Github_CreatePullRequestInput;
  Github_CreatePullRequestPayload: ResolverTypeWrapper<Github_CreatePullRequestPayload>;
  Github_CreateRefInput: Github_CreateRefInput;
  Github_CreateRefPayload: ResolverTypeWrapper<Github_CreateRefPayload>;
  Github_CreateRepositoryInput: Github_CreateRepositoryInput;
  Github_CreateRepositoryPayload: ResolverTypeWrapper<Github_CreateRepositoryPayload>;
  Github_CreateSponsorsListingInput: Github_CreateSponsorsListingInput;
  Github_CreateSponsorsListingPayload: ResolverTypeWrapper<Github_CreateSponsorsListingPayload>;
  Github_CreateSponsorsTierInput: Github_CreateSponsorsTierInput;
  Github_CreateSponsorsTierPayload: ResolverTypeWrapper<Github_CreateSponsorsTierPayload>;
  Github_CreateSponsorshipInput: Github_CreateSponsorshipInput;
  Github_CreateSponsorshipPayload: ResolverTypeWrapper<Github_CreateSponsorshipPayload>;
  Github_CreateTeamDiscussionCommentInput: Github_CreateTeamDiscussionCommentInput;
  Github_CreateTeamDiscussionCommentPayload: ResolverTypeWrapper<Github_CreateTeamDiscussionCommentPayload>;
  Github_CreateTeamDiscussionInput: Github_CreateTeamDiscussionInput;
  Github_CreateTeamDiscussionPayload: ResolverTypeWrapper<Github_CreateTeamDiscussionPayload>;
  Github_CreatedCommitContribution: ResolverTypeWrapper<Github_CreatedCommitContribution>;
  Github_CreatedCommitContributionConnection: ResolverTypeWrapper<Github_CreatedCommitContributionConnection>;
  Github_CreatedCommitContributionEdge: ResolverTypeWrapper<Github_CreatedCommitContributionEdge>;
  Github_CreatedIssueContribution: ResolverTypeWrapper<Github_CreatedIssueContribution>;
  Github_CreatedIssueContributionConnection: ResolverTypeWrapper<Github_CreatedIssueContributionConnection>;
  Github_CreatedIssueContributionEdge: ResolverTypeWrapper<Github_CreatedIssueContributionEdge>;
  Github_CreatedIssueOrRestrictedContribution: ResolversTypes['Github_CreatedIssueContribution'] | ResolversTypes['Github_RestrictedContribution'];
  Github_CreatedPullRequestContribution: ResolverTypeWrapper<Github_CreatedPullRequestContribution>;
  Github_CreatedPullRequestContributionConnection: ResolverTypeWrapper<Github_CreatedPullRequestContributionConnection>;
  Github_CreatedPullRequestContributionEdge: ResolverTypeWrapper<Github_CreatedPullRequestContributionEdge>;
  Github_CreatedPullRequestOrRestrictedContribution: ResolversTypes['Github_CreatedPullRequestContribution'] | ResolversTypes['Github_RestrictedContribution'];
  Github_CreatedPullRequestReviewContribution: ResolverTypeWrapper<Github_CreatedPullRequestReviewContribution>;
  Github_CreatedPullRequestReviewContributionConnection: ResolverTypeWrapper<Github_CreatedPullRequestReviewContributionConnection>;
  Github_CreatedPullRequestReviewContributionEdge: ResolverTypeWrapper<Github_CreatedPullRequestReviewContributionEdge>;
  Github_CreatedRepositoryContribution: ResolverTypeWrapper<Github_CreatedRepositoryContribution>;
  Github_CreatedRepositoryContributionConnection: ResolverTypeWrapper<Github_CreatedRepositoryContributionConnection>;
  Github_CreatedRepositoryContributionEdge: ResolverTypeWrapper<Github_CreatedRepositoryContributionEdge>;
  Github_CreatedRepositoryOrRestrictedContribution: ResolversTypes['Github_CreatedRepositoryContribution'] | ResolversTypes['Github_RestrictedContribution'];
  Github_CrossReferencedEvent: ResolverTypeWrapper<Omit<Github_CrossReferencedEvent, 'source' | 'target'> & { source: ResolversTypes['Github_ReferencedSubject'], target: ResolversTypes['Github_ReferencedSubject'] }>;
  Date: ResolverTypeWrapper<Scalars['Date']>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  Github_DeclineTopicSuggestionInput: Github_DeclineTopicSuggestionInput;
  Github_DeclineTopicSuggestionPayload: ResolverTypeWrapper<Github_DeclineTopicSuggestionPayload>;
  Github_DefaultRepositoryPermissionField: Github_DefaultRepositoryPermissionField;
  Github_Deletable: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_GistComment'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'];
  Github_DeleteBranchProtectionRuleInput: Github_DeleteBranchProtectionRuleInput;
  Github_DeleteBranchProtectionRulePayload: ResolverTypeWrapper<Github_DeleteBranchProtectionRulePayload>;
  Github_DeleteDeploymentInput: Github_DeleteDeploymentInput;
  Github_DeleteDeploymentPayload: ResolverTypeWrapper<Github_DeleteDeploymentPayload>;
  Github_DeleteDiscussionCommentInput: Github_DeleteDiscussionCommentInput;
  Github_DeleteDiscussionCommentPayload: ResolverTypeWrapper<Github_DeleteDiscussionCommentPayload>;
  Github_DeleteDiscussionInput: Github_DeleteDiscussionInput;
  Github_DeleteDiscussionPayload: ResolverTypeWrapper<Github_DeleteDiscussionPayload>;
  Github_DeleteEnvironmentInput: Github_DeleteEnvironmentInput;
  Github_DeleteEnvironmentPayload: ResolverTypeWrapper<Github_DeleteEnvironmentPayload>;
  Github_DeleteIpAllowListEntryInput: Github_DeleteIpAllowListEntryInput;
  Github_DeleteIpAllowListEntryPayload: ResolverTypeWrapper<Github_DeleteIpAllowListEntryPayload>;
  Github_DeleteIssueCommentInput: Github_DeleteIssueCommentInput;
  Github_DeleteIssueCommentPayload: ResolverTypeWrapper<Github_DeleteIssueCommentPayload>;
  Github_DeleteIssueInput: Github_DeleteIssueInput;
  Github_DeleteIssuePayload: ResolverTypeWrapper<Github_DeleteIssuePayload>;
  Github_DeleteLabelInput: Github_DeleteLabelInput;
  Github_DeleteLabelPayload: ResolverTypeWrapper<Github_DeleteLabelPayload>;
  Github_DeleteLinkedBranchInput: Github_DeleteLinkedBranchInput;
  Github_DeleteLinkedBranchPayload: ResolverTypeWrapper<Github_DeleteLinkedBranchPayload>;
  Github_DeletePackageVersionInput: Github_DeletePackageVersionInput;
  Github_DeletePackageVersionPayload: ResolverTypeWrapper<Github_DeletePackageVersionPayload>;
  Github_DeleteProjectCardInput: Github_DeleteProjectCardInput;
  Github_DeleteProjectCardPayload: ResolverTypeWrapper<Github_DeleteProjectCardPayload>;
  Github_DeleteProjectColumnInput: Github_DeleteProjectColumnInput;
  Github_DeleteProjectColumnPayload: ResolverTypeWrapper<Github_DeleteProjectColumnPayload>;
  Github_DeleteProjectInput: Github_DeleteProjectInput;
  Github_DeleteProjectPayload: ResolverTypeWrapper<Github_DeleteProjectPayload>;
  Github_DeleteProjectV2Input: Github_DeleteProjectV2Input;
  Github_DeleteProjectV2ItemInput: Github_DeleteProjectV2ItemInput;
  Github_DeleteProjectV2ItemPayload: ResolverTypeWrapper<Github_DeleteProjectV2ItemPayload>;
  Github_DeleteProjectV2Payload: ResolverTypeWrapper<Github_DeleteProjectV2Payload>;
  Github_DeletePullRequestReviewCommentInput: Github_DeletePullRequestReviewCommentInput;
  Github_DeletePullRequestReviewCommentPayload: ResolverTypeWrapper<Github_DeletePullRequestReviewCommentPayload>;
  Github_DeletePullRequestReviewInput: Github_DeletePullRequestReviewInput;
  Github_DeletePullRequestReviewPayload: ResolverTypeWrapper<Github_DeletePullRequestReviewPayload>;
  Github_DeleteRefInput: Github_DeleteRefInput;
  Github_DeleteRefPayload: ResolverTypeWrapper<Github_DeleteRefPayload>;
  Github_DeleteTeamDiscussionCommentInput: Github_DeleteTeamDiscussionCommentInput;
  Github_DeleteTeamDiscussionCommentPayload: ResolverTypeWrapper<Github_DeleteTeamDiscussionCommentPayload>;
  Github_DeleteTeamDiscussionInput: Github_DeleteTeamDiscussionInput;
  Github_DeleteTeamDiscussionPayload: ResolverTypeWrapper<Github_DeleteTeamDiscussionPayload>;
  Github_DeleteVerifiableDomainInput: Github_DeleteVerifiableDomainInput;
  Github_DeleteVerifiableDomainPayload: ResolverTypeWrapper<Omit<Github_DeleteVerifiableDomainPayload, 'owner'> & { owner?: Maybe<ResolversTypes['Github_VerifiableDomainOwner']> }>;
  Github_DemilestonedEvent: ResolverTypeWrapper<Omit<Github_DemilestonedEvent, 'subject'> & { subject: ResolversTypes['Github_MilestoneItem'] }>;
  Github_DependabotUpdate: ResolverTypeWrapper<Github_DependabotUpdate>;
  Github_DependabotUpdateError: ResolverTypeWrapper<Github_DependabotUpdateError>;
  Github_DependencyGraphDependency: ResolverTypeWrapper<Github_DependencyGraphDependency>;
  Github_DependencyGraphDependencyConnection: ResolverTypeWrapper<Github_DependencyGraphDependencyConnection>;
  Github_DependencyGraphDependencyEdge: ResolverTypeWrapper<Github_DependencyGraphDependencyEdge>;
  Github_DependencyGraphEcosystem: Github_DependencyGraphEcosystem;
  Github_DependencyGraphManifest: ResolverTypeWrapper<Github_DependencyGraphManifest>;
  Github_DependencyGraphManifestConnection: ResolverTypeWrapper<Github_DependencyGraphManifestConnection>;
  Github_DependencyGraphManifestEdge: ResolverTypeWrapper<Github_DependencyGraphManifestEdge>;
  Github_DeployKey: ResolverTypeWrapper<Github_DeployKey>;
  Github_DeployKeyConnection: ResolverTypeWrapper<Github_DeployKeyConnection>;
  Github_DeployKeyEdge: ResolverTypeWrapper<Github_DeployKeyEdge>;
  Github_DeployedEvent: ResolverTypeWrapper<Github_DeployedEvent>;
  Github_Deployment: ResolverTypeWrapper<Github_Deployment>;
  Github_DeploymentConnection: ResolverTypeWrapper<Github_DeploymentConnection>;
  Github_DeploymentEdge: ResolverTypeWrapper<Github_DeploymentEdge>;
  Github_DeploymentEnvironmentChangedEvent: ResolverTypeWrapper<Github_DeploymentEnvironmentChangedEvent>;
  Github_DeploymentOrder: Github_DeploymentOrder;
  Github_DeploymentOrderField: Github_DeploymentOrderField;
  Github_DeploymentProtectionRule: ResolverTypeWrapper<Github_DeploymentProtectionRule>;
  Github_DeploymentProtectionRuleConnection: ResolverTypeWrapper<Github_DeploymentProtectionRuleConnection>;
  Github_DeploymentProtectionRuleEdge: ResolverTypeWrapper<Github_DeploymentProtectionRuleEdge>;
  Github_DeploymentProtectionRuleType: Github_DeploymentProtectionRuleType;
  Github_DeploymentRequest: ResolverTypeWrapper<Github_DeploymentRequest>;
  Github_DeploymentRequestConnection: ResolverTypeWrapper<Github_DeploymentRequestConnection>;
  Github_DeploymentRequestEdge: ResolverTypeWrapper<Github_DeploymentRequestEdge>;
  Github_DeploymentReview: ResolverTypeWrapper<Github_DeploymentReview>;
  Github_DeploymentReviewConnection: ResolverTypeWrapper<Github_DeploymentReviewConnection>;
  Github_DeploymentReviewEdge: ResolverTypeWrapper<Github_DeploymentReviewEdge>;
  Github_DeploymentReviewState: Github_DeploymentReviewState;
  Github_DeploymentReviewer: ResolversTypes['Github_Team'] | ResolversTypes['Github_User'];
  Github_DeploymentReviewerConnection: ResolverTypeWrapper<Omit<Github_DeploymentReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_DeploymentReviewer']>>> }>;
  Github_DeploymentReviewerEdge: ResolverTypeWrapper<Omit<Github_DeploymentReviewerEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_DeploymentReviewer']> }>;
  Github_DeploymentState: Github_DeploymentState;
  Github_DeploymentStatus: ResolverTypeWrapper<Github_DeploymentStatus>;
  Github_DeploymentStatusConnection: ResolverTypeWrapper<Github_DeploymentStatusConnection>;
  Github_DeploymentStatusEdge: ResolverTypeWrapper<Github_DeploymentStatusEdge>;
  Github_DeploymentStatusState: Github_DeploymentStatusState;
  Github_DiffSide: Github_DiffSide;
  Github_DisablePullRequestAutoMergeInput: Github_DisablePullRequestAutoMergeInput;
  Github_DisablePullRequestAutoMergePayload: ResolverTypeWrapper<Github_DisablePullRequestAutoMergePayload>;
  Github_DisconnectedEvent: ResolverTypeWrapper<Omit<Github_DisconnectedEvent, 'source' | 'subject'> & { source: ResolversTypes['Github_ReferencedSubject'], subject: ResolversTypes['Github_ReferencedSubject'] }>;
  Github_Discussion: ResolverTypeWrapper<Github_Discussion>;
  Github_DiscussionCategory: ResolverTypeWrapper<Github_DiscussionCategory>;
  Github_DiscussionCategoryConnection: ResolverTypeWrapper<Github_DiscussionCategoryConnection>;
  Github_DiscussionCategoryEdge: ResolverTypeWrapper<Github_DiscussionCategoryEdge>;
  Github_DiscussionComment: ResolverTypeWrapper<Github_DiscussionComment>;
  Github_DiscussionCommentConnection: ResolverTypeWrapper<Github_DiscussionCommentConnection>;
  Github_DiscussionCommentEdge: ResolverTypeWrapper<Github_DiscussionCommentEdge>;
  Github_DiscussionConnection: ResolverTypeWrapper<Github_DiscussionConnection>;
  Github_DiscussionEdge: ResolverTypeWrapper<Github_DiscussionEdge>;
  Github_DiscussionOrder: Github_DiscussionOrder;
  Github_DiscussionOrderField: Github_DiscussionOrderField;
  Github_DiscussionPoll: ResolverTypeWrapper<Github_DiscussionPoll>;
  Github_DiscussionPollOption: ResolverTypeWrapper<Github_DiscussionPollOption>;
  Github_DiscussionPollOptionConnection: ResolverTypeWrapper<Github_DiscussionPollOptionConnection>;
  Github_DiscussionPollOptionEdge: ResolverTypeWrapper<Github_DiscussionPollOptionEdge>;
  Github_DiscussionPollOptionOrder: Github_DiscussionPollOptionOrder;
  Github_DiscussionPollOptionOrderField: Github_DiscussionPollOptionOrderField;
  Github_DismissPullRequestReviewInput: Github_DismissPullRequestReviewInput;
  Github_DismissPullRequestReviewPayload: ResolverTypeWrapper<Github_DismissPullRequestReviewPayload>;
  Github_DismissReason: Github_DismissReason;
  Github_DismissRepositoryVulnerabilityAlertInput: Github_DismissRepositoryVulnerabilityAlertInput;
  Github_DismissRepositoryVulnerabilityAlertPayload: ResolverTypeWrapper<Github_DismissRepositoryVulnerabilityAlertPayload>;
  Github_DraftIssue: ResolverTypeWrapper<Github_DraftIssue>;
  Github_DraftPullRequestReviewComment: Github_DraftPullRequestReviewComment;
  Github_DraftPullRequestReviewThread: Github_DraftPullRequestReviewThread;
  Github_EnablePullRequestAutoMergeInput: Github_EnablePullRequestAutoMergeInput;
  Github_EnablePullRequestAutoMergePayload: ResolverTypeWrapper<Github_EnablePullRequestAutoMergePayload>;
  Github_Enterprise: ResolverTypeWrapper<Github_Enterprise>;
  Github_EnterpriseAdministratorConnection: ResolverTypeWrapper<Github_EnterpriseAdministratorConnection>;
  Github_EnterpriseAdministratorEdge: ResolverTypeWrapper<Github_EnterpriseAdministratorEdge>;
  Github_EnterpriseAdministratorInvitation: ResolverTypeWrapper<Github_EnterpriseAdministratorInvitation>;
  Github_EnterpriseAdministratorInvitationConnection: ResolverTypeWrapper<Github_EnterpriseAdministratorInvitationConnection>;
  Github_EnterpriseAdministratorInvitationEdge: ResolverTypeWrapper<Github_EnterpriseAdministratorInvitationEdge>;
  Github_EnterpriseAdministratorInvitationOrder: Github_EnterpriseAdministratorInvitationOrder;
  Github_EnterpriseAdministratorInvitationOrderField: Github_EnterpriseAdministratorInvitationOrderField;
  Github_EnterpriseAdministratorRole: Github_EnterpriseAdministratorRole;
  Github_EnterpriseAllowPrivateRepositoryForkingPolicyValue: Github_EnterpriseAllowPrivateRepositoryForkingPolicyValue;
  Github_EnterpriseAuditEntryData: ResolversTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'];
  Github_EnterpriseBillingInfo: ResolverTypeWrapper<Github_EnterpriseBillingInfo>;
  Github_EnterpriseDefaultRepositoryPermissionSettingValue: Github_EnterpriseDefaultRepositoryPermissionSettingValue;
  Github_EnterpriseEnabledDisabledSettingValue: Github_EnterpriseEnabledDisabledSettingValue;
  Github_EnterpriseEnabledSettingValue: Github_EnterpriseEnabledSettingValue;
  Github_EnterpriseFailedInvitationConnection: ResolverTypeWrapper<Github_EnterpriseFailedInvitationConnection>;
  Github_EnterpriseFailedInvitationEdge: ResolverTypeWrapper<Github_EnterpriseFailedInvitationEdge>;
  Github_EnterpriseIdentityProvider: ResolverTypeWrapper<Github_EnterpriseIdentityProvider>;
  Github_EnterpriseMember: ResolversTypes['Github_EnterpriseUserAccount'] | ResolversTypes['Github_User'];
  Github_EnterpriseMemberConnection: ResolverTypeWrapper<Omit<Github_EnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseMember']>>> }>;
  Github_EnterpriseMemberEdge: ResolverTypeWrapper<Omit<Github_EnterpriseMemberEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_EnterpriseMember']> }>;
  Github_EnterpriseMemberOrder: Github_EnterpriseMemberOrder;
  Github_EnterpriseMemberOrderField: Github_EnterpriseMemberOrderField;
  Github_EnterpriseMembersCanCreateRepositoriesSettingValue: Github_EnterpriseMembersCanCreateRepositoriesSettingValue;
  Github_EnterpriseMembersCanMakePurchasesSettingValue: Github_EnterpriseMembersCanMakePurchasesSettingValue;
  Github_EnterpriseOrganizationMembershipConnection: ResolverTypeWrapper<Github_EnterpriseOrganizationMembershipConnection>;
  Github_EnterpriseOrganizationMembershipEdge: ResolverTypeWrapper<Github_EnterpriseOrganizationMembershipEdge>;
  Github_EnterpriseOutsideCollaboratorConnection: ResolverTypeWrapper<Github_EnterpriseOutsideCollaboratorConnection>;
  Github_EnterpriseOutsideCollaboratorEdge: ResolverTypeWrapper<Github_EnterpriseOutsideCollaboratorEdge>;
  Github_EnterpriseOwnerInfo: ResolverTypeWrapper<Github_EnterpriseOwnerInfo>;
  Github_EnterprisePendingMemberInvitationConnection: ResolverTypeWrapper<Github_EnterprisePendingMemberInvitationConnection>;
  Github_EnterprisePendingMemberInvitationEdge: ResolverTypeWrapper<Github_EnterprisePendingMemberInvitationEdge>;
  Github_EnterpriseRepositoryInfo: ResolverTypeWrapper<Github_EnterpriseRepositoryInfo>;
  Github_EnterpriseRepositoryInfoConnection: ResolverTypeWrapper<Github_EnterpriseRepositoryInfoConnection>;
  Github_EnterpriseRepositoryInfoEdge: ResolverTypeWrapper<Github_EnterpriseRepositoryInfoEdge>;
  Github_EnterpriseServerInstallation: ResolverTypeWrapper<Github_EnterpriseServerInstallation>;
  Github_EnterpriseServerInstallationConnection: ResolverTypeWrapper<Github_EnterpriseServerInstallationConnection>;
  Github_EnterpriseServerInstallationEdge: ResolverTypeWrapper<Github_EnterpriseServerInstallationEdge>;
  Github_EnterpriseServerInstallationOrder: Github_EnterpriseServerInstallationOrder;
  Github_EnterpriseServerInstallationOrderField: Github_EnterpriseServerInstallationOrderField;
  Github_EnterpriseServerUserAccount: ResolverTypeWrapper<Github_EnterpriseServerUserAccount>;
  Github_EnterpriseServerUserAccountConnection: ResolverTypeWrapper<Github_EnterpriseServerUserAccountConnection>;
  Github_EnterpriseServerUserAccountEdge: ResolverTypeWrapper<Github_EnterpriseServerUserAccountEdge>;
  Github_EnterpriseServerUserAccountEmail: ResolverTypeWrapper<Github_EnterpriseServerUserAccountEmail>;
  Github_EnterpriseServerUserAccountEmailConnection: ResolverTypeWrapper<Github_EnterpriseServerUserAccountEmailConnection>;
  Github_EnterpriseServerUserAccountEmailEdge: ResolverTypeWrapper<Github_EnterpriseServerUserAccountEmailEdge>;
  Github_EnterpriseServerUserAccountEmailOrder: Github_EnterpriseServerUserAccountEmailOrder;
  Github_EnterpriseServerUserAccountEmailOrderField: Github_EnterpriseServerUserAccountEmailOrderField;
  Github_EnterpriseServerUserAccountOrder: Github_EnterpriseServerUserAccountOrder;
  Github_EnterpriseServerUserAccountOrderField: Github_EnterpriseServerUserAccountOrderField;
  Github_EnterpriseServerUserAccountsUpload: ResolverTypeWrapper<Github_EnterpriseServerUserAccountsUpload>;
  Github_EnterpriseServerUserAccountsUploadConnection: ResolverTypeWrapper<Github_EnterpriseServerUserAccountsUploadConnection>;
  Github_EnterpriseServerUserAccountsUploadEdge: ResolverTypeWrapper<Github_EnterpriseServerUserAccountsUploadEdge>;
  Github_EnterpriseServerUserAccountsUploadOrder: Github_EnterpriseServerUserAccountsUploadOrder;
  Github_EnterpriseServerUserAccountsUploadOrderField: Github_EnterpriseServerUserAccountsUploadOrderField;
  Github_EnterpriseServerUserAccountsUploadSyncState: Github_EnterpriseServerUserAccountsUploadSyncState;
  Github_EnterpriseUserAccount: ResolverTypeWrapper<Github_EnterpriseUserAccount>;
  Github_EnterpriseUserAccountMembershipRole: Github_EnterpriseUserAccountMembershipRole;
  Github_EnterpriseUserDeployment: Github_EnterpriseUserDeployment;
  Github_Environment: ResolverTypeWrapper<Github_Environment>;
  Github_EnvironmentConnection: ResolverTypeWrapper<Github_EnvironmentConnection>;
  Github_EnvironmentEdge: ResolverTypeWrapper<Github_EnvironmentEdge>;
  Github_ExternalIdentity: ResolverTypeWrapper<Github_ExternalIdentity>;
  Github_ExternalIdentityAttribute: ResolverTypeWrapper<Github_ExternalIdentityAttribute>;
  Github_ExternalIdentityConnection: ResolverTypeWrapper<Github_ExternalIdentityConnection>;
  Github_ExternalIdentityEdge: ResolverTypeWrapper<Github_ExternalIdentityEdge>;
  Github_ExternalIdentitySamlAttributes: ResolverTypeWrapper<Github_ExternalIdentitySamlAttributes>;
  Github_ExternalIdentityScimAttributes: ResolverTypeWrapper<Github_ExternalIdentityScimAttributes>;
  Github_FileAddition: Github_FileAddition;
  Github_FileChanges: Github_FileChanges;
  Github_FileDeletion: Github_FileDeletion;
  Github_FileViewedState: Github_FileViewedState;
  Github_FollowOrganizationInput: Github_FollowOrganizationInput;
  Github_FollowOrganizationPayload: ResolverTypeWrapper<Github_FollowOrganizationPayload>;
  Github_FollowUserInput: Github_FollowUserInput;
  Github_FollowUserPayload: ResolverTypeWrapper<Github_FollowUserPayload>;
  Github_FollowerConnection: ResolverTypeWrapper<Github_FollowerConnection>;
  Github_FollowingConnection: ResolverTypeWrapper<Github_FollowingConnection>;
  Github_FundingLink: ResolverTypeWrapper<Github_FundingLink>;
  Github_FundingPlatform: Github_FundingPlatform;
  Github_GenericHovercardContext: ResolverTypeWrapper<Github_GenericHovercardContext>;
  Github_Gist: ResolverTypeWrapper<Github_Gist>;
  Github_GistComment: ResolverTypeWrapper<Github_GistComment>;
  Github_GistCommentConnection: ResolverTypeWrapper<Github_GistCommentConnection>;
  Github_GistCommentEdge: ResolverTypeWrapper<Github_GistCommentEdge>;
  Github_GistConnection: ResolverTypeWrapper<Github_GistConnection>;
  Github_GistEdge: ResolverTypeWrapper<Github_GistEdge>;
  Github_GistFile: ResolverTypeWrapper<Github_GistFile>;
  Github_GistOrder: Github_GistOrder;
  Github_GistOrderField: Github_GistOrderField;
  Github_GistPrivacy: Github_GistPrivacy;
  Github_GitActor: ResolverTypeWrapper<Github_GitActor>;
  Github_GitActorConnection: ResolverTypeWrapper<Github_GitActorConnection>;
  Github_GitActorEdge: ResolverTypeWrapper<Github_GitActorEdge>;
  Github_GitHubMetadata: ResolverTypeWrapper<Github_GitHubMetadata>;
  Github_GitObject: ResolversTypes['Github_Blob'] | ResolversTypes['Github_Commit'] | ResolversTypes['Github_Tag'] | ResolversTypes['Github_Tree'];
  Github_GitObjectID: ResolverTypeWrapper<Scalars['Github_GitObjectID']>;
  Github_GitRefname: ResolverTypeWrapper<Scalars['Github_GitRefname']>;
  Github_GitSSHRemote: ResolverTypeWrapper<Scalars['Github_GitSSHRemote']>;
  Github_GitSignature: ResolversTypes['Github_GpgSignature'] | ResolversTypes['Github_SmimeSignature'] | ResolversTypes['Github_SshSignature'] | ResolversTypes['Github_UnknownSignature'];
  Github_GitSignatureState: Github_GitSignatureState;
  Github_GitTimestamp: ResolverTypeWrapper<Scalars['Github_GitTimestamp']>;
  Github_GpgSignature: ResolverTypeWrapper<Github_GpgSignature>;
  Github_GrantEnterpriseOrganizationsMigratorRoleInput: Github_GrantEnterpriseOrganizationsMigratorRoleInput;
  Github_GrantEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<Github_GrantEnterpriseOrganizationsMigratorRolePayload>;
  Github_GrantMigratorRoleInput: Github_GrantMigratorRoleInput;
  Github_GrantMigratorRolePayload: ResolverTypeWrapper<Github_GrantMigratorRolePayload>;
  Github_HTML: ResolverTypeWrapper<Scalars['Github_HTML']>;
  Github_HeadRefDeletedEvent: ResolverTypeWrapper<Github_HeadRefDeletedEvent>;
  Github_HeadRefForcePushedEvent: ResolverTypeWrapper<Github_HeadRefForcePushedEvent>;
  Github_HeadRefRestoredEvent: ResolverTypeWrapper<Github_HeadRefRestoredEvent>;
  Github_Hovercard: ResolverTypeWrapper<Github_Hovercard>;
  Github_HovercardContext: ResolversTypes['Github_GenericHovercardContext'] | ResolversTypes['Github_OrganizationTeamsHovercardContext'] | ResolversTypes['Github_OrganizationsHovercardContext'] | ResolversTypes['Github_ReviewStatusHovercardContext'] | ResolversTypes['Github_ViewerHovercardContext'];
  Github_IdentityProviderConfigurationState: Github_IdentityProviderConfigurationState;
  Github_ImportProjectInput: Github_ImportProjectInput;
  Github_ImportProjectPayload: ResolverTypeWrapper<Github_ImportProjectPayload>;
  Github_InviteEnterpriseAdminInput: Github_InviteEnterpriseAdminInput;
  Github_InviteEnterpriseAdminPayload: ResolverTypeWrapper<Github_InviteEnterpriseAdminPayload>;
  Github_IpAllowListEnabledSettingValue: Github_IpAllowListEnabledSettingValue;
  Github_IpAllowListEntry: ResolverTypeWrapper<Omit<Github_IpAllowListEntry, 'owner'> & { owner: ResolversTypes['Github_IpAllowListOwner'] }>;
  Github_IpAllowListEntryConnection: ResolverTypeWrapper<Github_IpAllowListEntryConnection>;
  Github_IpAllowListEntryEdge: ResolverTypeWrapper<Github_IpAllowListEntryEdge>;
  Github_IpAllowListEntryOrder: Github_IpAllowListEntryOrder;
  Github_IpAllowListEntryOrderField: Github_IpAllowListEntryOrderField;
  Github_IpAllowListForInstalledAppsEnabledSettingValue: Github_IpAllowListForInstalledAppsEnabledSettingValue;
  Github_IpAllowListOwner: ResolversTypes['Github_App'] | ResolversTypes['Github_Enterprise'] | ResolversTypes['Github_Organization'];
  Github_Issue: ResolverTypeWrapper<Github_Issue>;
  Github_IssueClosedStateReason: Github_IssueClosedStateReason;
  Github_IssueComment: ResolverTypeWrapper<Github_IssueComment>;
  Github_IssueCommentConnection: ResolverTypeWrapper<Github_IssueCommentConnection>;
  Github_IssueCommentEdge: ResolverTypeWrapper<Github_IssueCommentEdge>;
  Github_IssueCommentOrder: Github_IssueCommentOrder;
  Github_IssueCommentOrderField: Github_IssueCommentOrderField;
  Github_IssueConnection: ResolverTypeWrapper<Github_IssueConnection>;
  Github_IssueContributionsByRepository: ResolverTypeWrapper<Github_IssueContributionsByRepository>;
  Github_IssueEdge: ResolverTypeWrapper<Github_IssueEdge>;
  Github_IssueFilters: Github_IssueFilters;
  Github_IssueOrPullRequest: ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_IssueOrder: Github_IssueOrder;
  Github_IssueOrderField: Github_IssueOrderField;
  Github_IssueState: Github_IssueState;
  Github_IssueStateReason: Github_IssueStateReason;
  Github_IssueTemplate: ResolverTypeWrapper<Github_IssueTemplate>;
  Github_IssueTimelineConnection: ResolverTypeWrapper<Omit<Github_IssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_IssueTimelineItem']>>> }>;
  Github_IssueTimelineItem: ResolversTypes['Github_AssignedEvent'] | ResolversTypes['Github_ClosedEvent'] | ResolversTypes['Github_Commit'] | ResolversTypes['Github_CrossReferencedEvent'] | ResolversTypes['Github_DemilestonedEvent'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_LabeledEvent'] | ResolversTypes['Github_LockedEvent'] | ResolversTypes['Github_MilestonedEvent'] | ResolversTypes['Github_ReferencedEvent'] | ResolversTypes['Github_RenamedTitleEvent'] | ResolversTypes['Github_ReopenedEvent'] | ResolversTypes['Github_SubscribedEvent'] | ResolversTypes['Github_TransferredEvent'] | ResolversTypes['Github_UnassignedEvent'] | ResolversTypes['Github_UnlabeledEvent'] | ResolversTypes['Github_UnlockedEvent'] | ResolversTypes['Github_UnsubscribedEvent'] | ResolversTypes['Github_UserBlockedEvent'];
  Github_IssueTimelineItemEdge: ResolverTypeWrapper<Omit<Github_IssueTimelineItemEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_IssueTimelineItem']> }>;
  Github_IssueTimelineItems: ResolversTypes['Github_AddedToProjectEvent'] | ResolversTypes['Github_AssignedEvent'] | ResolversTypes['Github_ClosedEvent'] | ResolversTypes['Github_CommentDeletedEvent'] | ResolversTypes['Github_ConnectedEvent'] | ResolversTypes['Github_ConvertedNoteToIssueEvent'] | ResolversTypes['Github_ConvertedToDiscussionEvent'] | ResolversTypes['Github_CrossReferencedEvent'] | ResolversTypes['Github_DemilestonedEvent'] | ResolversTypes['Github_DisconnectedEvent'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_LabeledEvent'] | ResolversTypes['Github_LockedEvent'] | ResolversTypes['Github_MarkedAsDuplicateEvent'] | ResolversTypes['Github_MentionedEvent'] | ResolversTypes['Github_MilestonedEvent'] | ResolversTypes['Github_MovedColumnsInProjectEvent'] | ResolversTypes['Github_PinnedEvent'] | ResolversTypes['Github_ReferencedEvent'] | ResolversTypes['Github_RemovedFromProjectEvent'] | ResolversTypes['Github_RenamedTitleEvent'] | ResolversTypes['Github_ReopenedEvent'] | ResolversTypes['Github_SubscribedEvent'] | ResolversTypes['Github_TransferredEvent'] | ResolversTypes['Github_UnassignedEvent'] | ResolversTypes['Github_UnlabeledEvent'] | ResolversTypes['Github_UnlockedEvent'] | ResolversTypes['Github_UnmarkedAsDuplicateEvent'] | ResolversTypes['Github_UnpinnedEvent'] | ResolversTypes['Github_UnsubscribedEvent'] | ResolversTypes['Github_UserBlockedEvent'];
  Github_IssueTimelineItemsConnection: ResolverTypeWrapper<Omit<Github_IssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_IssueTimelineItems']>>> }>;
  Github_IssueTimelineItemsEdge: ResolverTypeWrapper<Omit<Github_IssueTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_IssueTimelineItems']> }>;
  Github_IssueTimelineItemsItemType: Github_IssueTimelineItemsItemType;
  Github_JoinedGitHubContribution: ResolverTypeWrapper<Github_JoinedGitHubContribution>;
  Github_Label: ResolverTypeWrapper<Github_Label>;
  Github_LabelConnection: ResolverTypeWrapper<Github_LabelConnection>;
  Github_LabelEdge: ResolverTypeWrapper<Github_LabelEdge>;
  Github_LabelOrder: Github_LabelOrder;
  Github_LabelOrderField: Github_LabelOrderField;
  Github_Labelable: ResolversTypes['Github_Discussion'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_LabeledEvent: ResolverTypeWrapper<Github_LabeledEvent>;
  Github_Language: ResolverTypeWrapper<Github_Language>;
  Github_LanguageConnection: ResolverTypeWrapper<Github_LanguageConnection>;
  Github_LanguageEdge: ResolverTypeWrapper<Github_LanguageEdge>;
  Github_LanguageOrder: Github_LanguageOrder;
  Github_LanguageOrderField: Github_LanguageOrderField;
  Github_License: ResolverTypeWrapper<Github_License>;
  Github_LicenseRule: ResolverTypeWrapper<Github_LicenseRule>;
  Github_LinkProjectV2ToRepositoryInput: Github_LinkProjectV2ToRepositoryInput;
  Github_LinkProjectV2ToRepositoryPayload: ResolverTypeWrapper<Github_LinkProjectV2ToRepositoryPayload>;
  Github_LinkProjectV2ToTeamInput: Github_LinkProjectV2ToTeamInput;
  Github_LinkProjectV2ToTeamPayload: ResolverTypeWrapper<Github_LinkProjectV2ToTeamPayload>;
  Github_LinkRepositoryToProjectInput: Github_LinkRepositoryToProjectInput;
  Github_LinkRepositoryToProjectPayload: ResolverTypeWrapper<Github_LinkRepositoryToProjectPayload>;
  Github_LinkedBranch: ResolverTypeWrapper<Github_LinkedBranch>;
  Github_LinkedBranchConnection: ResolverTypeWrapper<Github_LinkedBranchConnection>;
  Github_LinkedBranchEdge: ResolverTypeWrapper<Github_LinkedBranchEdge>;
  Github_LockLockableInput: Github_LockLockableInput;
  Github_LockLockablePayload: ResolverTypeWrapper<Github_LockLockablePayload>;
  Github_LockReason: Github_LockReason;
  Github_Lockable: ResolversTypes['Github_Discussion'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_LockedEvent: ResolverTypeWrapper<Github_LockedEvent>;
  Github_Mannequin: ResolverTypeWrapper<Github_Mannequin>;
  Github_MannequinConnection: ResolverTypeWrapper<Github_MannequinConnection>;
  Github_MannequinEdge: ResolverTypeWrapper<Github_MannequinEdge>;
  Github_MannequinOrder: Github_MannequinOrder;
  Github_MannequinOrderField: Github_MannequinOrderField;
  Github_MarkDiscussionCommentAsAnswerInput: Github_MarkDiscussionCommentAsAnswerInput;
  Github_MarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<Github_MarkDiscussionCommentAsAnswerPayload>;
  Github_MarkFileAsViewedInput: Github_MarkFileAsViewedInput;
  Github_MarkFileAsViewedPayload: ResolverTypeWrapper<Github_MarkFileAsViewedPayload>;
  Github_MarkPullRequestReadyForReviewInput: Github_MarkPullRequestReadyForReviewInput;
  Github_MarkPullRequestReadyForReviewPayload: ResolverTypeWrapper<Github_MarkPullRequestReadyForReviewPayload>;
  Github_MarkedAsDuplicateEvent: ResolverTypeWrapper<Omit<Github_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversTypes['Github_IssueOrPullRequest']>, duplicate?: Maybe<ResolversTypes['Github_IssueOrPullRequest']> }>;
  Github_MarketplaceCategory: ResolverTypeWrapper<Github_MarketplaceCategory>;
  Github_MarketplaceListing: ResolverTypeWrapper<Github_MarketplaceListing>;
  Github_MarketplaceListingConnection: ResolverTypeWrapper<Github_MarketplaceListingConnection>;
  Github_MarketplaceListingEdge: ResolverTypeWrapper<Github_MarketplaceListingEdge>;
  Github_MemberStatusable: ResolversTypes['Github_Organization'] | ResolversTypes['Github_Team'];
  Github_MembersCanDeleteReposClearAuditEntry: ResolverTypeWrapper<Omit<Github_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_MembersCanDeleteReposDisableAuditEntry: ResolverTypeWrapper<Omit<Github_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_MembersCanDeleteReposEnableAuditEntry: ResolverTypeWrapper<Omit<Github_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_MentionedEvent: ResolverTypeWrapper<Github_MentionedEvent>;
  Github_MergeBranchInput: Github_MergeBranchInput;
  Github_MergeBranchPayload: ResolverTypeWrapper<Github_MergeBranchPayload>;
  Github_MergeCommitMessage: Github_MergeCommitMessage;
  Github_MergeCommitTitle: Github_MergeCommitTitle;
  Github_MergePullRequestInput: Github_MergePullRequestInput;
  Github_MergePullRequestPayload: ResolverTypeWrapper<Github_MergePullRequestPayload>;
  Github_MergeStateStatus: Github_MergeStateStatus;
  Github_MergeableState: Github_MergeableState;
  Github_MergedEvent: ResolverTypeWrapper<Github_MergedEvent>;
  Github_Migration: ResolversTypes['Github_RepositoryMigration'];
  Github_MigrationSource: ResolverTypeWrapper<Github_MigrationSource>;
  Github_MigrationSourceType: Github_MigrationSourceType;
  Github_MigrationState: Github_MigrationState;
  Github_Milestone: ResolverTypeWrapper<Github_Milestone>;
  Github_MilestoneConnection: ResolverTypeWrapper<Github_MilestoneConnection>;
  Github_MilestoneEdge: ResolverTypeWrapper<Github_MilestoneEdge>;
  Github_MilestoneItem: ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_MilestoneOrder: Github_MilestoneOrder;
  Github_MilestoneOrderField: Github_MilestoneOrderField;
  Github_MilestoneState: Github_MilestoneState;
  Github_MilestonedEvent: ResolverTypeWrapper<Omit<Github_MilestonedEvent, 'subject'> & { subject: ResolversTypes['Github_MilestoneItem'] }>;
  Github_Minimizable: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_GistComment'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_PullRequestReviewComment'];
  Github_MinimizeCommentInput: Github_MinimizeCommentInput;
  Github_MinimizeCommentPayload: ResolverTypeWrapper<Github_MinimizeCommentPayload>;
  Github_MoveProjectCardInput: Github_MoveProjectCardInput;
  Github_MoveProjectCardPayload: ResolverTypeWrapper<Github_MoveProjectCardPayload>;
  Github_MoveProjectColumnInput: Github_MoveProjectColumnInput;
  Github_MoveProjectColumnPayload: ResolverTypeWrapper<Github_MoveProjectColumnPayload>;
  Github_MovedColumnsInProjectEvent: ResolverTypeWrapper<Github_MovedColumnsInProjectEvent>;
  Github_Node: ResolversTypes['Github_AddedToProjectEvent'] | ResolversTypes['Github_App'] | ResolversTypes['Github_AssignedEvent'] | ResolversTypes['Github_AutoMergeDisabledEvent'] | ResolversTypes['Github_AutoMergeEnabledEvent'] | ResolversTypes['Github_AutoRebaseEnabledEvent'] | ResolversTypes['Github_AutoSquashEnabledEvent'] | ResolversTypes['Github_AutomaticBaseChangeFailedEvent'] | ResolversTypes['Github_AutomaticBaseChangeSucceededEvent'] | ResolversTypes['Github_BaseRefChangedEvent'] | ResolversTypes['Github_BaseRefDeletedEvent'] | ResolversTypes['Github_BaseRefForcePushedEvent'] | ResolversTypes['Github_Blob'] | ResolversTypes['Github_Bot'] | ResolversTypes['Github_BranchProtectionRule'] | ResolversTypes['Github_BypassForcePushAllowance'] | ResolversTypes['Github_BypassPullRequestAllowance'] | ResolversTypes['Github_CWE'] | ResolversTypes['Github_CheckRun'] | ResolversTypes['Github_CheckSuite'] | ResolversTypes['Github_ClosedEvent'] | ResolversTypes['Github_CodeOfConduct'] | ResolversTypes['Github_CommentDeletedEvent'] | ResolversTypes['Github_Commit'] | ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_CommitCommentThread'] | ResolversTypes['Github_Comparison'] | ResolversTypes['Github_ConnectedEvent'] | ResolversTypes['Github_ConvertToDraftEvent'] | ResolversTypes['Github_ConvertedNoteToIssueEvent'] | ResolversTypes['Github_ConvertedToDiscussionEvent'] | ResolversTypes['Github_CrossReferencedEvent'] | ResolversTypes['Github_DemilestonedEvent'] | ResolversTypes['Github_DependencyGraphManifest'] | ResolversTypes['Github_DeployKey'] | ResolversTypes['Github_DeployedEvent'] | ResolversTypes['Github_Deployment'] | ResolversTypes['Github_DeploymentEnvironmentChangedEvent'] | ResolversTypes['Github_DeploymentReview'] | ResolversTypes['Github_DeploymentStatus'] | ResolversTypes['Github_DisconnectedEvent'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionCategory'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_DiscussionPoll'] | ResolversTypes['Github_DiscussionPollOption'] | ResolversTypes['Github_DraftIssue'] | ResolversTypes['Github_Enterprise'] | ResolversTypes['Github_EnterpriseAdministratorInvitation'] | ResolversTypes['Github_EnterpriseIdentityProvider'] | ResolversTypes['Github_EnterpriseRepositoryInfo'] | ResolversTypes['Github_EnterpriseServerInstallation'] | ResolversTypes['Github_EnterpriseServerUserAccount'] | ResolversTypes['Github_EnterpriseServerUserAccountEmail'] | ResolversTypes['Github_EnterpriseServerUserAccountsUpload'] | ResolversTypes['Github_EnterpriseUserAccount'] | ResolversTypes['Github_Environment'] | ResolversTypes['Github_ExternalIdentity'] | ResolversTypes['Github_Gist'] | ResolversTypes['Github_GistComment'] | ResolversTypes['Github_HeadRefDeletedEvent'] | ResolversTypes['Github_HeadRefForcePushedEvent'] | ResolversTypes['Github_HeadRefRestoredEvent'] | ResolversTypes['Github_IpAllowListEntry'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_Label'] | ResolversTypes['Github_LabeledEvent'] | ResolversTypes['Github_Language'] | ResolversTypes['Github_License'] | ResolversTypes['Github_LinkedBranch'] | ResolversTypes['Github_LockedEvent'] | ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_MarkedAsDuplicateEvent'] | ResolversTypes['Github_MarketplaceCategory'] | ResolversTypes['Github_MarketplaceListing'] | ResolversTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversTypes['Github_MentionedEvent'] | ResolversTypes['Github_MergedEvent'] | ResolversTypes['Github_MigrationSource'] | ResolversTypes['Github_Milestone'] | ResolversTypes['Github_MilestonedEvent'] | ResolversTypes['Github_MovedColumnsInProjectEvent'] | ResolversTypes['Github_OIDCProvider'] | ResolversTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversTypes['Github_OrgAddMemberAuditEntry'] | ResolversTypes['Github_OrgBlockUserAuditEntry'] | ResolversTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgCreateAuditEntry'] | ResolversTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgDisableSamlAuditEntry'] | ResolversTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgEnableSamlAuditEntry'] | ResolversTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgInviteMemberAuditEntry'] | ResolversTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversTypes['Github_OrgUnblockUserAuditEntry'] | ResolversTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_OrganizationIdentityProvider'] | ResolversTypes['Github_OrganizationInvitation'] | ResolversTypes['Github_OrganizationMigration'] | ResolversTypes['Github_Package'] | ResolversTypes['Github_PackageFile'] | ResolversTypes['Github_PackageTag'] | ResolversTypes['Github_PackageVersion'] | ResolversTypes['Github_PinnedDiscussion'] | ResolversTypes['Github_PinnedEvent'] | ResolversTypes['Github_PinnedIssue'] | ResolversTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversTypes['Github_Project'] | ResolversTypes['Github_ProjectCard'] | ResolversTypes['Github_ProjectColumn'] | ResolversTypes['Github_ProjectV2'] | ResolversTypes['Github_ProjectV2Field'] | ResolversTypes['Github_ProjectV2Item'] | ResolversTypes['Github_ProjectV2ItemFieldDateValue'] | ResolversTypes['Github_ProjectV2ItemFieldIterationValue'] | ResolversTypes['Github_ProjectV2ItemFieldNumberValue'] | ResolversTypes['Github_ProjectV2ItemFieldSingleSelectValue'] | ResolversTypes['Github_ProjectV2ItemFieldTextValue'] | ResolversTypes['Github_ProjectV2IterationField'] | ResolversTypes['Github_ProjectV2SingleSelectField'] | ResolversTypes['Github_ProjectV2View'] | ResolversTypes['Github_ProjectV2Workflow'] | ResolversTypes['Github_PublicKey'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestCommit'] | ResolversTypes['Github_PullRequestCommitCommentThread'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_PullRequestReviewThread'] | ResolversTypes['Github_PullRequestThread'] | ResolversTypes['Github_Push'] | ResolversTypes['Github_PushAllowance'] | ResolversTypes['Github_Reaction'] | ResolversTypes['Github_ReadyForReviewEvent'] | ResolversTypes['Github_Ref'] | ResolversTypes['Github_ReferencedEvent'] | ResolversTypes['Github_Release'] | ResolversTypes['Github_ReleaseAsset'] | ResolversTypes['Github_RemovedFromProjectEvent'] | ResolversTypes['Github_RenamedTitleEvent'] | ResolversTypes['Github_ReopenedEvent'] | ResolversTypes['Github_RepoAccessAuditEntry'] | ResolversTypes['Github_RepoAddMemberAuditEntry'] | ResolversTypes['Github_RepoAddTopicAuditEntry'] | ResolversTypes['Github_RepoArchivedAuditEntry'] | ResolversTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoCreateAuditEntry'] | ResolversTypes['Github_RepoDestroyAuditEntry'] | ResolversTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_RepositoryInvitation'] | ResolversTypes['Github_RepositoryMigration'] | ResolversTypes['Github_RepositoryTopic'] | ResolversTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversTypes['Github_RepositoryVulnerabilityAlert'] | ResolversTypes['Github_ReviewDismissalAllowance'] | ResolversTypes['Github_ReviewDismissedEvent'] | ResolversTypes['Github_ReviewRequest'] | ResolversTypes['Github_ReviewRequestRemovedEvent'] | ResolversTypes['Github_ReviewRequestedEvent'] | ResolversTypes['Github_SavedReply'] | ResolversTypes['Github_SecurityAdvisory'] | ResolversTypes['Github_SponsorsActivity'] | ResolversTypes['Github_SponsorsListing'] | ResolversTypes['Github_SponsorsListingFeaturedItem'] | ResolversTypes['Github_SponsorsTier'] | ResolversTypes['Github_Sponsorship'] | ResolversTypes['Github_SponsorshipNewsletter'] | ResolversTypes['Github_Status'] | ResolversTypes['Github_StatusCheckRollup'] | ResolversTypes['Github_StatusContext'] | ResolversTypes['Github_SubscribedEvent'] | ResolversTypes['Github_Tag'] | ResolversTypes['Github_Team'] | ResolversTypes['Github_TeamAddMemberAuditEntry'] | ResolversTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'] | ResolversTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversTypes['Github_TeamRemoveRepositoryAuditEntry'] | ResolversTypes['Github_Topic'] | ResolversTypes['Github_TransferredEvent'] | ResolversTypes['Github_Tree'] | ResolversTypes['Github_UnassignedEvent'] | ResolversTypes['Github_UnlabeledEvent'] | ResolversTypes['Github_UnlockedEvent'] | ResolversTypes['Github_UnmarkedAsDuplicateEvent'] | ResolversTypes['Github_UnpinnedEvent'] | ResolversTypes['Github_UnsubscribedEvent'] | ResolversTypes['Github_User'] | ResolversTypes['Github_UserBlockedEvent'] | ResolversTypes['Github_UserContentEdit'] | ResolversTypes['Github_UserStatus'] | ResolversTypes['Github_VerifiableDomain'] | ResolversTypes['Github_Workflow'] | ResolversTypes['Github_WorkflowRun'];
  Github_NotificationRestrictionSettingValue: Github_NotificationRestrictionSettingValue;
  Github_OIDCProvider: ResolverTypeWrapper<Github_OIDCProvider>;
  Github_OIDCProviderType: Github_OIDCProviderType;
  Github_OauthApplicationAuditEntryData: ResolversTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessRequestedAuditEntry'];
  Github_OauthApplicationCreateAuditEntry: ResolverTypeWrapper<Omit<Github_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OauthApplicationCreateAuditEntryState: Github_OauthApplicationCreateAuditEntryState;
  Github_OperationType: Github_OperationType;
  Github_OrderDirection: Github_OrderDirection;
  Github_OrgAddBillingManagerAuditEntry: ResolverTypeWrapper<Omit<Github_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgAddMemberAuditEntry: ResolverTypeWrapper<Omit<Github_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgAddMemberAuditEntryPermission: Github_OrgAddMemberAuditEntryPermission;
  Github_OrgBlockUserAuditEntry: ResolverTypeWrapper<Omit<Github_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<Github_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<Github_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgCreateAuditEntry: ResolverTypeWrapper<Omit<Github_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgCreateAuditEntryBillingPlan: Github_OrgCreateAuditEntryBillingPlan;
  Github_OrgDisableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<Github_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgDisableSamlAuditEntry: ResolverTypeWrapper<Omit<Github_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgDisableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<Github_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgEnableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<Github_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgEnableSamlAuditEntry: ResolverTypeWrapper<Omit<Github_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgEnableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<Github_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgEnterpriseOwnerOrder: Github_OrgEnterpriseOwnerOrder;
  Github_OrgEnterpriseOwnerOrderField: Github_OrgEnterpriseOwnerOrderField;
  Github_OrgInviteMemberAuditEntry: ResolverTypeWrapper<Omit<Github_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgInviteToBusinessAuditEntry: ResolverTypeWrapper<Omit<Github_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgOauthAppAccessApprovedAuditEntry: ResolverTypeWrapper<Omit<Github_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgOauthAppAccessDeniedAuditEntry: ResolverTypeWrapper<Omit<Github_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgOauthAppAccessRequestedAuditEntry: ResolverTypeWrapper<Omit<Github_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgRemoveBillingManagerAuditEntry: ResolverTypeWrapper<Omit<Github_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgRemoveBillingManagerAuditEntryReason: Github_OrgRemoveBillingManagerAuditEntryReason;
  Github_OrgRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<Github_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgRemoveMemberAuditEntryMembershipType: Github_OrgRemoveMemberAuditEntryMembershipType;
  Github_OrgRemoveMemberAuditEntryReason: Github_OrgRemoveMemberAuditEntryReason;
  Github_OrgRemoveOutsideCollaboratorAuditEntry: ResolverTypeWrapper<Omit<Github_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType: Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType;
  Github_OrgRemoveOutsideCollaboratorAuditEntryReason: Github_OrgRemoveOutsideCollaboratorAuditEntryReason;
  Github_OrgRestoreMemberAuditEntry: ResolverTypeWrapper<Omit<Github_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']>, restoredMemberships?: Maybe<Array<ResolversTypes['Github_OrgRestoreMemberAuditEntryMembership']>> }>;
  Github_OrgRestoreMemberAuditEntryMembership: ResolversTypes['Github_OrgRestoreMemberMembershipOrganizationAuditEntryData'] | ResolversTypes['Github_OrgRestoreMemberMembershipRepositoryAuditEntryData'] | ResolversTypes['Github_OrgRestoreMemberMembershipTeamAuditEntryData'];
  Github_OrgRestoreMemberMembershipOrganizationAuditEntryData: ResolverTypeWrapper<Github_OrgRestoreMemberMembershipOrganizationAuditEntryData>;
  Github_OrgRestoreMemberMembershipRepositoryAuditEntryData: ResolverTypeWrapper<Github_OrgRestoreMemberMembershipRepositoryAuditEntryData>;
  Github_OrgRestoreMemberMembershipTeamAuditEntryData: ResolverTypeWrapper<Github_OrgRestoreMemberMembershipTeamAuditEntryData>;
  Github_OrgUnblockUserAuditEntry: ResolverTypeWrapper<Omit<Github_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgUpdateDefaultRepositoryPermissionAuditEntry: ResolverTypeWrapper<Omit<Github_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
  Github_OrgUpdateMemberAuditEntry: ResolverTypeWrapper<Omit<Github_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgUpdateMemberAuditEntryPermission: Github_OrgUpdateMemberAuditEntryPermission;
  Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry: ResolverTypeWrapper<Omit<Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility;
  Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: ResolverTypeWrapper<Omit<Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_Organization: ResolverTypeWrapper<Github_Organization>;
  Github_OrganizationAuditEntry: ResolversTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversTypes['Github_OrgAddMemberAuditEntry'] | ResolversTypes['Github_OrgBlockUserAuditEntry'] | ResolversTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgCreateAuditEntry'] | ResolversTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgDisableSamlAuditEntry'] | ResolversTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgEnableSamlAuditEntry'] | ResolversTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgInviteMemberAuditEntry'] | ResolversTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversTypes['Github_OrgUnblockUserAuditEntry'] | ResolversTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversTypes['Github_RepoAccessAuditEntry'] | ResolversTypes['Github_RepoAddMemberAuditEntry'] | ResolversTypes['Github_RepoAddTopicAuditEntry'] | ResolversTypes['Github_RepoArchivedAuditEntry'] | ResolversTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoCreateAuditEntry'] | ResolversTypes['Github_RepoDestroyAuditEntry'] | ResolversTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversTypes['Github_TeamAddMemberAuditEntry'] | ResolversTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_OrganizationAuditEntryConnection: ResolverTypeWrapper<Omit<Github_OrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_OrganizationAuditEntry']>>> }>;
  Github_OrganizationAuditEntryData: ResolversTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversTypes['Github_OrgAddMemberAuditEntry'] | ResolversTypes['Github_OrgBlockUserAuditEntry'] | ResolversTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_OrgCreateAuditEntry'] | ResolversTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgDisableSamlAuditEntry'] | ResolversTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversTypes['Github_OrgEnableSamlAuditEntry'] | ResolversTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversTypes['Github_OrgInviteMemberAuditEntry'] | ResolversTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversTypes['Github_OrgRestoreMemberMembershipOrganizationAuditEntryData'] | ResolversTypes['Github_OrgUnblockUserAuditEntry'] | ResolversTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversTypes['Github_RepoAccessAuditEntry'] | ResolversTypes['Github_RepoAddMemberAuditEntry'] | ResolversTypes['Github_RepoAddTopicAuditEntry'] | ResolversTypes['Github_RepoArchivedAuditEntry'] | ResolversTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoCreateAuditEntry'] | ResolversTypes['Github_RepoDestroyAuditEntry'] | ResolversTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversTypes['Github_TeamAddMemberAuditEntry'] | ResolversTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_OrganizationAuditEntryEdge: ResolverTypeWrapper<Omit<Github_OrganizationAuditEntryEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_OrganizationAuditEntry']> }>;
  Github_OrganizationConnection: ResolverTypeWrapper<Github_OrganizationConnection>;
  Github_OrganizationEdge: ResolverTypeWrapper<Github_OrganizationEdge>;
  Github_OrganizationEnterpriseOwnerConnection: ResolverTypeWrapper<Github_OrganizationEnterpriseOwnerConnection>;
  Github_OrganizationEnterpriseOwnerEdge: ResolverTypeWrapper<Github_OrganizationEnterpriseOwnerEdge>;
  Github_OrganizationIdentityProvider: ResolverTypeWrapper<Github_OrganizationIdentityProvider>;
  Github_OrganizationInvitation: ResolverTypeWrapper<Github_OrganizationInvitation>;
  Github_OrganizationInvitationConnection: ResolverTypeWrapper<Github_OrganizationInvitationConnection>;
  Github_OrganizationInvitationEdge: ResolverTypeWrapper<Github_OrganizationInvitationEdge>;
  Github_OrganizationInvitationRole: Github_OrganizationInvitationRole;
  Github_OrganizationInvitationSource: Github_OrganizationInvitationSource;
  Github_OrganizationInvitationType: Github_OrganizationInvitationType;
  Github_OrganizationMemberConnection: ResolverTypeWrapper<Github_OrganizationMemberConnection>;
  Github_OrganizationMemberEdge: ResolverTypeWrapper<Github_OrganizationMemberEdge>;
  Github_OrganizationMemberRole: Github_OrganizationMemberRole;
  Github_OrganizationMembersCanCreateRepositoriesSettingValue: Github_OrganizationMembersCanCreateRepositoriesSettingValue;
  Github_OrganizationMigration: ResolverTypeWrapper<Github_OrganizationMigration>;
  Github_OrganizationMigrationState: Github_OrganizationMigrationState;
  Github_OrganizationOrUser: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_OrganizationOrder: Github_OrganizationOrder;
  Github_OrganizationOrderField: Github_OrganizationOrderField;
  Github_OrganizationTeamsHovercardContext: ResolverTypeWrapper<Github_OrganizationTeamsHovercardContext>;
  Github_OrganizationsHovercardContext: ResolverTypeWrapper<Github_OrganizationsHovercardContext>;
  Github_Package: ResolverTypeWrapper<Github_Package>;
  Github_PackageConnection: ResolverTypeWrapper<Github_PackageConnection>;
  Github_PackageEdge: ResolverTypeWrapper<Github_PackageEdge>;
  Github_PackageFile: ResolverTypeWrapper<Github_PackageFile>;
  Github_PackageFileConnection: ResolverTypeWrapper<Github_PackageFileConnection>;
  Github_PackageFileEdge: ResolverTypeWrapper<Github_PackageFileEdge>;
  Github_PackageFileOrder: Github_PackageFileOrder;
  Github_PackageFileOrderField: Github_PackageFileOrderField;
  Github_PackageOrder: Github_PackageOrder;
  Github_PackageOrderField: Github_PackageOrderField;
  Github_PackageOwner: ResolversTypes['Github_Organization'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_User'];
  Github_PackageStatistics: ResolverTypeWrapper<Github_PackageStatistics>;
  Github_PackageTag: ResolverTypeWrapper<Github_PackageTag>;
  Github_PackageType: Github_PackageType;
  Github_PackageVersion: ResolverTypeWrapper<Github_PackageVersion>;
  Github_PackageVersionConnection: ResolverTypeWrapper<Github_PackageVersionConnection>;
  Github_PackageVersionEdge: ResolverTypeWrapper<Github_PackageVersionEdge>;
  Github_PackageVersionOrder: Github_PackageVersionOrder;
  Github_PackageVersionOrderField: Github_PackageVersionOrderField;
  Github_PackageVersionStatistics: ResolverTypeWrapper<Github_PackageVersionStatistics>;
  Github_PageInfo: ResolverTypeWrapper<Github_PageInfo>;
  Github_PatchStatus: Github_PatchStatus;
  Github_PermissionGranter: ResolversTypes['Github_Organization'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_Team'];
  Github_PermissionSource: ResolverTypeWrapper<Omit<Github_PermissionSource, 'source'> & { source: ResolversTypes['Github_PermissionGranter'] }>;
  Github_PinIssueInput: Github_PinIssueInput;
  Github_PinIssuePayload: ResolverTypeWrapper<Github_PinIssuePayload>;
  Github_PinnableItem: ResolversTypes['Github_Gist'] | ResolversTypes['Github_Repository'];
  Github_PinnableItemConnection: ResolverTypeWrapper<Omit<Github_PinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_PinnableItem']>>> }>;
  Github_PinnableItemEdge: ResolverTypeWrapper<Omit<Github_PinnableItemEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_PinnableItem']> }>;
  Github_PinnableItemType: Github_PinnableItemType;
  Github_PinnedDiscussion: ResolverTypeWrapper<Github_PinnedDiscussion>;
  Github_PinnedDiscussionConnection: ResolverTypeWrapper<Github_PinnedDiscussionConnection>;
  Github_PinnedDiscussionEdge: ResolverTypeWrapper<Github_PinnedDiscussionEdge>;
  Github_PinnedDiscussionGradient: Github_PinnedDiscussionGradient;
  Github_PinnedDiscussionPattern: Github_PinnedDiscussionPattern;
  Github_PinnedEvent: ResolverTypeWrapper<Github_PinnedEvent>;
  Github_PinnedIssue: ResolverTypeWrapper<Github_PinnedIssue>;
  Github_PinnedIssueConnection: ResolverTypeWrapper<Github_PinnedIssueConnection>;
  Github_PinnedIssueEdge: ResolverTypeWrapper<Github_PinnedIssueEdge>;
  Github_PreciseDateTime: ResolverTypeWrapper<Scalars['Github_PreciseDateTime']>;
  Github_PrivateRepositoryForkingDisableAuditEntry: ResolverTypeWrapper<Omit<Github_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_PrivateRepositoryForkingEnableAuditEntry: ResolverTypeWrapper<Omit<Github_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_ProfileItemShowcase: ResolverTypeWrapper<Github_ProfileItemShowcase>;
  Github_ProfileOwner: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_Project: ResolverTypeWrapper<Github_Project>;
  Github_ProjectCard: ResolverTypeWrapper<Omit<Github_ProjectCard, 'content'> & { content?: Maybe<ResolversTypes['Github_ProjectCardItem']> }>;
  Github_ProjectCardArchivedState: Github_ProjectCardArchivedState;
  Github_ProjectCardConnection: ResolverTypeWrapper<Github_ProjectCardConnection>;
  Github_ProjectCardEdge: ResolverTypeWrapper<Github_ProjectCardEdge>;
  Github_ProjectCardImport: Github_ProjectCardImport;
  Github_ProjectCardItem: ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_ProjectCardState: Github_ProjectCardState;
  Github_ProjectColumn: ResolverTypeWrapper<Github_ProjectColumn>;
  Github_ProjectColumnConnection: ResolverTypeWrapper<Github_ProjectColumnConnection>;
  Github_ProjectColumnEdge: ResolverTypeWrapper<Github_ProjectColumnEdge>;
  Github_ProjectColumnImport: Github_ProjectColumnImport;
  Github_ProjectColumnPurpose: Github_ProjectColumnPurpose;
  Github_ProjectConnection: ResolverTypeWrapper<Github_ProjectConnection>;
  Github_ProjectEdge: ResolverTypeWrapper<Github_ProjectEdge>;
  Github_ProjectOrder: Github_ProjectOrder;
  Github_ProjectOrderField: Github_ProjectOrderField;
  Github_ProjectOwner: ResolversTypes['Github_Organization'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_User'];
  Github_ProjectProgress: ResolverTypeWrapper<Github_ProjectProgress>;
  Github_ProjectState: Github_ProjectState;
  Github_ProjectTemplate: Github_ProjectTemplate;
  Github_ProjectV2: ResolverTypeWrapper<Omit<Github_ProjectV2, 'field'> & { field?: Maybe<ResolversTypes['Github_ProjectV2FieldConfiguration']> }>;
  Github_ProjectV2Connection: ResolverTypeWrapper<Github_ProjectV2Connection>;
  Github_ProjectV2Edge: ResolverTypeWrapper<Github_ProjectV2Edge>;
  Github_ProjectV2Field: ResolverTypeWrapper<Github_ProjectV2Field>;
  Github_ProjectV2FieldCommon: ResolversTypes['Github_ProjectV2Field'] | ResolversTypes['Github_ProjectV2IterationField'] | ResolversTypes['Github_ProjectV2SingleSelectField'];
  Github_ProjectV2FieldConfiguration: ResolversTypes['Github_ProjectV2Field'] | ResolversTypes['Github_ProjectV2IterationField'] | ResolversTypes['Github_ProjectV2SingleSelectField'];
  Github_ProjectV2FieldConfigurationConnection: ResolverTypeWrapper<Omit<Github_ProjectV2FieldConfigurationConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2FieldConfiguration']>>> }>;
  Github_ProjectV2FieldConfigurationEdge: ResolverTypeWrapper<Omit<Github_ProjectV2FieldConfigurationEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_ProjectV2FieldConfiguration']> }>;
  Github_ProjectV2FieldConnection: ResolverTypeWrapper<Github_ProjectV2FieldConnection>;
  Github_ProjectV2FieldEdge: ResolverTypeWrapper<Github_ProjectV2FieldEdge>;
  Github_ProjectV2FieldOrder: Github_ProjectV2FieldOrder;
  Github_ProjectV2FieldOrderField: Github_ProjectV2FieldOrderField;
  Github_ProjectV2FieldType: Github_ProjectV2FieldType;
  Github_ProjectV2FieldValue: Github_ProjectV2FieldValue;
  Github_ProjectV2Filters: Github_ProjectV2Filters;
  Github_ProjectV2Item: ResolverTypeWrapper<Omit<Github_ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<ResolversTypes['Github_ProjectV2ItemContent']>, fieldValueByName?: Maybe<ResolversTypes['Github_ProjectV2ItemFieldValue']> }>;
  Github_ProjectV2ItemConnection: ResolverTypeWrapper<Github_ProjectV2ItemConnection>;
  Github_ProjectV2ItemContent: ResolversTypes['Github_DraftIssue'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_ProjectV2ItemEdge: ResolverTypeWrapper<Github_ProjectV2ItemEdge>;
  Github_ProjectV2ItemFieldDateValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldDateValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldIterationValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldIterationValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldLabelValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldLabelValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldMilestoneValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldMilestoneValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldNumberValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldNumberValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldPullRequestValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldPullRequestValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldRepositoryValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldRepositoryValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldReviewerValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldReviewerValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldSingleSelectValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldTextValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldTextValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldUserValue: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldUserValue, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2ItemFieldValue: ResolversTypes['Github_ProjectV2ItemFieldDateValue'] | ResolversTypes['Github_ProjectV2ItemFieldIterationValue'] | ResolversTypes['Github_ProjectV2ItemFieldLabelValue'] | ResolversTypes['Github_ProjectV2ItemFieldMilestoneValue'] | ResolversTypes['Github_ProjectV2ItemFieldNumberValue'] | ResolversTypes['Github_ProjectV2ItemFieldPullRequestValue'] | ResolversTypes['Github_ProjectV2ItemFieldRepositoryValue'] | ResolversTypes['Github_ProjectV2ItemFieldReviewerValue'] | ResolversTypes['Github_ProjectV2ItemFieldSingleSelectValue'] | ResolversTypes['Github_ProjectV2ItemFieldTextValue'] | ResolversTypes['Github_ProjectV2ItemFieldUserValue'];
  Github_ProjectV2ItemFieldValueCommon: ResolversTypes['Github_ProjectV2ItemFieldDateValue'] | ResolversTypes['Github_ProjectV2ItemFieldIterationValue'] | ResolversTypes['Github_ProjectV2ItemFieldNumberValue'] | ResolversTypes['Github_ProjectV2ItemFieldSingleSelectValue'] | ResolversTypes['Github_ProjectV2ItemFieldTextValue'];
  Github_ProjectV2ItemFieldValueConnection: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldValueConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2ItemFieldValue']>>> }>;
  Github_ProjectV2ItemFieldValueEdge: ResolverTypeWrapper<Omit<Github_ProjectV2ItemFieldValueEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_ProjectV2ItemFieldValue']> }>;
  Github_ProjectV2ItemFieldValueOrder: Github_ProjectV2ItemFieldValueOrder;
  Github_ProjectV2ItemFieldValueOrderField: Github_ProjectV2ItemFieldValueOrderField;
  Github_ProjectV2ItemOrder: Github_ProjectV2ItemOrder;
  Github_ProjectV2ItemOrderField: Github_ProjectV2ItemOrderField;
  Github_ProjectV2ItemType: Github_ProjectV2ItemType;
  Github_ProjectV2IterationField: ResolverTypeWrapper<Github_ProjectV2IterationField>;
  Github_ProjectV2IterationFieldConfiguration: ResolverTypeWrapper<Github_ProjectV2IterationFieldConfiguration>;
  Github_ProjectV2IterationFieldIteration: ResolverTypeWrapper<Github_ProjectV2IterationFieldIteration>;
  Github_ProjectV2Order: Github_ProjectV2Order;
  Github_ProjectV2OrderField: Github_ProjectV2OrderField;
  Github_ProjectV2Owner: ResolversTypes['Github_Issue'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_User'];
  Github_ProjectV2Recent: ResolversTypes['Github_Organization'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_User'];
  Github_ProjectV2SingleSelectField: ResolverTypeWrapper<Github_ProjectV2SingleSelectField>;
  Github_ProjectV2SingleSelectFieldOption: ResolverTypeWrapper<Github_ProjectV2SingleSelectFieldOption>;
  Github_ProjectV2SortBy: ResolverTypeWrapper<Github_ProjectV2SortBy>;
  Github_ProjectV2SortByConnection: ResolverTypeWrapper<Github_ProjectV2SortByConnection>;
  Github_ProjectV2SortByEdge: ResolverTypeWrapper<Github_ProjectV2SortByEdge>;
  Github_ProjectV2SortByField: ResolverTypeWrapper<Omit<Github_ProjectV2SortByField, 'field'> & { field: ResolversTypes['Github_ProjectV2FieldConfiguration'] }>;
  Github_ProjectV2SortByFieldConnection: ResolverTypeWrapper<Github_ProjectV2SortByFieldConnection>;
  Github_ProjectV2SortByFieldEdge: ResolverTypeWrapper<Github_ProjectV2SortByFieldEdge>;
  Github_ProjectV2State: Github_ProjectV2State;
  Github_ProjectV2View: ResolverTypeWrapper<Github_ProjectV2View>;
  Github_ProjectV2ViewConnection: ResolverTypeWrapper<Github_ProjectV2ViewConnection>;
  Github_ProjectV2ViewEdge: ResolverTypeWrapper<Github_ProjectV2ViewEdge>;
  Github_ProjectV2ViewLayout: Github_ProjectV2ViewLayout;
  Github_ProjectV2ViewOrder: Github_ProjectV2ViewOrder;
  Github_ProjectV2ViewOrderField: Github_ProjectV2ViewOrderField;
  Github_ProjectV2Workflow: ResolverTypeWrapper<Github_ProjectV2Workflow>;
  Github_ProjectV2WorkflowConnection: ResolverTypeWrapper<Github_ProjectV2WorkflowConnection>;
  Github_ProjectV2WorkflowEdge: ResolverTypeWrapper<Github_ProjectV2WorkflowEdge>;
  Github_ProjectV2WorkflowOrder: Github_ProjectV2WorkflowOrder;
  Github_ProjectV2WorkflowsOrderField: Github_ProjectV2WorkflowsOrderField;
  Github_PublicKey: ResolverTypeWrapper<Github_PublicKey>;
  Github_PublicKeyConnection: ResolverTypeWrapper<Github_PublicKeyConnection>;
  Github_PublicKeyEdge: ResolverTypeWrapper<Github_PublicKeyEdge>;
  Github_PublishSponsorsTierInput: Github_PublishSponsorsTierInput;
  Github_PublishSponsorsTierPayload: ResolverTypeWrapper<Github_PublishSponsorsTierPayload>;
  Github_PullRequest: ResolverTypeWrapper<Github_PullRequest>;
  Github_PullRequestChangedFile: ResolverTypeWrapper<Github_PullRequestChangedFile>;
  Github_PullRequestChangedFileConnection: ResolverTypeWrapper<Github_PullRequestChangedFileConnection>;
  Github_PullRequestChangedFileEdge: ResolverTypeWrapper<Github_PullRequestChangedFileEdge>;
  Github_PullRequestCommit: ResolverTypeWrapper<Github_PullRequestCommit>;
  Github_PullRequestCommitCommentThread: ResolverTypeWrapper<Github_PullRequestCommitCommentThread>;
  Github_PullRequestCommitConnection: ResolverTypeWrapper<Github_PullRequestCommitConnection>;
  Github_PullRequestCommitEdge: ResolverTypeWrapper<Github_PullRequestCommitEdge>;
  Github_PullRequestConnection: ResolverTypeWrapper<Github_PullRequestConnection>;
  Github_PullRequestContributionsByRepository: ResolverTypeWrapper<Github_PullRequestContributionsByRepository>;
  Github_PullRequestEdge: ResolverTypeWrapper<Github_PullRequestEdge>;
  Github_PullRequestMergeMethod: Github_PullRequestMergeMethod;
  Github_PullRequestOrder: Github_PullRequestOrder;
  Github_PullRequestOrderField: Github_PullRequestOrderField;
  Github_PullRequestReview: ResolverTypeWrapper<Github_PullRequestReview>;
  Github_PullRequestReviewComment: ResolverTypeWrapper<Github_PullRequestReviewComment>;
  Github_PullRequestReviewCommentConnection: ResolverTypeWrapper<Github_PullRequestReviewCommentConnection>;
  Github_PullRequestReviewCommentEdge: ResolverTypeWrapper<Github_PullRequestReviewCommentEdge>;
  Github_PullRequestReviewCommentState: Github_PullRequestReviewCommentState;
  Github_PullRequestReviewConnection: ResolverTypeWrapper<Github_PullRequestReviewConnection>;
  Github_PullRequestReviewContributionsByRepository: ResolverTypeWrapper<Github_PullRequestReviewContributionsByRepository>;
  Github_PullRequestReviewDecision: Github_PullRequestReviewDecision;
  Github_PullRequestReviewEdge: ResolverTypeWrapper<Github_PullRequestReviewEdge>;
  Github_PullRequestReviewEvent: Github_PullRequestReviewEvent;
  Github_PullRequestReviewState: Github_PullRequestReviewState;
  Github_PullRequestReviewThread: ResolverTypeWrapper<Github_PullRequestReviewThread>;
  Github_PullRequestReviewThreadConnection: ResolverTypeWrapper<Github_PullRequestReviewThreadConnection>;
  Github_PullRequestReviewThreadEdge: ResolverTypeWrapper<Github_PullRequestReviewThreadEdge>;
  Github_PullRequestRevisionMarker: ResolverTypeWrapper<Github_PullRequestRevisionMarker>;
  Github_PullRequestState: Github_PullRequestState;
  Github_PullRequestTemplate: ResolverTypeWrapper<Github_PullRequestTemplate>;
  Github_PullRequestThread: ResolverTypeWrapper<Github_PullRequestThread>;
  Github_PullRequestTimelineConnection: ResolverTypeWrapper<Omit<Github_PullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_PullRequestTimelineItem']>>> }>;
  Github_PullRequestTimelineItem: ResolversTypes['Github_AssignedEvent'] | ResolversTypes['Github_BaseRefDeletedEvent'] | ResolversTypes['Github_BaseRefForcePushedEvent'] | ResolversTypes['Github_ClosedEvent'] | ResolversTypes['Github_Commit'] | ResolversTypes['Github_CommitCommentThread'] | ResolversTypes['Github_CrossReferencedEvent'] | ResolversTypes['Github_DemilestonedEvent'] | ResolversTypes['Github_DeployedEvent'] | ResolversTypes['Github_DeploymentEnvironmentChangedEvent'] | ResolversTypes['Github_HeadRefDeletedEvent'] | ResolversTypes['Github_HeadRefForcePushedEvent'] | ResolversTypes['Github_HeadRefRestoredEvent'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_LabeledEvent'] | ResolversTypes['Github_LockedEvent'] | ResolversTypes['Github_MergedEvent'] | ResolversTypes['Github_MilestonedEvent'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_PullRequestReviewThread'] | ResolversTypes['Github_ReferencedEvent'] | ResolversTypes['Github_RenamedTitleEvent'] | ResolversTypes['Github_ReopenedEvent'] | ResolversTypes['Github_ReviewDismissedEvent'] | ResolversTypes['Github_ReviewRequestRemovedEvent'] | ResolversTypes['Github_ReviewRequestedEvent'] | ResolversTypes['Github_SubscribedEvent'] | ResolversTypes['Github_UnassignedEvent'] | ResolversTypes['Github_UnlabeledEvent'] | ResolversTypes['Github_UnlockedEvent'] | ResolversTypes['Github_UnsubscribedEvent'] | ResolversTypes['Github_UserBlockedEvent'];
  Github_PullRequestTimelineItemEdge: ResolverTypeWrapper<Omit<Github_PullRequestTimelineItemEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_PullRequestTimelineItem']> }>;
  Github_PullRequestTimelineItems: ResolversTypes['Github_AddedToProjectEvent'] | ResolversTypes['Github_AssignedEvent'] | ResolversTypes['Github_AutoMergeDisabledEvent'] | ResolversTypes['Github_AutoMergeEnabledEvent'] | ResolversTypes['Github_AutoRebaseEnabledEvent'] | ResolversTypes['Github_AutoSquashEnabledEvent'] | ResolversTypes['Github_AutomaticBaseChangeFailedEvent'] | ResolversTypes['Github_AutomaticBaseChangeSucceededEvent'] | ResolversTypes['Github_BaseRefChangedEvent'] | ResolversTypes['Github_BaseRefDeletedEvent'] | ResolversTypes['Github_BaseRefForcePushedEvent'] | ResolversTypes['Github_ClosedEvent'] | ResolversTypes['Github_CommentDeletedEvent'] | ResolversTypes['Github_ConnectedEvent'] | ResolversTypes['Github_ConvertToDraftEvent'] | ResolversTypes['Github_ConvertedNoteToIssueEvent'] | ResolversTypes['Github_ConvertedToDiscussionEvent'] | ResolversTypes['Github_CrossReferencedEvent'] | ResolversTypes['Github_DemilestonedEvent'] | ResolversTypes['Github_DeployedEvent'] | ResolversTypes['Github_DeploymentEnvironmentChangedEvent'] | ResolversTypes['Github_DisconnectedEvent'] | ResolversTypes['Github_HeadRefDeletedEvent'] | ResolversTypes['Github_HeadRefForcePushedEvent'] | ResolversTypes['Github_HeadRefRestoredEvent'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_LabeledEvent'] | ResolversTypes['Github_LockedEvent'] | ResolversTypes['Github_MarkedAsDuplicateEvent'] | ResolversTypes['Github_MentionedEvent'] | ResolversTypes['Github_MergedEvent'] | ResolversTypes['Github_MilestonedEvent'] | ResolversTypes['Github_MovedColumnsInProjectEvent'] | ResolversTypes['Github_PinnedEvent'] | ResolversTypes['Github_PullRequestCommit'] | ResolversTypes['Github_PullRequestCommitCommentThread'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewThread'] | ResolversTypes['Github_PullRequestRevisionMarker'] | ResolversTypes['Github_ReadyForReviewEvent'] | ResolversTypes['Github_ReferencedEvent'] | ResolversTypes['Github_RemovedFromProjectEvent'] | ResolversTypes['Github_RenamedTitleEvent'] | ResolversTypes['Github_ReopenedEvent'] | ResolversTypes['Github_ReviewDismissedEvent'] | ResolversTypes['Github_ReviewRequestRemovedEvent'] | ResolversTypes['Github_ReviewRequestedEvent'] | ResolversTypes['Github_SubscribedEvent'] | ResolversTypes['Github_TransferredEvent'] | ResolversTypes['Github_UnassignedEvent'] | ResolversTypes['Github_UnlabeledEvent'] | ResolversTypes['Github_UnlockedEvent'] | ResolversTypes['Github_UnmarkedAsDuplicateEvent'] | ResolversTypes['Github_UnpinnedEvent'] | ResolversTypes['Github_UnsubscribedEvent'] | ResolversTypes['Github_UserBlockedEvent'];
  Github_PullRequestTimelineItemsConnection: ResolverTypeWrapper<Omit<Github_PullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_PullRequestTimelineItems']>>> }>;
  Github_PullRequestTimelineItemsEdge: ResolverTypeWrapper<Omit<Github_PullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_PullRequestTimelineItems']> }>;
  Github_PullRequestTimelineItemsItemType: Github_PullRequestTimelineItemsItemType;
  Github_PullRequestUpdateState: Github_PullRequestUpdateState;
  Github_Push: ResolverTypeWrapper<Github_Push>;
  Github_PushAllowance: ResolverTypeWrapper<Omit<Github_PushAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['Github_PushAllowanceActor']> }>;
  Github_PushAllowanceActor: ResolversTypes['Github_App'] | ResolversTypes['Github_Team'] | ResolversTypes['Github_User'];
  Github_PushAllowanceConnection: ResolverTypeWrapper<Github_PushAllowanceConnection>;
  Github_PushAllowanceEdge: ResolverTypeWrapper<Github_PushAllowanceEdge>;
  Github_RateLimit: ResolverTypeWrapper<Github_RateLimit>;
  Github_Reactable: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_Release'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'];
  Github_ReactingUserConnection: ResolverTypeWrapper<Github_ReactingUserConnection>;
  Github_ReactingUserEdge: ResolverTypeWrapper<Github_ReactingUserEdge>;
  Github_Reaction: ResolverTypeWrapper<Github_Reaction>;
  Github_ReactionConnection: ResolverTypeWrapper<Github_ReactionConnection>;
  Github_ReactionContent: Github_ReactionContent;
  Github_ReactionEdge: ResolverTypeWrapper<Github_ReactionEdge>;
  Github_ReactionGroup: ResolverTypeWrapper<Github_ReactionGroup>;
  Github_ReactionOrder: Github_ReactionOrder;
  Github_ReactionOrderField: Github_ReactionOrderField;
  Github_Reactor: ResolversTypes['Github_Bot'] | ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_ReactorConnection: ResolverTypeWrapper<Omit<Github_ReactorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_Reactor']>>> }>;
  Github_ReactorEdge: ResolverTypeWrapper<Omit<Github_ReactorEdge, 'node'> & { node: ResolversTypes['Github_Reactor'] }>;
  Github_ReadyForReviewEvent: ResolverTypeWrapper<Github_ReadyForReviewEvent>;
  Github_Ref: ResolverTypeWrapper<Github_Ref>;
  Github_RefConnection: ResolverTypeWrapper<Github_RefConnection>;
  Github_RefEdge: ResolverTypeWrapper<Github_RefEdge>;
  Github_RefOrder: Github_RefOrder;
  Github_RefOrderField: Github_RefOrderField;
  Github_RefUpdate: Github_RefUpdate;
  Github_RefUpdateRule: ResolverTypeWrapper<Github_RefUpdateRule>;
  Github_ReferencedEvent: ResolverTypeWrapper<Omit<Github_ReferencedEvent, 'subject'> & { subject: ResolversTypes['Github_ReferencedSubject'] }>;
  Github_ReferencedSubject: ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput: Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: ResolverTypeWrapper<Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  Github_RegenerateVerifiableDomainTokenInput: Github_RegenerateVerifiableDomainTokenInput;
  Github_RegenerateVerifiableDomainTokenPayload: ResolverTypeWrapper<Github_RegenerateVerifiableDomainTokenPayload>;
  Github_RejectDeploymentsInput: Github_RejectDeploymentsInput;
  Github_RejectDeploymentsPayload: ResolverTypeWrapper<Github_RejectDeploymentsPayload>;
  Github_Release: ResolverTypeWrapper<Github_Release>;
  Github_ReleaseAsset: ResolverTypeWrapper<Github_ReleaseAsset>;
  Github_ReleaseAssetConnection: ResolverTypeWrapper<Github_ReleaseAssetConnection>;
  Github_ReleaseAssetEdge: ResolverTypeWrapper<Github_ReleaseAssetEdge>;
  Github_ReleaseConnection: ResolverTypeWrapper<Github_ReleaseConnection>;
  Github_ReleaseEdge: ResolverTypeWrapper<Github_ReleaseEdge>;
  Github_ReleaseOrder: Github_ReleaseOrder;
  Github_ReleaseOrderField: Github_ReleaseOrderField;
  Github_RemoveAssigneesFromAssignableInput: Github_RemoveAssigneesFromAssignableInput;
  Github_RemoveAssigneesFromAssignablePayload: ResolverTypeWrapper<Github_RemoveAssigneesFromAssignablePayload>;
  Github_RemoveEnterpriseAdminInput: Github_RemoveEnterpriseAdminInput;
  Github_RemoveEnterpriseAdminPayload: ResolverTypeWrapper<Github_RemoveEnterpriseAdminPayload>;
  Github_RemoveEnterpriseIdentityProviderInput: Github_RemoveEnterpriseIdentityProviderInput;
  Github_RemoveEnterpriseIdentityProviderPayload: ResolverTypeWrapper<Github_RemoveEnterpriseIdentityProviderPayload>;
  Github_RemoveEnterpriseMemberInput: Github_RemoveEnterpriseMemberInput;
  Github_RemoveEnterpriseMemberPayload: ResolverTypeWrapper<Github_RemoveEnterpriseMemberPayload>;
  Github_RemoveEnterpriseOrganizationInput: Github_RemoveEnterpriseOrganizationInput;
  Github_RemoveEnterpriseOrganizationPayload: ResolverTypeWrapper<Github_RemoveEnterpriseOrganizationPayload>;
  Github_RemoveEnterpriseSupportEntitlementInput: Github_RemoveEnterpriseSupportEntitlementInput;
  Github_RemoveEnterpriseSupportEntitlementPayload: ResolverTypeWrapper<Github_RemoveEnterpriseSupportEntitlementPayload>;
  Github_RemoveLabelsFromLabelableInput: Github_RemoveLabelsFromLabelableInput;
  Github_RemoveLabelsFromLabelablePayload: ResolverTypeWrapper<Github_RemoveLabelsFromLabelablePayload>;
  Github_RemoveOutsideCollaboratorInput: Github_RemoveOutsideCollaboratorInput;
  Github_RemoveOutsideCollaboratorPayload: ResolverTypeWrapper<Github_RemoveOutsideCollaboratorPayload>;
  Github_RemoveReactionInput: Github_RemoveReactionInput;
  Github_RemoveReactionPayload: ResolverTypeWrapper<Github_RemoveReactionPayload>;
  Github_RemoveStarInput: Github_RemoveStarInput;
  Github_RemoveStarPayload: ResolverTypeWrapper<Github_RemoveStarPayload>;
  Github_RemoveUpvoteInput: Github_RemoveUpvoteInput;
  Github_RemoveUpvotePayload: ResolverTypeWrapper<Github_RemoveUpvotePayload>;
  Github_RemovedFromProjectEvent: ResolverTypeWrapper<Github_RemovedFromProjectEvent>;
  Github_RenamedTitleEvent: ResolverTypeWrapper<Omit<Github_RenamedTitleEvent, 'subject'> & { subject: ResolversTypes['Github_RenamedTitleSubject'] }>;
  Github_RenamedTitleSubject: ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'];
  Github_ReopenIssueInput: Github_ReopenIssueInput;
  Github_ReopenIssuePayload: ResolverTypeWrapper<Github_ReopenIssuePayload>;
  Github_ReopenPullRequestInput: Github_ReopenPullRequestInput;
  Github_ReopenPullRequestPayload: ResolverTypeWrapper<Github_ReopenPullRequestPayload>;
  Github_ReopenedEvent: ResolverTypeWrapper<Github_ReopenedEvent>;
  Github_RepoAccessAuditEntry: ResolverTypeWrapper<Omit<Github_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoAccessAuditEntryVisibility: Github_RepoAccessAuditEntryVisibility;
  Github_RepoAddMemberAuditEntry: ResolverTypeWrapper<Omit<Github_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoAddMemberAuditEntryVisibility: Github_RepoAddMemberAuditEntryVisibility;
  Github_RepoAddTopicAuditEntry: ResolverTypeWrapper<Omit<Github_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoArchivedAuditEntry: ResolverTypeWrapper<Omit<Github_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoArchivedAuditEntryVisibility: Github_RepoArchivedAuditEntryVisibility;
  Github_RepoChangeMergeSettingAuditEntry: ResolverTypeWrapper<Omit<Github_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoChangeMergeSettingAuditEntryMergeType: Github_RepoChangeMergeSettingAuditEntryMergeType;
  Github_RepoConfigDisableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigDisableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigDisableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigEnableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigEnableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigEnableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigLockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoConfigUnlockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<Github_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoCreateAuditEntry: ResolverTypeWrapper<Omit<Github_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoCreateAuditEntryVisibility: Github_RepoCreateAuditEntryVisibility;
  Github_RepoDestroyAuditEntry: ResolverTypeWrapper<Omit<Github_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoDestroyAuditEntryVisibility: Github_RepoDestroyAuditEntryVisibility;
  Github_RepoRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<Github_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepoRemoveMemberAuditEntryVisibility: Github_RepoRemoveMemberAuditEntryVisibility;
  Github_RepoRemoveTopicAuditEntry: ResolverTypeWrapper<Omit<Github_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_ReportedContentClassifiers: Github_ReportedContentClassifiers;
  Github_Repository: ResolverTypeWrapper<Omit<Github_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<ResolversTypes['Github_IssueOrPullRequest']> }>;
  Github_RepositoryAffiliation: Github_RepositoryAffiliation;
  Github_RepositoryAuditEntryData: ResolversTypes['Github_OrgRestoreMemberMembershipRepositoryAuditEntryData'] | ResolversTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversTypes['Github_RepoAccessAuditEntry'] | ResolversTypes['Github_RepoAddMemberAuditEntry'] | ResolversTypes['Github_RepoAddTopicAuditEntry'] | ResolversTypes['Github_RepoArchivedAuditEntry'] | ResolversTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversTypes['Github_RepoCreateAuditEntry'] | ResolversTypes['Github_RepoDestroyAuditEntry'] | ResolversTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_RepositoryCodeowners: ResolverTypeWrapper<Github_RepositoryCodeowners>;
  Github_RepositoryCodeownersError: ResolverTypeWrapper<Github_RepositoryCodeownersError>;
  Github_RepositoryCollaboratorConnection: ResolverTypeWrapper<Github_RepositoryCollaboratorConnection>;
  Github_RepositoryCollaboratorEdge: ResolverTypeWrapper<Github_RepositoryCollaboratorEdge>;
  Github_RepositoryConnection: ResolverTypeWrapper<Github_RepositoryConnection>;
  Github_RepositoryContactLink: ResolverTypeWrapper<Github_RepositoryContactLink>;
  Github_RepositoryContributionType: Github_RepositoryContributionType;
  Github_RepositoryDiscussionAuthor: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_RepositoryDiscussionCommentAuthor: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_RepositoryEdge: ResolverTypeWrapper<Github_RepositoryEdge>;
  Github_RepositoryInfo: ResolversTypes['Github_Repository'];
  Github_RepositoryInteractionAbility: ResolverTypeWrapper<Github_RepositoryInteractionAbility>;
  Github_RepositoryInteractionLimit: Github_RepositoryInteractionLimit;
  Github_RepositoryInteractionLimitExpiry: Github_RepositoryInteractionLimitExpiry;
  Github_RepositoryInteractionLimitOrigin: Github_RepositoryInteractionLimitOrigin;
  Github_RepositoryInvitation: ResolverTypeWrapper<Github_RepositoryInvitation>;
  Github_RepositoryInvitationConnection: ResolverTypeWrapper<Github_RepositoryInvitationConnection>;
  Github_RepositoryInvitationEdge: ResolverTypeWrapper<Github_RepositoryInvitationEdge>;
  Github_RepositoryInvitationOrder: Github_RepositoryInvitationOrder;
  Github_RepositoryInvitationOrderField: Github_RepositoryInvitationOrderField;
  Github_RepositoryLockReason: Github_RepositoryLockReason;
  Github_RepositoryMigration: ResolverTypeWrapper<Github_RepositoryMigration>;
  Github_RepositoryMigrationConnection: ResolverTypeWrapper<Github_RepositoryMigrationConnection>;
  Github_RepositoryMigrationEdge: ResolverTypeWrapper<Github_RepositoryMigrationEdge>;
  Github_RepositoryMigrationOrder: Github_RepositoryMigrationOrder;
  Github_RepositoryMigrationOrderDirection: Github_RepositoryMigrationOrderDirection;
  Github_RepositoryMigrationOrderField: Github_RepositoryMigrationOrderField;
  Github_RepositoryNode: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_CommitCommentThread'] | ResolversTypes['Github_DependabotUpdate'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionCategory'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_PinnedDiscussion'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestCommitCommentThread'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_RepositoryVulnerabilityAlert'];
  Github_RepositoryOrder: Github_RepositoryOrder;
  Github_RepositoryOrderField: Github_RepositoryOrderField;
  Github_RepositoryOwner: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_RepositoryPermission: Github_RepositoryPermission;
  Github_RepositoryPrivacy: Github_RepositoryPrivacy;
  Github_RepositoryTopic: ResolverTypeWrapper<Github_RepositoryTopic>;
  Github_RepositoryTopicConnection: ResolverTypeWrapper<Github_RepositoryTopicConnection>;
  Github_RepositoryTopicEdge: ResolverTypeWrapper<Github_RepositoryTopicEdge>;
  Github_RepositoryVisibility: Github_RepositoryVisibility;
  Github_RepositoryVisibilityChangeDisableAuditEntry: ResolverTypeWrapper<Omit<Github_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepositoryVisibilityChangeEnableAuditEntry: ResolverTypeWrapper<Omit<Github_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_RepositoryVulnerabilityAlert: ResolverTypeWrapper<Github_RepositoryVulnerabilityAlert>;
  Github_RepositoryVulnerabilityAlertConnection: ResolverTypeWrapper<Github_RepositoryVulnerabilityAlertConnection>;
  Github_RepositoryVulnerabilityAlertDependencyScope: Github_RepositoryVulnerabilityAlertDependencyScope;
  Github_RepositoryVulnerabilityAlertEdge: ResolverTypeWrapper<Github_RepositoryVulnerabilityAlertEdge>;
  Github_RepositoryVulnerabilityAlertState: Github_RepositoryVulnerabilityAlertState;
  Github_RequestReviewsInput: Github_RequestReviewsInput;
  Github_RequestReviewsPayload: ResolverTypeWrapper<Github_RequestReviewsPayload>;
  Github_RequestableCheckStatusState: Github_RequestableCheckStatusState;
  Github_RequestedReviewer: ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_Team'] | ResolversTypes['Github_User'];
  Github_RequestedReviewerConnection: ResolverTypeWrapper<Omit<Github_RequestedReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_RequestedReviewer']>>> }>;
  Github_RequestedReviewerEdge: ResolverTypeWrapper<Omit<Github_RequestedReviewerEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_RequestedReviewer']> }>;
  Github_RequirableByPullRequest: ResolversTypes['Github_CheckRun'] | ResolversTypes['Github_StatusContext'];
  Github_RequiredStatusCheckDescription: ResolverTypeWrapper<Github_RequiredStatusCheckDescription>;
  Github_RequiredStatusCheckInput: Github_RequiredStatusCheckInput;
  Github_RerequestCheckSuiteInput: Github_RerequestCheckSuiteInput;
  Github_RerequestCheckSuitePayload: ResolverTypeWrapper<Github_RerequestCheckSuitePayload>;
  Github_ResolveReviewThreadInput: Github_ResolveReviewThreadInput;
  Github_ResolveReviewThreadPayload: ResolverTypeWrapper<Github_ResolveReviewThreadPayload>;
  Github_RestrictedContribution: ResolverTypeWrapper<Github_RestrictedContribution>;
  Github_RetireSponsorsTierInput: Github_RetireSponsorsTierInput;
  Github_RetireSponsorsTierPayload: ResolverTypeWrapper<Github_RetireSponsorsTierPayload>;
  Github_RevertPullRequestInput: Github_RevertPullRequestInput;
  Github_RevertPullRequestPayload: ResolverTypeWrapper<Github_RevertPullRequestPayload>;
  Github_ReviewDismissalAllowance: ResolverTypeWrapper<Omit<Github_ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<ResolversTypes['Github_ReviewDismissalAllowanceActor']> }>;
  Github_ReviewDismissalAllowanceActor: ResolversTypes['Github_App'] | ResolversTypes['Github_Team'] | ResolversTypes['Github_User'];
  Github_ReviewDismissalAllowanceConnection: ResolverTypeWrapper<Github_ReviewDismissalAllowanceConnection>;
  Github_ReviewDismissalAllowanceEdge: ResolverTypeWrapper<Github_ReviewDismissalAllowanceEdge>;
  Github_ReviewDismissedEvent: ResolverTypeWrapper<Github_ReviewDismissedEvent>;
  Github_ReviewRequest: ResolverTypeWrapper<Omit<Github_ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['Github_RequestedReviewer']> }>;
  Github_ReviewRequestConnection: ResolverTypeWrapper<Github_ReviewRequestConnection>;
  Github_ReviewRequestEdge: ResolverTypeWrapper<Github_ReviewRequestEdge>;
  Github_ReviewRequestRemovedEvent: ResolverTypeWrapper<Omit<Github_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['Github_RequestedReviewer']> }>;
  Github_ReviewRequestedEvent: ResolverTypeWrapper<Omit<Github_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversTypes['Github_RequestedReviewer']> }>;
  Github_ReviewStatusHovercardContext: ResolverTypeWrapper<Github_ReviewStatusHovercardContext>;
  Github_RevokeEnterpriseOrganizationsMigratorRoleInput: Github_RevokeEnterpriseOrganizationsMigratorRoleInput;
  Github_RevokeEnterpriseOrganizationsMigratorRolePayload: ResolverTypeWrapper<Github_RevokeEnterpriseOrganizationsMigratorRolePayload>;
  Github_RevokeMigratorRoleInput: Github_RevokeMigratorRoleInput;
  Github_RevokeMigratorRolePayload: ResolverTypeWrapper<Github_RevokeMigratorRolePayload>;
  Github_RoleInOrganization: Github_RoleInOrganization;
  Github_SamlDigestAlgorithm: Github_SamlDigestAlgorithm;
  Github_SamlSignatureAlgorithm: Github_SamlSignatureAlgorithm;
  Github_SavedReply: ResolverTypeWrapper<Github_SavedReply>;
  Github_SavedReplyConnection: ResolverTypeWrapper<Github_SavedReplyConnection>;
  Github_SavedReplyEdge: ResolverTypeWrapper<Github_SavedReplyEdge>;
  Github_SavedReplyOrder: Github_SavedReplyOrder;
  Github_SavedReplyOrderField: Github_SavedReplyOrderField;
  Github_SearchResultItem: ResolversTypes['Github_App'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_MarketplaceListing'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_User'];
  Github_SearchResultItemConnection: ResolverTypeWrapper<Omit<Github_SearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_SearchResultItem']>>> }>;
  Github_SearchResultItemEdge: ResolverTypeWrapper<Omit<Github_SearchResultItemEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_SearchResultItem']> }>;
  Github_SearchType: Github_SearchType;
  Github_SecurityAdvisory: ResolverTypeWrapper<Github_SecurityAdvisory>;
  Github_SecurityAdvisoryClassification: Github_SecurityAdvisoryClassification;
  Github_SecurityAdvisoryConnection: ResolverTypeWrapper<Github_SecurityAdvisoryConnection>;
  Github_SecurityAdvisoryEcosystem: Github_SecurityAdvisoryEcosystem;
  Github_SecurityAdvisoryEdge: ResolverTypeWrapper<Github_SecurityAdvisoryEdge>;
  Github_SecurityAdvisoryIdentifier: ResolverTypeWrapper<Github_SecurityAdvisoryIdentifier>;
  Github_SecurityAdvisoryIdentifierFilter: Github_SecurityAdvisoryIdentifierFilter;
  Github_SecurityAdvisoryIdentifierType: Github_SecurityAdvisoryIdentifierType;
  Github_SecurityAdvisoryOrder: Github_SecurityAdvisoryOrder;
  Github_SecurityAdvisoryOrderField: Github_SecurityAdvisoryOrderField;
  Github_SecurityAdvisoryPackage: ResolverTypeWrapper<Github_SecurityAdvisoryPackage>;
  Github_SecurityAdvisoryPackageVersion: ResolverTypeWrapper<Github_SecurityAdvisoryPackageVersion>;
  Github_SecurityAdvisoryReference: ResolverTypeWrapper<Github_SecurityAdvisoryReference>;
  Github_SecurityAdvisorySeverity: Github_SecurityAdvisorySeverity;
  Github_SecurityVulnerability: ResolverTypeWrapper<Github_SecurityVulnerability>;
  Github_SecurityVulnerabilityConnection: ResolverTypeWrapper<Github_SecurityVulnerabilityConnection>;
  Github_SecurityVulnerabilityEdge: ResolverTypeWrapper<Github_SecurityVulnerabilityEdge>;
  Github_SecurityVulnerabilityOrder: Github_SecurityVulnerabilityOrder;
  Github_SecurityVulnerabilityOrderField: Github_SecurityVulnerabilityOrderField;
  Github_SetEnterpriseIdentityProviderInput: Github_SetEnterpriseIdentityProviderInput;
  Github_SetEnterpriseIdentityProviderPayload: ResolverTypeWrapper<Github_SetEnterpriseIdentityProviderPayload>;
  Github_SetOrganizationInteractionLimitInput: Github_SetOrganizationInteractionLimitInput;
  Github_SetOrganizationInteractionLimitPayload: ResolverTypeWrapper<Github_SetOrganizationInteractionLimitPayload>;
  Github_SetRepositoryInteractionLimitInput: Github_SetRepositoryInteractionLimitInput;
  Github_SetRepositoryInteractionLimitPayload: ResolverTypeWrapper<Github_SetRepositoryInteractionLimitPayload>;
  Github_SetUserInteractionLimitInput: Github_SetUserInteractionLimitInput;
  Github_SetUserInteractionLimitPayload: ResolverTypeWrapper<Github_SetUserInteractionLimitPayload>;
  Github_SmimeSignature: ResolverTypeWrapper<Github_SmimeSignature>;
  Github_Sponsor: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_SponsorConnection: ResolverTypeWrapper<Omit<Github_SponsorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_Sponsor']>>> }>;
  Github_SponsorEdge: ResolverTypeWrapper<Omit<Github_SponsorEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_Sponsor']> }>;
  Github_SponsorOrder: Github_SponsorOrder;
  Github_SponsorOrderField: Github_SponsorOrderField;
  Github_Sponsorable: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_SponsorableItem: ResolversTypes['Github_Organization'] | ResolversTypes['Github_User'];
  Github_SponsorableItemConnection: ResolverTypeWrapper<Omit<Github_SponsorableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_SponsorableItem']>>> }>;
  Github_SponsorableItemEdge: ResolverTypeWrapper<Omit<Github_SponsorableItemEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_SponsorableItem']> }>;
  Github_SponsorableOrder: Github_SponsorableOrder;
  Github_SponsorableOrderField: Github_SponsorableOrderField;
  Github_SponsorsActivity: ResolverTypeWrapper<Omit<Github_SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<ResolversTypes['Github_Sponsor']> }>;
  Github_SponsorsActivityAction: Github_SponsorsActivityAction;
  Github_SponsorsActivityConnection: ResolverTypeWrapper<Github_SponsorsActivityConnection>;
  Github_SponsorsActivityEdge: ResolverTypeWrapper<Github_SponsorsActivityEdge>;
  Github_SponsorsActivityOrder: Github_SponsorsActivityOrder;
  Github_SponsorsActivityOrderField: Github_SponsorsActivityOrderField;
  Github_SponsorsActivityPeriod: Github_SponsorsActivityPeriod;
  Github_SponsorsCountryOrRegionCode: Github_SponsorsCountryOrRegionCode;
  Github_SponsorsGoal: ResolverTypeWrapper<Github_SponsorsGoal>;
  Github_SponsorsGoalKind: Github_SponsorsGoalKind;
  Github_SponsorsListing: ResolverTypeWrapper<Github_SponsorsListing>;
  Github_SponsorsListingFeatureableItem: ResolversTypes['Github_Repository'] | ResolversTypes['Github_User'];
  Github_SponsorsListingFeaturedItem: ResolverTypeWrapper<Omit<Github_SponsorsListingFeaturedItem, 'featureable'> & { featureable: ResolversTypes['Github_SponsorsListingFeatureableItem'] }>;
  Github_SponsorsListingFeaturedItemFeatureableType: Github_SponsorsListingFeaturedItemFeatureableType;
  Github_SponsorsTier: ResolverTypeWrapper<Github_SponsorsTier>;
  Github_SponsorsTierAdminInfo: ResolverTypeWrapper<Github_SponsorsTierAdminInfo>;
  Github_SponsorsTierConnection: ResolverTypeWrapper<Github_SponsorsTierConnection>;
  Github_SponsorsTierEdge: ResolverTypeWrapper<Github_SponsorsTierEdge>;
  Github_SponsorsTierOrder: Github_SponsorsTierOrder;
  Github_SponsorsTierOrderField: Github_SponsorsTierOrderField;
  Github_Sponsorship: ResolverTypeWrapper<Omit<Github_Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<ResolversTypes['Github_Sponsor']> }>;
  Github_SponsorshipConnection: ResolverTypeWrapper<Github_SponsorshipConnection>;
  Github_SponsorshipEdge: ResolverTypeWrapper<Github_SponsorshipEdge>;
  Github_SponsorshipNewsletter: ResolverTypeWrapper<Github_SponsorshipNewsletter>;
  Github_SponsorshipNewsletterConnection: ResolverTypeWrapper<Github_SponsorshipNewsletterConnection>;
  Github_SponsorshipNewsletterEdge: ResolverTypeWrapper<Github_SponsorshipNewsletterEdge>;
  Github_SponsorshipNewsletterOrder: Github_SponsorshipNewsletterOrder;
  Github_SponsorshipNewsletterOrderField: Github_SponsorshipNewsletterOrderField;
  Github_SponsorshipOrder: Github_SponsorshipOrder;
  Github_SponsorshipOrderField: Github_SponsorshipOrderField;
  Github_SponsorshipPrivacy: Github_SponsorshipPrivacy;
  Github_SquashMergeCommitMessage: Github_SquashMergeCommitMessage;
  Github_SquashMergeCommitTitle: Github_SquashMergeCommitTitle;
  Github_SshSignature: ResolverTypeWrapper<Github_SshSignature>;
  Github_StarOrder: Github_StarOrder;
  Github_StarOrderField: Github_StarOrderField;
  Github_StargazerConnection: ResolverTypeWrapper<Github_StargazerConnection>;
  Github_StargazerEdge: ResolverTypeWrapper<Github_StargazerEdge>;
  Github_Starrable: ResolversTypes['Github_Gist'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_Topic'];
  Github_StarredRepositoryConnection: ResolverTypeWrapper<Github_StarredRepositoryConnection>;
  Github_StarredRepositoryEdge: ResolverTypeWrapper<Github_StarredRepositoryEdge>;
  Github_StartOrganizationMigrationInput: Github_StartOrganizationMigrationInput;
  Github_StartOrganizationMigrationPayload: ResolverTypeWrapper<Github_StartOrganizationMigrationPayload>;
  Github_StartRepositoryMigrationInput: Github_StartRepositoryMigrationInput;
  Github_StartRepositoryMigrationPayload: ResolverTypeWrapper<Github_StartRepositoryMigrationPayload>;
  Github_Status: ResolverTypeWrapper<Github_Status>;
  Github_StatusCheckRollup: ResolverTypeWrapper<Github_StatusCheckRollup>;
  Github_StatusCheckRollupContext: ResolversTypes['Github_CheckRun'] | ResolversTypes['Github_StatusContext'];
  Github_StatusCheckRollupContextConnection: ResolverTypeWrapper<Omit<Github_StatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversTypes['Github_StatusCheckRollupContext']>>> }>;
  Github_StatusCheckRollupContextEdge: ResolverTypeWrapper<Omit<Github_StatusCheckRollupContextEdge, 'node'> & { node?: Maybe<ResolversTypes['Github_StatusCheckRollupContext']> }>;
  Github_StatusContext: ResolverTypeWrapper<Github_StatusContext>;
  Github_StatusContextStateCount: ResolverTypeWrapper<Github_StatusContextStateCount>;
  Github_StatusState: Github_StatusState;
  Github_StripeConnectAccount: ResolverTypeWrapper<Github_StripeConnectAccount>;
  Github_SubmitPullRequestReviewInput: Github_SubmitPullRequestReviewInput;
  Github_SubmitPullRequestReviewPayload: ResolverTypeWrapper<Github_SubmitPullRequestReviewPayload>;
  Github_Submodule: ResolverTypeWrapper<Github_Submodule>;
  Github_SubmoduleConnection: ResolverTypeWrapper<Github_SubmoduleConnection>;
  Github_SubmoduleEdge: ResolverTypeWrapper<Github_SubmoduleEdge>;
  Github_Subscribable: ResolversTypes['Github_Commit'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_Team'] | ResolversTypes['Github_TeamDiscussion'];
  Github_SubscribedEvent: ResolverTypeWrapper<Github_SubscribedEvent>;
  Github_SubscriptionState: Github_SubscriptionState;
  Github_SuggestedReviewer: ResolverTypeWrapper<Github_SuggestedReviewer>;
  Github_Tag: ResolverTypeWrapper<Github_Tag>;
  Github_Team: ResolverTypeWrapper<Github_Team>;
  Github_TeamAddMemberAuditEntry: ResolverTypeWrapper<Omit<Github_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_TeamAddRepositoryAuditEntry: ResolverTypeWrapper<Omit<Github_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_TeamAuditEntryData: ResolversTypes['Github_OrgRestoreMemberMembershipTeamAuditEntryData'] | ResolversTypes['Github_TeamAddMemberAuditEntry'] | ResolversTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_TeamChangeParentTeamAuditEntry: ResolverTypeWrapper<Omit<Github_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_TeamConnection: ResolverTypeWrapper<Github_TeamConnection>;
  Github_TeamDiscussion: ResolverTypeWrapper<Github_TeamDiscussion>;
  Github_TeamDiscussionComment: ResolverTypeWrapper<Github_TeamDiscussionComment>;
  Github_TeamDiscussionCommentConnection: ResolverTypeWrapper<Github_TeamDiscussionCommentConnection>;
  Github_TeamDiscussionCommentEdge: ResolverTypeWrapper<Github_TeamDiscussionCommentEdge>;
  Github_TeamDiscussionCommentOrder: Github_TeamDiscussionCommentOrder;
  Github_TeamDiscussionCommentOrderField: Github_TeamDiscussionCommentOrderField;
  Github_TeamDiscussionConnection: ResolverTypeWrapper<Github_TeamDiscussionConnection>;
  Github_TeamDiscussionEdge: ResolverTypeWrapper<Github_TeamDiscussionEdge>;
  Github_TeamDiscussionOrder: Github_TeamDiscussionOrder;
  Github_TeamDiscussionOrderField: Github_TeamDiscussionOrderField;
  Github_TeamEdge: ResolverTypeWrapper<Github_TeamEdge>;
  Github_TeamMemberConnection: ResolverTypeWrapper<Github_TeamMemberConnection>;
  Github_TeamMemberEdge: ResolverTypeWrapper<Github_TeamMemberEdge>;
  Github_TeamMemberOrder: Github_TeamMemberOrder;
  Github_TeamMemberOrderField: Github_TeamMemberOrderField;
  Github_TeamMemberRole: Github_TeamMemberRole;
  Github_TeamMembershipType: Github_TeamMembershipType;
  Github_TeamOrder: Github_TeamOrder;
  Github_TeamOrderField: Github_TeamOrderField;
  Github_TeamPrivacy: Github_TeamPrivacy;
  Github_TeamRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<Github_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_TeamRemoveRepositoryAuditEntry: ResolverTypeWrapper<Omit<Github_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversTypes['Github_AuditEntryActor']> }>;
  Github_TeamRepositoryConnection: ResolverTypeWrapper<Github_TeamRepositoryConnection>;
  Github_TeamRepositoryEdge: ResolverTypeWrapper<Github_TeamRepositoryEdge>;
  Github_TeamRepositoryOrder: Github_TeamRepositoryOrder;
  Github_TeamRepositoryOrderField: Github_TeamRepositoryOrderField;
  Github_TeamReviewAssignmentAlgorithm: Github_TeamReviewAssignmentAlgorithm;
  Github_TeamRole: Github_TeamRole;
  Github_TextMatch: ResolverTypeWrapper<Github_TextMatch>;
  Github_TextMatchHighlight: ResolverTypeWrapper<Github_TextMatchHighlight>;
  Github_Topic: ResolverTypeWrapper<Github_Topic>;
  Github_TopicAuditEntryData: ResolversTypes['Github_RepoAddTopicAuditEntry'] | ResolversTypes['Github_RepoRemoveTopicAuditEntry'];
  Github_TopicSuggestionDeclineReason: Github_TopicSuggestionDeclineReason;
  Github_TrackedIssueStates: Github_TrackedIssueStates;
  Github_TransferEnterpriseOrganizationInput: Github_TransferEnterpriseOrganizationInput;
  Github_TransferEnterpriseOrganizationPayload: ResolverTypeWrapper<Github_TransferEnterpriseOrganizationPayload>;
  Github_TransferIssueInput: Github_TransferIssueInput;
  Github_TransferIssuePayload: ResolverTypeWrapper<Github_TransferIssuePayload>;
  Github_TransferredEvent: ResolverTypeWrapper<Github_TransferredEvent>;
  Github_Tree: ResolverTypeWrapper<Github_Tree>;
  Github_TreeEntry: ResolverTypeWrapper<Github_TreeEntry>;
  Github_URI: ResolverTypeWrapper<Scalars['Github_URI']>;
  Github_UnarchiveProjectV2ItemInput: Github_UnarchiveProjectV2ItemInput;
  Github_UnarchiveProjectV2ItemPayload: ResolverTypeWrapper<Github_UnarchiveProjectV2ItemPayload>;
  Github_UnarchiveRepositoryInput: Github_UnarchiveRepositoryInput;
  Github_UnarchiveRepositoryPayload: ResolverTypeWrapper<Github_UnarchiveRepositoryPayload>;
  Github_UnassignedEvent: ResolverTypeWrapper<Omit<Github_UnassignedEvent, 'assignee'> & { assignee?: Maybe<ResolversTypes['Github_Assignee']> }>;
  Github_UnfollowOrganizationInput: Github_UnfollowOrganizationInput;
  Github_UnfollowOrganizationPayload: ResolverTypeWrapper<Github_UnfollowOrganizationPayload>;
  Github_UnfollowUserInput: Github_UnfollowUserInput;
  Github_UnfollowUserPayload: ResolverTypeWrapper<Github_UnfollowUserPayload>;
  Github_UniformResourceLocatable: ResolversTypes['Github_Bot'] | ResolversTypes['Github_CheckRun'] | ResolversTypes['Github_ClosedEvent'] | ResolversTypes['Github_Commit'] | ResolversTypes['Github_ConvertToDraftEvent'] | ResolversTypes['Github_CrossReferencedEvent'] | ResolversTypes['Github_Gist'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_Mannequin'] | ResolversTypes['Github_MergedEvent'] | ResolversTypes['Github_Milestone'] | ResolversTypes['Github_Organization'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestCommit'] | ResolversTypes['Github_ReadyForReviewEvent'] | ResolversTypes['Github_Release'] | ResolversTypes['Github_Repository'] | ResolversTypes['Github_RepositoryTopic'] | ResolversTypes['Github_ReviewDismissedEvent'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'] | ResolversTypes['Github_User'] | ResolversTypes['Github_WorkflowRun'];
  Github_UnknownSignature: ResolverTypeWrapper<Github_UnknownSignature>;
  Github_UnlabeledEvent: ResolverTypeWrapper<Github_UnlabeledEvent>;
  Github_UnlinkProjectV2FromRepositoryInput: Github_UnlinkProjectV2FromRepositoryInput;
  Github_UnlinkProjectV2FromRepositoryPayload: ResolverTypeWrapper<Github_UnlinkProjectV2FromRepositoryPayload>;
  Github_UnlinkProjectV2FromTeamInput: Github_UnlinkProjectV2FromTeamInput;
  Github_UnlinkProjectV2FromTeamPayload: ResolverTypeWrapper<Github_UnlinkProjectV2FromTeamPayload>;
  Github_UnlinkRepositoryFromProjectInput: Github_UnlinkRepositoryFromProjectInput;
  Github_UnlinkRepositoryFromProjectPayload: ResolverTypeWrapper<Github_UnlinkRepositoryFromProjectPayload>;
  Github_UnlockLockableInput: Github_UnlockLockableInput;
  Github_UnlockLockablePayload: ResolverTypeWrapper<Github_UnlockLockablePayload>;
  Github_UnlockedEvent: ResolverTypeWrapper<Github_UnlockedEvent>;
  Github_UnmarkDiscussionCommentAsAnswerInput: Github_UnmarkDiscussionCommentAsAnswerInput;
  Github_UnmarkDiscussionCommentAsAnswerPayload: ResolverTypeWrapper<Github_UnmarkDiscussionCommentAsAnswerPayload>;
  Github_UnmarkFileAsViewedInput: Github_UnmarkFileAsViewedInput;
  Github_UnmarkFileAsViewedPayload: ResolverTypeWrapper<Github_UnmarkFileAsViewedPayload>;
  Github_UnmarkIssueAsDuplicateInput: Github_UnmarkIssueAsDuplicateInput;
  Github_UnmarkIssueAsDuplicatePayload: ResolverTypeWrapper<Omit<Github_UnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<ResolversTypes['Github_IssueOrPullRequest']> }>;
  Github_UnmarkedAsDuplicateEvent: ResolverTypeWrapper<Omit<Github_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversTypes['Github_IssueOrPullRequest']>, duplicate?: Maybe<ResolversTypes['Github_IssueOrPullRequest']> }>;
  Github_UnminimizeCommentInput: Github_UnminimizeCommentInput;
  Github_UnminimizeCommentPayload: ResolverTypeWrapper<Github_UnminimizeCommentPayload>;
  Github_UnpinIssueInput: Github_UnpinIssueInput;
  Github_UnpinIssuePayload: ResolverTypeWrapper<Github_UnpinIssuePayload>;
  Github_UnpinnedEvent: ResolverTypeWrapper<Github_UnpinnedEvent>;
  Github_UnresolveReviewThreadInput: Github_UnresolveReviewThreadInput;
  Github_UnresolveReviewThreadPayload: ResolverTypeWrapper<Github_UnresolveReviewThreadPayload>;
  Github_UnsubscribedEvent: ResolverTypeWrapper<Github_UnsubscribedEvent>;
  Github_Updatable: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_GistComment'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_Project'] | ResolversTypes['Github_ProjectV2'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'];
  Github_UpdatableComment: ResolversTypes['Github_CommitComment'] | ResolversTypes['Github_DiscussionComment'] | ResolversTypes['Github_GistComment'] | ResolversTypes['Github_Issue'] | ResolversTypes['Github_IssueComment'] | ResolversTypes['Github_PullRequest'] | ResolversTypes['Github_PullRequestReview'] | ResolversTypes['Github_PullRequestReviewComment'] | ResolversTypes['Github_TeamDiscussion'] | ResolversTypes['Github_TeamDiscussionComment'];
  Github_UpdateBranchProtectionRuleInput: Github_UpdateBranchProtectionRuleInput;
  Github_UpdateBranchProtectionRulePayload: ResolverTypeWrapper<Github_UpdateBranchProtectionRulePayload>;
  Github_UpdateCheckRunInput: Github_UpdateCheckRunInput;
  Github_UpdateCheckRunPayload: ResolverTypeWrapper<Github_UpdateCheckRunPayload>;
  Github_UpdateCheckSuitePreferencesInput: Github_UpdateCheckSuitePreferencesInput;
  Github_UpdateCheckSuitePreferencesPayload: ResolverTypeWrapper<Github_UpdateCheckSuitePreferencesPayload>;
  Github_UpdateDiscussionCommentInput: Github_UpdateDiscussionCommentInput;
  Github_UpdateDiscussionCommentPayload: ResolverTypeWrapper<Github_UpdateDiscussionCommentPayload>;
  Github_UpdateDiscussionInput: Github_UpdateDiscussionInput;
  Github_UpdateDiscussionPayload: ResolverTypeWrapper<Github_UpdateDiscussionPayload>;
  Github_UpdateEnterpriseAdministratorRoleInput: Github_UpdateEnterpriseAdministratorRoleInput;
  Github_UpdateEnterpriseAdministratorRolePayload: ResolverTypeWrapper<Github_UpdateEnterpriseAdministratorRolePayload>;
  Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput: Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput: Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput: Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  Github_UpdateEnterpriseOrganizationProjectsSettingInput: Github_UpdateEnterpriseOrganizationProjectsSettingInput;
  Github_UpdateEnterpriseOrganizationProjectsSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseOrganizationProjectsSettingPayload>;
  Github_UpdateEnterpriseOwnerOrganizationRoleInput: Github_UpdateEnterpriseOwnerOrganizationRoleInput;
  Github_UpdateEnterpriseOwnerOrganizationRolePayload: ResolverTypeWrapper<Github_UpdateEnterpriseOwnerOrganizationRolePayload>;
  Github_UpdateEnterpriseProfileInput: Github_UpdateEnterpriseProfileInput;
  Github_UpdateEnterpriseProfilePayload: ResolverTypeWrapper<Github_UpdateEnterpriseProfilePayload>;
  Github_UpdateEnterpriseRepositoryProjectsSettingInput: Github_UpdateEnterpriseRepositoryProjectsSettingInput;
  Github_UpdateEnterpriseRepositoryProjectsSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseRepositoryProjectsSettingPayload>;
  Github_UpdateEnterpriseTeamDiscussionsSettingInput: Github_UpdateEnterpriseTeamDiscussionsSettingInput;
  Github_UpdateEnterpriseTeamDiscussionsSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseTeamDiscussionsSettingPayload>;
  Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: ResolverTypeWrapper<Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  Github_UpdateEnvironmentInput: Github_UpdateEnvironmentInput;
  Github_UpdateEnvironmentPayload: ResolverTypeWrapper<Github_UpdateEnvironmentPayload>;
  Github_UpdateIpAllowListEnabledSettingInput: Github_UpdateIpAllowListEnabledSettingInput;
  Github_UpdateIpAllowListEnabledSettingPayload: ResolverTypeWrapper<Omit<Github_UpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['Github_IpAllowListOwner']> }>;
  Github_UpdateIpAllowListEntryInput: Github_UpdateIpAllowListEntryInput;
  Github_UpdateIpAllowListEntryPayload: ResolverTypeWrapper<Github_UpdateIpAllowListEntryPayload>;
  Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput: Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload: ResolverTypeWrapper<Omit<Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['Github_IpAllowListOwner']> }>;
  Github_UpdateIssueCommentInput: Github_UpdateIssueCommentInput;
  Github_UpdateIssueCommentPayload: ResolverTypeWrapper<Github_UpdateIssueCommentPayload>;
  Github_UpdateIssueInput: Github_UpdateIssueInput;
  Github_UpdateIssuePayload: ResolverTypeWrapper<Github_UpdateIssuePayload>;
  Github_UpdateLabelInput: Github_UpdateLabelInput;
  Github_UpdateLabelPayload: ResolverTypeWrapper<Github_UpdateLabelPayload>;
  Github_UpdateNotificationRestrictionSettingInput: Github_UpdateNotificationRestrictionSettingInput;
  Github_UpdateNotificationRestrictionSettingPayload: ResolverTypeWrapper<Omit<Github_UpdateNotificationRestrictionSettingPayload, 'owner'> & { owner?: Maybe<ResolversTypes['Github_VerifiableDomainOwner']> }>;
  Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  Github_UpdateOrganizationWebCommitSignoffSettingInput: Github_UpdateOrganizationWebCommitSignoffSettingInput;
  Github_UpdateOrganizationWebCommitSignoffSettingPayload: ResolverTypeWrapper<Github_UpdateOrganizationWebCommitSignoffSettingPayload>;
  Github_UpdateProjectCardInput: Github_UpdateProjectCardInput;
  Github_UpdateProjectCardPayload: ResolverTypeWrapper<Github_UpdateProjectCardPayload>;
  Github_UpdateProjectColumnInput: Github_UpdateProjectColumnInput;
  Github_UpdateProjectColumnPayload: ResolverTypeWrapper<Github_UpdateProjectColumnPayload>;
  Github_UpdateProjectInput: Github_UpdateProjectInput;
  Github_UpdateProjectPayload: ResolverTypeWrapper<Github_UpdateProjectPayload>;
  Github_UpdateProjectV2DraftIssueInput: Github_UpdateProjectV2DraftIssueInput;
  Github_UpdateProjectV2DraftIssuePayload: ResolverTypeWrapper<Github_UpdateProjectV2DraftIssuePayload>;
  Github_UpdateProjectV2Input: Github_UpdateProjectV2Input;
  Github_UpdateProjectV2ItemFieldValueInput: Github_UpdateProjectV2ItemFieldValueInput;
  Github_UpdateProjectV2ItemFieldValuePayload: ResolverTypeWrapper<Github_UpdateProjectV2ItemFieldValuePayload>;
  Github_UpdateProjectV2ItemPositionInput: Github_UpdateProjectV2ItemPositionInput;
  Github_UpdateProjectV2ItemPositionPayload: ResolverTypeWrapper<Github_UpdateProjectV2ItemPositionPayload>;
  Github_UpdateProjectV2Payload: ResolverTypeWrapper<Github_UpdateProjectV2Payload>;
  Github_UpdatePullRequestBranchInput: Github_UpdatePullRequestBranchInput;
  Github_UpdatePullRequestBranchPayload: ResolverTypeWrapper<Github_UpdatePullRequestBranchPayload>;
  Github_UpdatePullRequestInput: Github_UpdatePullRequestInput;
  Github_UpdatePullRequestPayload: ResolverTypeWrapper<Github_UpdatePullRequestPayload>;
  Github_UpdatePullRequestReviewCommentInput: Github_UpdatePullRequestReviewCommentInput;
  Github_UpdatePullRequestReviewCommentPayload: ResolverTypeWrapper<Github_UpdatePullRequestReviewCommentPayload>;
  Github_UpdatePullRequestReviewInput: Github_UpdatePullRequestReviewInput;
  Github_UpdatePullRequestReviewPayload: ResolverTypeWrapper<Github_UpdatePullRequestReviewPayload>;
  Github_UpdateRefInput: Github_UpdateRefInput;
  Github_UpdateRefPayload: ResolverTypeWrapper<Github_UpdateRefPayload>;
  Github_UpdateRefsInput: Github_UpdateRefsInput;
  Github_UpdateRefsPayload: ResolverTypeWrapper<Github_UpdateRefsPayload>;
  Github_UpdateRepositoryInput: Github_UpdateRepositoryInput;
  Github_UpdateRepositoryPayload: ResolverTypeWrapper<Github_UpdateRepositoryPayload>;
  Github_UpdateRepositoryWebCommitSignoffSettingInput: Github_UpdateRepositoryWebCommitSignoffSettingInput;
  Github_UpdateRepositoryWebCommitSignoffSettingPayload: ResolverTypeWrapper<Github_UpdateRepositoryWebCommitSignoffSettingPayload>;
  Github_UpdateSponsorshipPreferencesInput: Github_UpdateSponsorshipPreferencesInput;
  Github_UpdateSponsorshipPreferencesPayload: ResolverTypeWrapper<Github_UpdateSponsorshipPreferencesPayload>;
  Github_UpdateSubscriptionInput: Github_UpdateSubscriptionInput;
  Github_UpdateSubscriptionPayload: ResolverTypeWrapper<Github_UpdateSubscriptionPayload>;
  Github_UpdateTeamDiscussionCommentInput: Github_UpdateTeamDiscussionCommentInput;
  Github_UpdateTeamDiscussionCommentPayload: ResolverTypeWrapper<Github_UpdateTeamDiscussionCommentPayload>;
  Github_UpdateTeamDiscussionInput: Github_UpdateTeamDiscussionInput;
  Github_UpdateTeamDiscussionPayload: ResolverTypeWrapper<Github_UpdateTeamDiscussionPayload>;
  Github_UpdateTeamReviewAssignmentInput: Github_UpdateTeamReviewAssignmentInput;
  Github_UpdateTeamReviewAssignmentPayload: ResolverTypeWrapper<Github_UpdateTeamReviewAssignmentPayload>;
  Github_UpdateTeamsRepositoryInput: Github_UpdateTeamsRepositoryInput;
  Github_UpdateTeamsRepositoryPayload: ResolverTypeWrapper<Github_UpdateTeamsRepositoryPayload>;
  Github_UpdateTopicsInput: Github_UpdateTopicsInput;
  Github_UpdateTopicsPayload: ResolverTypeWrapper<Github_UpdateTopicsPayload>;
  Github_User: ResolverTypeWrapper<Github_User>;
  Github_UserBlockDuration: Github_UserBlockDuration;
  Github_UserBlockedEvent: ResolverTypeWrapper<Github_UserBlockedEvent>;
  Github_UserConnection: ResolverTypeWrapper<Github_UserConnection>;
  Github_UserContentEdit: ResolverTypeWrapper<Github_UserContentEdit>;
  Github_UserContentEditConnection: ResolverTypeWrapper<Github_UserContentEditConnection>;
  Github_UserContentEditEdge: ResolverTypeWrapper<Github_UserContentEditEdge>;
  Github_UserEdge: ResolverTypeWrapper<Github_UserEdge>;
  Github_UserEmailMetadata: ResolverTypeWrapper<Github_UserEmailMetadata>;
  Github_UserStatus: ResolverTypeWrapper<Github_UserStatus>;
  Github_UserStatusConnection: ResolverTypeWrapper<Github_UserStatusConnection>;
  Github_UserStatusEdge: ResolverTypeWrapper<Github_UserStatusEdge>;
  Github_UserStatusOrder: Github_UserStatusOrder;
  Github_UserStatusOrderField: Github_UserStatusOrderField;
  Github_VerifiableDomain: ResolverTypeWrapper<Omit<Github_VerifiableDomain, 'owner'> & { owner: ResolversTypes['Github_VerifiableDomainOwner'] }>;
  Github_VerifiableDomainConnection: ResolverTypeWrapper<Github_VerifiableDomainConnection>;
  Github_VerifiableDomainEdge: ResolverTypeWrapper<Github_VerifiableDomainEdge>;
  Github_VerifiableDomainOrder: Github_VerifiableDomainOrder;
  Github_VerifiableDomainOrderField: Github_VerifiableDomainOrderField;
  Github_VerifiableDomainOwner: ResolversTypes['Github_Enterprise'] | ResolversTypes['Github_Organization'];
  Github_VerifyVerifiableDomainInput: Github_VerifyVerifiableDomainInput;
  Github_VerifyVerifiableDomainPayload: ResolverTypeWrapper<Github_VerifyVerifiableDomainPayload>;
  Github_ViewerHovercardContext: ResolverTypeWrapper<Github_ViewerHovercardContext>;
  Github_Votable: ResolversTypes['Github_Discussion'] | ResolversTypes['Github_DiscussionComment'];
  Github_Workflow: ResolverTypeWrapper<Github_Workflow>;
  Github_WorkflowRun: ResolverTypeWrapper<Github_WorkflowRun>;
  Github_WorkflowRunConnection: ResolverTypeWrapper<Github_WorkflowRunConnection>;
  Github_WorkflowRunEdge: ResolverTypeWrapper<Github_WorkflowRunEdge>;
  Github_WorkflowRunOrder: Github_WorkflowRunOrder;
  Github_WorkflowRunOrderField: Github_WorkflowRunOrderField;
  Github_X509Certificate: ResolverTypeWrapper<Scalars['Github_X509Certificate']>;
  github_1Query: ResolverTypeWrapper<github_1Query>;
  github_1Mutation: ResolverTypeWrapper<github_1Mutation>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Query: {};
  AWSLambda_ListFunctionsResponse: AWSLambda_ListFunctionsResponse;
  AWSLambda_FunctionsListItem: AWSLambda_FunctionsListItem;
  String: Scalars['String'];
  Int: Scalars['Int'];
  AWSLambda_DeadLetterConfig: AWSLambda_DeadLetterConfig;
  AWSLambda_Environment: AWSLambda_Environment;
  AWSLambda_Error: AWSLambda_Error;
  JSON: Scalars['JSON'];
  AWSLambda_FileSystemConfigsListItem: AWSLambda_FileSystemConfigsListItem;
  AWSLambda_ImageConfigResponse: AWSLambda_ImageConfigResponse;
  AWSLambda_Error2: AWSLambda_Error2;
  AWSLambda_ImageConfig: AWSLambda_ImageConfig;
  AWSLambda_LayersListItem: AWSLambda_LayersListItem;
  AWSLambda_TracingConfig: AWSLambda_TracingConfig;
  AWSLambda_VpcConfig: AWSLambda_VpcConfig;
  Boolean: Scalars['Boolean'];
  aws_lambda_1Query: aws_lambda_1Query;
  Mutation: {};
  Github_AbortQueuedMigrationsInput: Github_AbortQueuedMigrationsInput;
  ID: Scalars['ID'];
  Github_AbortQueuedMigrationsPayload: Github_AbortQueuedMigrationsPayload;
  Github_AcceptEnterpriseAdministratorInvitationInput: Github_AcceptEnterpriseAdministratorInvitationInput;
  Github_AcceptEnterpriseAdministratorInvitationPayload: Github_AcceptEnterpriseAdministratorInvitationPayload;
  Github_AcceptTopicSuggestionInput: Github_AcceptTopicSuggestionInput;
  Github_AcceptTopicSuggestionPayload: Github_AcceptTopicSuggestionPayload;
  Github_Actor: ResolversParentTypes['Github_Bot'] | ResolversParentTypes['Github_EnterpriseUserAccount'] | ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_ActorLocation: Github_ActorLocation;
  Github_AddAssigneesToAssignableInput: Github_AddAssigneesToAssignableInput;
  Github_AddAssigneesToAssignablePayload: Github_AddAssigneesToAssignablePayload;
  Github_AddCommentInput: Github_AddCommentInput;
  Github_AddCommentPayload: Github_AddCommentPayload;
  Github_AddDiscussionCommentInput: Github_AddDiscussionCommentInput;
  Github_AddDiscussionCommentPayload: Github_AddDiscussionCommentPayload;
  Github_AddDiscussionPollVoteInput: Github_AddDiscussionPollVoteInput;
  Github_AddDiscussionPollVotePayload: Github_AddDiscussionPollVotePayload;
  Github_AddEnterpriseOrganizationMemberInput: Github_AddEnterpriseOrganizationMemberInput;
  Github_AddEnterpriseOrganizationMemberPayload: Github_AddEnterpriseOrganizationMemberPayload;
  Github_AddEnterpriseSupportEntitlementInput: Github_AddEnterpriseSupportEntitlementInput;
  Github_AddEnterpriseSupportEntitlementPayload: Github_AddEnterpriseSupportEntitlementPayload;
  Github_AddLabelsToLabelableInput: Github_AddLabelsToLabelableInput;
  Github_AddLabelsToLabelablePayload: Github_AddLabelsToLabelablePayload;
  Github_AddProjectCardInput: Github_AddProjectCardInput;
  Github_AddProjectCardPayload: Github_AddProjectCardPayload;
  Github_AddProjectColumnInput: Github_AddProjectColumnInput;
  Github_AddProjectColumnPayload: Github_AddProjectColumnPayload;
  Github_AddProjectV2DraftIssueInput: Github_AddProjectV2DraftIssueInput;
  Github_AddProjectV2DraftIssuePayload: Github_AddProjectV2DraftIssuePayload;
  Github_AddProjectV2ItemByIdInput: Github_AddProjectV2ItemByIdInput;
  Github_AddProjectV2ItemByIdPayload: Github_AddProjectV2ItemByIdPayload;
  Github_AddPullRequestReviewCommentInput: Github_AddPullRequestReviewCommentInput;
  Github_AddPullRequestReviewCommentPayload: Github_AddPullRequestReviewCommentPayload;
  Github_AddPullRequestReviewInput: Github_AddPullRequestReviewInput;
  Github_AddPullRequestReviewPayload: Github_AddPullRequestReviewPayload;
  Github_AddPullRequestReviewThreadInput: Github_AddPullRequestReviewThreadInput;
  Github_AddPullRequestReviewThreadPayload: Github_AddPullRequestReviewThreadPayload;
  Github_AddReactionInput: Github_AddReactionInput;
  Github_AddReactionPayload: Github_AddReactionPayload;
  Github_AddStarInput: Github_AddStarInput;
  Github_AddStarPayload: Github_AddStarPayload;
  Github_AddUpvoteInput: Github_AddUpvoteInput;
  Github_AddUpvotePayload: Github_AddUpvotePayload;
  Github_AddVerifiableDomainInput: Github_AddVerifiableDomainInput;
  Github_AddVerifiableDomainPayload: Github_AddVerifiableDomainPayload;
  Github_AddedToProjectEvent: Github_AddedToProjectEvent;
  Github_AnnouncementBanner: ResolversParentTypes['Github_Enterprise'] | ResolversParentTypes['Github_Organization'];
  Github_App: Github_App;
  Github_ApproveDeploymentsInput: Github_ApproveDeploymentsInput;
  Github_ApproveDeploymentsPayload: Github_ApproveDeploymentsPayload;
  Github_ApproveVerifiableDomainInput: Github_ApproveVerifiableDomainInput;
  Github_ApproveVerifiableDomainPayload: Github_ApproveVerifiableDomainPayload;
  Github_ArchiveProjectV2ItemInput: Github_ArchiveProjectV2ItemInput;
  Github_ArchiveProjectV2ItemPayload: Github_ArchiveProjectV2ItemPayload;
  Github_ArchiveRepositoryInput: Github_ArchiveRepositoryInput;
  Github_ArchiveRepositoryPayload: Github_ArchiveRepositoryPayload;
  Github_Assignable: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_AssignedEvent: Omit<Github_AssignedEvent, 'assignee'> & { assignee?: Maybe<ResolversParentTypes['Github_Assignee']> };
  Github_Assignee: ResolversParentTypes['Github_Bot'] | ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_AuditEntry: ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversParentTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversParentTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgAddMemberAuditEntry'] | ResolversParentTypes['Github_OrgBlockUserAuditEntry'] | ResolversParentTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgCreateAuditEntry'] | ResolversParentTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgDisableSamlAuditEntry'] | ResolversParentTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgEnableSamlAuditEntry'] | ResolversParentTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgInviteMemberAuditEntry'] | ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversParentTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversParentTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversParentTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversParentTypes['Github_OrgUnblockUserAuditEntry'] | ResolversParentTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversParentTypes['Github_RepoAccessAuditEntry'] | ResolversParentTypes['Github_RepoAddMemberAuditEntry'] | ResolversParentTypes['Github_RepoAddTopicAuditEntry'] | ResolversParentTypes['Github_RepoArchivedAuditEntry'] | ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoCreateAuditEntry'] | ResolversParentTypes['Github_RepoDestroyAuditEntry'] | ResolversParentTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversParentTypes['Github_TeamAddMemberAuditEntry'] | ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversParentTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_AuditEntryActor: ResolversParentTypes['Github_Bot'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_AuditLogOrder: Github_AuditLogOrder;
  Github_AutoMergeDisabledEvent: Github_AutoMergeDisabledEvent;
  Github_AutoMergeEnabledEvent: Github_AutoMergeEnabledEvent;
  Github_AutoMergeRequest: Github_AutoMergeRequest;
  Github_AutoRebaseEnabledEvent: Github_AutoRebaseEnabledEvent;
  Github_AutoSquashEnabledEvent: Github_AutoSquashEnabledEvent;
  Github_AutomaticBaseChangeFailedEvent: Github_AutomaticBaseChangeFailedEvent;
  Github_AutomaticBaseChangeSucceededEvent: Github_AutomaticBaseChangeSucceededEvent;
  Github_Base64String: Scalars['Github_Base64String'];
  Github_BaseRefChangedEvent: Github_BaseRefChangedEvent;
  Github_BaseRefDeletedEvent: Github_BaseRefDeletedEvent;
  Github_BaseRefForcePushedEvent: Github_BaseRefForcePushedEvent;
  Github_Blame: Github_Blame;
  Github_BlameRange: Github_BlameRange;
  Github_Blob: Github_Blob;
  Github_Bot: Github_Bot;
  Github_BranchActorAllowanceActor: ResolversParentTypes['Github_App'] | ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_User'];
  Github_BranchProtectionRule: Github_BranchProtectionRule;
  Github_BranchProtectionRuleConflict: Github_BranchProtectionRuleConflict;
  Github_BranchProtectionRuleConflictConnection: Github_BranchProtectionRuleConflictConnection;
  Github_BranchProtectionRuleConflictEdge: Github_BranchProtectionRuleConflictEdge;
  Github_BranchProtectionRuleConnection: Github_BranchProtectionRuleConnection;
  Github_BranchProtectionRuleEdge: Github_BranchProtectionRuleEdge;
  Github_BypassForcePushAllowance: Omit<Github_BypassForcePushAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_BranchActorAllowanceActor']> };
  Github_BypassForcePushAllowanceConnection: Github_BypassForcePushAllowanceConnection;
  Github_BypassForcePushAllowanceEdge: Github_BypassForcePushAllowanceEdge;
  Github_BypassPullRequestAllowance: Omit<Github_BypassPullRequestAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_BranchActorAllowanceActor']> };
  Github_BypassPullRequestAllowanceConnection: Github_BypassPullRequestAllowanceConnection;
  Github_BypassPullRequestAllowanceEdge: Github_BypassPullRequestAllowanceEdge;
  Github_CVSS: Github_CVSS;
  Float: Scalars['Float'];
  Github_CWE: Github_CWE;
  Github_CWEConnection: Github_CWEConnection;
  Github_CWEEdge: Github_CWEEdge;
  Github_CancelEnterpriseAdminInvitationInput: Github_CancelEnterpriseAdminInvitationInput;
  Github_CancelEnterpriseAdminInvitationPayload: Github_CancelEnterpriseAdminInvitationPayload;
  Github_CancelSponsorshipInput: Github_CancelSponsorshipInput;
  Github_CancelSponsorshipPayload: Github_CancelSponsorshipPayload;
  Github_ChangeUserStatusInput: Github_ChangeUserStatusInput;
  Github_ChangeUserStatusPayload: Github_ChangeUserStatusPayload;
  Github_CheckAnnotation: Github_CheckAnnotation;
  Github_CheckAnnotationConnection: Github_CheckAnnotationConnection;
  Github_CheckAnnotationData: Github_CheckAnnotationData;
  Github_CheckAnnotationEdge: Github_CheckAnnotationEdge;
  Github_CheckAnnotationPosition: Github_CheckAnnotationPosition;
  Github_CheckAnnotationRange: Github_CheckAnnotationRange;
  Github_CheckAnnotationSpan: Github_CheckAnnotationSpan;
  Github_CheckRun: Github_CheckRun;
  Github_CheckRunAction: Github_CheckRunAction;
  Github_CheckRunConnection: Github_CheckRunConnection;
  Github_CheckRunEdge: Github_CheckRunEdge;
  Github_CheckRunFilter: Github_CheckRunFilter;
  Github_CheckRunOutput: Github_CheckRunOutput;
  Github_CheckRunOutputImage: Github_CheckRunOutputImage;
  Github_CheckRunStateCount: Github_CheckRunStateCount;
  Github_CheckStep: Github_CheckStep;
  Github_CheckStepConnection: Github_CheckStepConnection;
  Github_CheckStepEdge: Github_CheckStepEdge;
  Github_CheckSuite: Github_CheckSuite;
  Github_CheckSuiteAutoTriggerPreference: Github_CheckSuiteAutoTriggerPreference;
  Github_CheckSuiteConnection: Github_CheckSuiteConnection;
  Github_CheckSuiteEdge: Github_CheckSuiteEdge;
  Github_CheckSuiteFilter: Github_CheckSuiteFilter;
  Github_Claimable: ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_User'];
  Github_ClearLabelsFromLabelableInput: Github_ClearLabelsFromLabelableInput;
  Github_ClearLabelsFromLabelablePayload: Github_ClearLabelsFromLabelablePayload;
  Github_ClearProjectV2ItemFieldValueInput: Github_ClearProjectV2ItemFieldValueInput;
  Github_ClearProjectV2ItemFieldValuePayload: Github_ClearProjectV2ItemFieldValuePayload;
  Github_CloneProjectInput: Github_CloneProjectInput;
  Github_CloneProjectPayload: Github_CloneProjectPayload;
  Github_CloneTemplateRepositoryInput: Github_CloneTemplateRepositoryInput;
  Github_CloneTemplateRepositoryPayload: Github_CloneTemplateRepositoryPayload;
  Github_Closable: ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_Milestone'] | ResolversParentTypes['Github_Project'] | ResolversParentTypes['Github_ProjectV2'] | ResolversParentTypes['Github_PullRequest'];
  Github_CloseIssueInput: Github_CloseIssueInput;
  Github_CloseIssuePayload: Github_CloseIssuePayload;
  Github_ClosePullRequestInput: Github_ClosePullRequestInput;
  Github_ClosePullRequestPayload: Github_ClosePullRequestPayload;
  Github_ClosedEvent: Omit<Github_ClosedEvent, 'closer'> & { closer?: Maybe<ResolversParentTypes['Github_Closer']> };
  Github_Closer: ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_PullRequest'];
  Github_CodeOfConduct: Github_CodeOfConduct;
  Github_Comment: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_GistComment'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'];
  Github_CommentDeletedEvent: Github_CommentDeletedEvent;
  Github_Commit: Github_Commit;
  Github_CommitAuthor: Github_CommitAuthor;
  Github_CommitComment: Github_CommitComment;
  Github_CommitCommentConnection: Github_CommitCommentConnection;
  Github_CommitCommentEdge: Github_CommitCommentEdge;
  Github_CommitCommentThread: Github_CommitCommentThread;
  Github_CommitConnection: Github_CommitConnection;
  Github_CommitContributionOrder: Github_CommitContributionOrder;
  Github_CommitContributionsByRepository: Github_CommitContributionsByRepository;
  Github_CommitEdge: Github_CommitEdge;
  Github_CommitHistoryConnection: Github_CommitHistoryConnection;
  Github_CommitMessage: Github_CommitMessage;
  Github_CommittableBranch: Github_CommittableBranch;
  Github_Comparison: Github_Comparison;
  Github_ComparisonCommitConnection: Github_ComparisonCommitConnection;
  Github_ConnectedEvent: Omit<Github_ConnectedEvent, 'source' | 'subject'> & { source: ResolversParentTypes['Github_ReferencedSubject'], subject: ResolversParentTypes['Github_ReferencedSubject'] };
  Github_Contribution: ResolversParentTypes['Github_CreatedCommitContribution'] | ResolversParentTypes['Github_CreatedIssueContribution'] | ResolversParentTypes['Github_CreatedPullRequestContribution'] | ResolversParentTypes['Github_CreatedPullRequestReviewContribution'] | ResolversParentTypes['Github_CreatedRepositoryContribution'] | ResolversParentTypes['Github_JoinedGitHubContribution'] | ResolversParentTypes['Github_RestrictedContribution'];
  Github_ContributionCalendar: Github_ContributionCalendar;
  Github_ContributionCalendarDay: Github_ContributionCalendarDay;
  Github_ContributionCalendarMonth: Github_ContributionCalendarMonth;
  Github_ContributionCalendarWeek: Github_ContributionCalendarWeek;
  Github_ContributionOrder: Github_ContributionOrder;
  Github_ContributionsCollection: Omit<Github_ContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<ResolversParentTypes['Github_CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<ResolversParentTypes['Github_CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<ResolversParentTypes['Github_CreatedRepositoryOrRestrictedContribution']> };
  Github_ConvertProjectCardNoteToIssueInput: Github_ConvertProjectCardNoteToIssueInput;
  Github_ConvertProjectCardNoteToIssuePayload: Github_ConvertProjectCardNoteToIssuePayload;
  Github_ConvertPullRequestToDraftInput: Github_ConvertPullRequestToDraftInput;
  Github_ConvertPullRequestToDraftPayload: Github_ConvertPullRequestToDraftPayload;
  Github_ConvertToDraftEvent: Github_ConvertToDraftEvent;
  Github_ConvertedNoteToIssueEvent: Github_ConvertedNoteToIssueEvent;
  Github_ConvertedToDiscussionEvent: Github_ConvertedToDiscussionEvent;
  Github_CopyProjectV2Input: Github_CopyProjectV2Input;
  Github_CopyProjectV2Payload: Github_CopyProjectV2Payload;
  Github_CreateAttributionInvitationInput: Github_CreateAttributionInvitationInput;
  Github_CreateAttributionInvitationPayload: Omit<Github_CreateAttributionInvitationPayload, 'source' | 'target'> & { source?: Maybe<ResolversParentTypes['Github_Claimable']>, target?: Maybe<ResolversParentTypes['Github_Claimable']> };
  Github_CreateBranchProtectionRuleInput: Github_CreateBranchProtectionRuleInput;
  Github_CreateBranchProtectionRulePayload: Github_CreateBranchProtectionRulePayload;
  Github_CreateCheckRunInput: Github_CreateCheckRunInput;
  Github_CreateCheckRunPayload: Github_CreateCheckRunPayload;
  Github_CreateCheckSuiteInput: Github_CreateCheckSuiteInput;
  Github_CreateCheckSuitePayload: Github_CreateCheckSuitePayload;
  Github_CreateCommitOnBranchInput: Github_CreateCommitOnBranchInput;
  Github_CreateCommitOnBranchPayload: Github_CreateCommitOnBranchPayload;
  Github_CreateDeploymentInput: Github_CreateDeploymentInput;
  Github_CreateDeploymentPayload: Github_CreateDeploymentPayload;
  Github_CreateDeploymentStatusInput: Github_CreateDeploymentStatusInput;
  Github_CreateDeploymentStatusPayload: Github_CreateDeploymentStatusPayload;
  Github_CreateDiscussionInput: Github_CreateDiscussionInput;
  Github_CreateDiscussionPayload: Github_CreateDiscussionPayload;
  Github_CreateEnterpriseOrganizationInput: Github_CreateEnterpriseOrganizationInput;
  Github_CreateEnterpriseOrganizationPayload: Github_CreateEnterpriseOrganizationPayload;
  Github_CreateEnvironmentInput: Github_CreateEnvironmentInput;
  Github_CreateEnvironmentPayload: Github_CreateEnvironmentPayload;
  Github_CreateIpAllowListEntryInput: Github_CreateIpAllowListEntryInput;
  Github_CreateIpAllowListEntryPayload: Github_CreateIpAllowListEntryPayload;
  Github_CreateIssueInput: Github_CreateIssueInput;
  Github_CreateIssuePayload: Github_CreateIssuePayload;
  Github_CreateLabelInput: Github_CreateLabelInput;
  Github_CreateLabelPayload: Github_CreateLabelPayload;
  Github_CreateLinkedBranchInput: Github_CreateLinkedBranchInput;
  Github_CreateLinkedBranchPayload: Github_CreateLinkedBranchPayload;
  Github_CreateMigrationSourceInput: Github_CreateMigrationSourceInput;
  Github_CreateMigrationSourcePayload: Github_CreateMigrationSourcePayload;
  Github_CreateProjectInput: Github_CreateProjectInput;
  Github_CreateProjectPayload: Github_CreateProjectPayload;
  Github_CreateProjectV2Input: Github_CreateProjectV2Input;
  Github_CreateProjectV2Payload: Github_CreateProjectV2Payload;
  Github_CreatePullRequestInput: Github_CreatePullRequestInput;
  Github_CreatePullRequestPayload: Github_CreatePullRequestPayload;
  Github_CreateRefInput: Github_CreateRefInput;
  Github_CreateRefPayload: Github_CreateRefPayload;
  Github_CreateRepositoryInput: Github_CreateRepositoryInput;
  Github_CreateRepositoryPayload: Github_CreateRepositoryPayload;
  Github_CreateSponsorsListingInput: Github_CreateSponsorsListingInput;
  Github_CreateSponsorsListingPayload: Github_CreateSponsorsListingPayload;
  Github_CreateSponsorsTierInput: Github_CreateSponsorsTierInput;
  Github_CreateSponsorsTierPayload: Github_CreateSponsorsTierPayload;
  Github_CreateSponsorshipInput: Github_CreateSponsorshipInput;
  Github_CreateSponsorshipPayload: Github_CreateSponsorshipPayload;
  Github_CreateTeamDiscussionCommentInput: Github_CreateTeamDiscussionCommentInput;
  Github_CreateTeamDiscussionCommentPayload: Github_CreateTeamDiscussionCommentPayload;
  Github_CreateTeamDiscussionInput: Github_CreateTeamDiscussionInput;
  Github_CreateTeamDiscussionPayload: Github_CreateTeamDiscussionPayload;
  Github_CreatedCommitContribution: Github_CreatedCommitContribution;
  Github_CreatedCommitContributionConnection: Github_CreatedCommitContributionConnection;
  Github_CreatedCommitContributionEdge: Github_CreatedCommitContributionEdge;
  Github_CreatedIssueContribution: Github_CreatedIssueContribution;
  Github_CreatedIssueContributionConnection: Github_CreatedIssueContributionConnection;
  Github_CreatedIssueContributionEdge: Github_CreatedIssueContributionEdge;
  Github_CreatedIssueOrRestrictedContribution: ResolversParentTypes['Github_CreatedIssueContribution'] | ResolversParentTypes['Github_RestrictedContribution'];
  Github_CreatedPullRequestContribution: Github_CreatedPullRequestContribution;
  Github_CreatedPullRequestContributionConnection: Github_CreatedPullRequestContributionConnection;
  Github_CreatedPullRequestContributionEdge: Github_CreatedPullRequestContributionEdge;
  Github_CreatedPullRequestOrRestrictedContribution: ResolversParentTypes['Github_CreatedPullRequestContribution'] | ResolversParentTypes['Github_RestrictedContribution'];
  Github_CreatedPullRequestReviewContribution: Github_CreatedPullRequestReviewContribution;
  Github_CreatedPullRequestReviewContributionConnection: Github_CreatedPullRequestReviewContributionConnection;
  Github_CreatedPullRequestReviewContributionEdge: Github_CreatedPullRequestReviewContributionEdge;
  Github_CreatedRepositoryContribution: Github_CreatedRepositoryContribution;
  Github_CreatedRepositoryContributionConnection: Github_CreatedRepositoryContributionConnection;
  Github_CreatedRepositoryContributionEdge: Github_CreatedRepositoryContributionEdge;
  Github_CreatedRepositoryOrRestrictedContribution: ResolversParentTypes['Github_CreatedRepositoryContribution'] | ResolversParentTypes['Github_RestrictedContribution'];
  Github_CrossReferencedEvent: Omit<Github_CrossReferencedEvent, 'source' | 'target'> & { source: ResolversParentTypes['Github_ReferencedSubject'], target: ResolversParentTypes['Github_ReferencedSubject'] };
  Date: Scalars['Date'];
  DateTime: Scalars['DateTime'];
  Github_DeclineTopicSuggestionInput: Github_DeclineTopicSuggestionInput;
  Github_DeclineTopicSuggestionPayload: Github_DeclineTopicSuggestionPayload;
  Github_Deletable: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_GistComment'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'];
  Github_DeleteBranchProtectionRuleInput: Github_DeleteBranchProtectionRuleInput;
  Github_DeleteBranchProtectionRulePayload: Github_DeleteBranchProtectionRulePayload;
  Github_DeleteDeploymentInput: Github_DeleteDeploymentInput;
  Github_DeleteDeploymentPayload: Github_DeleteDeploymentPayload;
  Github_DeleteDiscussionCommentInput: Github_DeleteDiscussionCommentInput;
  Github_DeleteDiscussionCommentPayload: Github_DeleteDiscussionCommentPayload;
  Github_DeleteDiscussionInput: Github_DeleteDiscussionInput;
  Github_DeleteDiscussionPayload: Github_DeleteDiscussionPayload;
  Github_DeleteEnvironmentInput: Github_DeleteEnvironmentInput;
  Github_DeleteEnvironmentPayload: Github_DeleteEnvironmentPayload;
  Github_DeleteIpAllowListEntryInput: Github_DeleteIpAllowListEntryInput;
  Github_DeleteIpAllowListEntryPayload: Github_DeleteIpAllowListEntryPayload;
  Github_DeleteIssueCommentInput: Github_DeleteIssueCommentInput;
  Github_DeleteIssueCommentPayload: Github_DeleteIssueCommentPayload;
  Github_DeleteIssueInput: Github_DeleteIssueInput;
  Github_DeleteIssuePayload: Github_DeleteIssuePayload;
  Github_DeleteLabelInput: Github_DeleteLabelInput;
  Github_DeleteLabelPayload: Github_DeleteLabelPayload;
  Github_DeleteLinkedBranchInput: Github_DeleteLinkedBranchInput;
  Github_DeleteLinkedBranchPayload: Github_DeleteLinkedBranchPayload;
  Github_DeletePackageVersionInput: Github_DeletePackageVersionInput;
  Github_DeletePackageVersionPayload: Github_DeletePackageVersionPayload;
  Github_DeleteProjectCardInput: Github_DeleteProjectCardInput;
  Github_DeleteProjectCardPayload: Github_DeleteProjectCardPayload;
  Github_DeleteProjectColumnInput: Github_DeleteProjectColumnInput;
  Github_DeleteProjectColumnPayload: Github_DeleteProjectColumnPayload;
  Github_DeleteProjectInput: Github_DeleteProjectInput;
  Github_DeleteProjectPayload: Github_DeleteProjectPayload;
  Github_DeleteProjectV2Input: Github_DeleteProjectV2Input;
  Github_DeleteProjectV2ItemInput: Github_DeleteProjectV2ItemInput;
  Github_DeleteProjectV2ItemPayload: Github_DeleteProjectV2ItemPayload;
  Github_DeleteProjectV2Payload: Github_DeleteProjectV2Payload;
  Github_DeletePullRequestReviewCommentInput: Github_DeletePullRequestReviewCommentInput;
  Github_DeletePullRequestReviewCommentPayload: Github_DeletePullRequestReviewCommentPayload;
  Github_DeletePullRequestReviewInput: Github_DeletePullRequestReviewInput;
  Github_DeletePullRequestReviewPayload: Github_DeletePullRequestReviewPayload;
  Github_DeleteRefInput: Github_DeleteRefInput;
  Github_DeleteRefPayload: Github_DeleteRefPayload;
  Github_DeleteTeamDiscussionCommentInput: Github_DeleteTeamDiscussionCommentInput;
  Github_DeleteTeamDiscussionCommentPayload: Github_DeleteTeamDiscussionCommentPayload;
  Github_DeleteTeamDiscussionInput: Github_DeleteTeamDiscussionInput;
  Github_DeleteTeamDiscussionPayload: Github_DeleteTeamDiscussionPayload;
  Github_DeleteVerifiableDomainInput: Github_DeleteVerifiableDomainInput;
  Github_DeleteVerifiableDomainPayload: Omit<Github_DeleteVerifiableDomainPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['Github_VerifiableDomainOwner']> };
  Github_DemilestonedEvent: Omit<Github_DemilestonedEvent, 'subject'> & { subject: ResolversParentTypes['Github_MilestoneItem'] };
  Github_DependabotUpdate: Github_DependabotUpdate;
  Github_DependabotUpdateError: Github_DependabotUpdateError;
  Github_DependencyGraphDependency: Github_DependencyGraphDependency;
  Github_DependencyGraphDependencyConnection: Github_DependencyGraphDependencyConnection;
  Github_DependencyGraphDependencyEdge: Github_DependencyGraphDependencyEdge;
  Github_DependencyGraphManifest: Github_DependencyGraphManifest;
  Github_DependencyGraphManifestConnection: Github_DependencyGraphManifestConnection;
  Github_DependencyGraphManifestEdge: Github_DependencyGraphManifestEdge;
  Github_DeployKey: Github_DeployKey;
  Github_DeployKeyConnection: Github_DeployKeyConnection;
  Github_DeployKeyEdge: Github_DeployKeyEdge;
  Github_DeployedEvent: Github_DeployedEvent;
  Github_Deployment: Github_Deployment;
  Github_DeploymentConnection: Github_DeploymentConnection;
  Github_DeploymentEdge: Github_DeploymentEdge;
  Github_DeploymentEnvironmentChangedEvent: Github_DeploymentEnvironmentChangedEvent;
  Github_DeploymentOrder: Github_DeploymentOrder;
  Github_DeploymentProtectionRule: Github_DeploymentProtectionRule;
  Github_DeploymentProtectionRuleConnection: Github_DeploymentProtectionRuleConnection;
  Github_DeploymentProtectionRuleEdge: Github_DeploymentProtectionRuleEdge;
  Github_DeploymentRequest: Github_DeploymentRequest;
  Github_DeploymentRequestConnection: Github_DeploymentRequestConnection;
  Github_DeploymentRequestEdge: Github_DeploymentRequestEdge;
  Github_DeploymentReview: Github_DeploymentReview;
  Github_DeploymentReviewConnection: Github_DeploymentReviewConnection;
  Github_DeploymentReviewEdge: Github_DeploymentReviewEdge;
  Github_DeploymentReviewer: ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_User'];
  Github_DeploymentReviewerConnection: Omit<Github_DeploymentReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_DeploymentReviewer']>>> };
  Github_DeploymentReviewerEdge: Omit<Github_DeploymentReviewerEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_DeploymentReviewer']> };
  Github_DeploymentStatus: Github_DeploymentStatus;
  Github_DeploymentStatusConnection: Github_DeploymentStatusConnection;
  Github_DeploymentStatusEdge: Github_DeploymentStatusEdge;
  Github_DisablePullRequestAutoMergeInput: Github_DisablePullRequestAutoMergeInput;
  Github_DisablePullRequestAutoMergePayload: Github_DisablePullRequestAutoMergePayload;
  Github_DisconnectedEvent: Omit<Github_DisconnectedEvent, 'source' | 'subject'> & { source: ResolversParentTypes['Github_ReferencedSubject'], subject: ResolversParentTypes['Github_ReferencedSubject'] };
  Github_Discussion: Github_Discussion;
  Github_DiscussionCategory: Github_DiscussionCategory;
  Github_DiscussionCategoryConnection: Github_DiscussionCategoryConnection;
  Github_DiscussionCategoryEdge: Github_DiscussionCategoryEdge;
  Github_DiscussionComment: Github_DiscussionComment;
  Github_DiscussionCommentConnection: Github_DiscussionCommentConnection;
  Github_DiscussionCommentEdge: Github_DiscussionCommentEdge;
  Github_DiscussionConnection: Github_DiscussionConnection;
  Github_DiscussionEdge: Github_DiscussionEdge;
  Github_DiscussionOrder: Github_DiscussionOrder;
  Github_DiscussionPoll: Github_DiscussionPoll;
  Github_DiscussionPollOption: Github_DiscussionPollOption;
  Github_DiscussionPollOptionConnection: Github_DiscussionPollOptionConnection;
  Github_DiscussionPollOptionEdge: Github_DiscussionPollOptionEdge;
  Github_DiscussionPollOptionOrder: Github_DiscussionPollOptionOrder;
  Github_DismissPullRequestReviewInput: Github_DismissPullRequestReviewInput;
  Github_DismissPullRequestReviewPayload: Github_DismissPullRequestReviewPayload;
  Github_DismissRepositoryVulnerabilityAlertInput: Github_DismissRepositoryVulnerabilityAlertInput;
  Github_DismissRepositoryVulnerabilityAlertPayload: Github_DismissRepositoryVulnerabilityAlertPayload;
  Github_DraftIssue: Github_DraftIssue;
  Github_DraftPullRequestReviewComment: Github_DraftPullRequestReviewComment;
  Github_DraftPullRequestReviewThread: Github_DraftPullRequestReviewThread;
  Github_EnablePullRequestAutoMergeInput: Github_EnablePullRequestAutoMergeInput;
  Github_EnablePullRequestAutoMergePayload: Github_EnablePullRequestAutoMergePayload;
  Github_Enterprise: Github_Enterprise;
  Github_EnterpriseAdministratorConnection: Github_EnterpriseAdministratorConnection;
  Github_EnterpriseAdministratorEdge: Github_EnterpriseAdministratorEdge;
  Github_EnterpriseAdministratorInvitation: Github_EnterpriseAdministratorInvitation;
  Github_EnterpriseAdministratorInvitationConnection: Github_EnterpriseAdministratorInvitationConnection;
  Github_EnterpriseAdministratorInvitationEdge: Github_EnterpriseAdministratorInvitationEdge;
  Github_EnterpriseAdministratorInvitationOrder: Github_EnterpriseAdministratorInvitationOrder;
  Github_EnterpriseAuditEntryData: ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'];
  Github_EnterpriseBillingInfo: Github_EnterpriseBillingInfo;
  Github_EnterpriseFailedInvitationConnection: Github_EnterpriseFailedInvitationConnection;
  Github_EnterpriseFailedInvitationEdge: Github_EnterpriseFailedInvitationEdge;
  Github_EnterpriseIdentityProvider: Github_EnterpriseIdentityProvider;
  Github_EnterpriseMember: ResolversParentTypes['Github_EnterpriseUserAccount'] | ResolversParentTypes['Github_User'];
  Github_EnterpriseMemberConnection: Omit<Github_EnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_EnterpriseMember']>>> };
  Github_EnterpriseMemberEdge: Omit<Github_EnterpriseMemberEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_EnterpriseMember']> };
  Github_EnterpriseMemberOrder: Github_EnterpriseMemberOrder;
  Github_EnterpriseOrganizationMembershipConnection: Github_EnterpriseOrganizationMembershipConnection;
  Github_EnterpriseOrganizationMembershipEdge: Github_EnterpriseOrganizationMembershipEdge;
  Github_EnterpriseOutsideCollaboratorConnection: Github_EnterpriseOutsideCollaboratorConnection;
  Github_EnterpriseOutsideCollaboratorEdge: Github_EnterpriseOutsideCollaboratorEdge;
  Github_EnterpriseOwnerInfo: Github_EnterpriseOwnerInfo;
  Github_EnterprisePendingMemberInvitationConnection: Github_EnterprisePendingMemberInvitationConnection;
  Github_EnterprisePendingMemberInvitationEdge: Github_EnterprisePendingMemberInvitationEdge;
  Github_EnterpriseRepositoryInfo: Github_EnterpriseRepositoryInfo;
  Github_EnterpriseRepositoryInfoConnection: Github_EnterpriseRepositoryInfoConnection;
  Github_EnterpriseRepositoryInfoEdge: Github_EnterpriseRepositoryInfoEdge;
  Github_EnterpriseServerInstallation: Github_EnterpriseServerInstallation;
  Github_EnterpriseServerInstallationConnection: Github_EnterpriseServerInstallationConnection;
  Github_EnterpriseServerInstallationEdge: Github_EnterpriseServerInstallationEdge;
  Github_EnterpriseServerInstallationOrder: Github_EnterpriseServerInstallationOrder;
  Github_EnterpriseServerUserAccount: Github_EnterpriseServerUserAccount;
  Github_EnterpriseServerUserAccountConnection: Github_EnterpriseServerUserAccountConnection;
  Github_EnterpriseServerUserAccountEdge: Github_EnterpriseServerUserAccountEdge;
  Github_EnterpriseServerUserAccountEmail: Github_EnterpriseServerUserAccountEmail;
  Github_EnterpriseServerUserAccountEmailConnection: Github_EnterpriseServerUserAccountEmailConnection;
  Github_EnterpriseServerUserAccountEmailEdge: Github_EnterpriseServerUserAccountEmailEdge;
  Github_EnterpriseServerUserAccountEmailOrder: Github_EnterpriseServerUserAccountEmailOrder;
  Github_EnterpriseServerUserAccountOrder: Github_EnterpriseServerUserAccountOrder;
  Github_EnterpriseServerUserAccountsUpload: Github_EnterpriseServerUserAccountsUpload;
  Github_EnterpriseServerUserAccountsUploadConnection: Github_EnterpriseServerUserAccountsUploadConnection;
  Github_EnterpriseServerUserAccountsUploadEdge: Github_EnterpriseServerUserAccountsUploadEdge;
  Github_EnterpriseServerUserAccountsUploadOrder: Github_EnterpriseServerUserAccountsUploadOrder;
  Github_EnterpriseUserAccount: Github_EnterpriseUserAccount;
  Github_Environment: Github_Environment;
  Github_EnvironmentConnection: Github_EnvironmentConnection;
  Github_EnvironmentEdge: Github_EnvironmentEdge;
  Github_ExternalIdentity: Github_ExternalIdentity;
  Github_ExternalIdentityAttribute: Github_ExternalIdentityAttribute;
  Github_ExternalIdentityConnection: Github_ExternalIdentityConnection;
  Github_ExternalIdentityEdge: Github_ExternalIdentityEdge;
  Github_ExternalIdentitySamlAttributes: Github_ExternalIdentitySamlAttributes;
  Github_ExternalIdentityScimAttributes: Github_ExternalIdentityScimAttributes;
  Github_FileAddition: Github_FileAddition;
  Github_FileChanges: Github_FileChanges;
  Github_FileDeletion: Github_FileDeletion;
  Github_FollowOrganizationInput: Github_FollowOrganizationInput;
  Github_FollowOrganizationPayload: Github_FollowOrganizationPayload;
  Github_FollowUserInput: Github_FollowUserInput;
  Github_FollowUserPayload: Github_FollowUserPayload;
  Github_FollowerConnection: Github_FollowerConnection;
  Github_FollowingConnection: Github_FollowingConnection;
  Github_FundingLink: Github_FundingLink;
  Github_GenericHovercardContext: Github_GenericHovercardContext;
  Github_Gist: Github_Gist;
  Github_GistComment: Github_GistComment;
  Github_GistCommentConnection: Github_GistCommentConnection;
  Github_GistCommentEdge: Github_GistCommentEdge;
  Github_GistConnection: Github_GistConnection;
  Github_GistEdge: Github_GistEdge;
  Github_GistFile: Github_GistFile;
  Github_GistOrder: Github_GistOrder;
  Github_GitActor: Github_GitActor;
  Github_GitActorConnection: Github_GitActorConnection;
  Github_GitActorEdge: Github_GitActorEdge;
  Github_GitHubMetadata: Github_GitHubMetadata;
  Github_GitObject: ResolversParentTypes['Github_Blob'] | ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_Tag'] | ResolversParentTypes['Github_Tree'];
  Github_GitObjectID: Scalars['Github_GitObjectID'];
  Github_GitRefname: Scalars['Github_GitRefname'];
  Github_GitSSHRemote: Scalars['Github_GitSSHRemote'];
  Github_GitSignature: ResolversParentTypes['Github_GpgSignature'] | ResolversParentTypes['Github_SmimeSignature'] | ResolversParentTypes['Github_SshSignature'] | ResolversParentTypes['Github_UnknownSignature'];
  Github_GitTimestamp: Scalars['Github_GitTimestamp'];
  Github_GpgSignature: Github_GpgSignature;
  Github_GrantEnterpriseOrganizationsMigratorRoleInput: Github_GrantEnterpriseOrganizationsMigratorRoleInput;
  Github_GrantEnterpriseOrganizationsMigratorRolePayload: Github_GrantEnterpriseOrganizationsMigratorRolePayload;
  Github_GrantMigratorRoleInput: Github_GrantMigratorRoleInput;
  Github_GrantMigratorRolePayload: Github_GrantMigratorRolePayload;
  Github_HTML: Scalars['Github_HTML'];
  Github_HeadRefDeletedEvent: Github_HeadRefDeletedEvent;
  Github_HeadRefForcePushedEvent: Github_HeadRefForcePushedEvent;
  Github_HeadRefRestoredEvent: Github_HeadRefRestoredEvent;
  Github_Hovercard: Github_Hovercard;
  Github_HovercardContext: ResolversParentTypes['Github_GenericHovercardContext'] | ResolversParentTypes['Github_OrganizationTeamsHovercardContext'] | ResolversParentTypes['Github_OrganizationsHovercardContext'] | ResolversParentTypes['Github_ReviewStatusHovercardContext'] | ResolversParentTypes['Github_ViewerHovercardContext'];
  Github_ImportProjectInput: Github_ImportProjectInput;
  Github_ImportProjectPayload: Github_ImportProjectPayload;
  Github_InviteEnterpriseAdminInput: Github_InviteEnterpriseAdminInput;
  Github_InviteEnterpriseAdminPayload: Github_InviteEnterpriseAdminPayload;
  Github_IpAllowListEntry: Omit<Github_IpAllowListEntry, 'owner'> & { owner: ResolversParentTypes['Github_IpAllowListOwner'] };
  Github_IpAllowListEntryConnection: Github_IpAllowListEntryConnection;
  Github_IpAllowListEntryEdge: Github_IpAllowListEntryEdge;
  Github_IpAllowListEntryOrder: Github_IpAllowListEntryOrder;
  Github_IpAllowListOwner: ResolversParentTypes['Github_App'] | ResolversParentTypes['Github_Enterprise'] | ResolversParentTypes['Github_Organization'];
  Github_Issue: Github_Issue;
  Github_IssueComment: Github_IssueComment;
  Github_IssueCommentConnection: Github_IssueCommentConnection;
  Github_IssueCommentEdge: Github_IssueCommentEdge;
  Github_IssueCommentOrder: Github_IssueCommentOrder;
  Github_IssueConnection: Github_IssueConnection;
  Github_IssueContributionsByRepository: Github_IssueContributionsByRepository;
  Github_IssueEdge: Github_IssueEdge;
  Github_IssueFilters: Github_IssueFilters;
  Github_IssueOrPullRequest: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_IssueOrder: Github_IssueOrder;
  Github_IssueTemplate: Github_IssueTemplate;
  Github_IssueTimelineConnection: Omit<Github_IssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_IssueTimelineItem']>>> };
  Github_IssueTimelineItem: ResolversParentTypes['Github_AssignedEvent'] | ResolversParentTypes['Github_ClosedEvent'] | ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_CrossReferencedEvent'] | ResolversParentTypes['Github_DemilestonedEvent'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_LabeledEvent'] | ResolversParentTypes['Github_LockedEvent'] | ResolversParentTypes['Github_MilestonedEvent'] | ResolversParentTypes['Github_ReferencedEvent'] | ResolversParentTypes['Github_RenamedTitleEvent'] | ResolversParentTypes['Github_ReopenedEvent'] | ResolversParentTypes['Github_SubscribedEvent'] | ResolversParentTypes['Github_TransferredEvent'] | ResolversParentTypes['Github_UnassignedEvent'] | ResolversParentTypes['Github_UnlabeledEvent'] | ResolversParentTypes['Github_UnlockedEvent'] | ResolversParentTypes['Github_UnsubscribedEvent'] | ResolversParentTypes['Github_UserBlockedEvent'];
  Github_IssueTimelineItemEdge: Omit<Github_IssueTimelineItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_IssueTimelineItem']> };
  Github_IssueTimelineItems: ResolversParentTypes['Github_AddedToProjectEvent'] | ResolversParentTypes['Github_AssignedEvent'] | ResolversParentTypes['Github_ClosedEvent'] | ResolversParentTypes['Github_CommentDeletedEvent'] | ResolversParentTypes['Github_ConnectedEvent'] | ResolversParentTypes['Github_ConvertedNoteToIssueEvent'] | ResolversParentTypes['Github_ConvertedToDiscussionEvent'] | ResolversParentTypes['Github_CrossReferencedEvent'] | ResolversParentTypes['Github_DemilestonedEvent'] | ResolversParentTypes['Github_DisconnectedEvent'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_LabeledEvent'] | ResolversParentTypes['Github_LockedEvent'] | ResolversParentTypes['Github_MarkedAsDuplicateEvent'] | ResolversParentTypes['Github_MentionedEvent'] | ResolversParentTypes['Github_MilestonedEvent'] | ResolversParentTypes['Github_MovedColumnsInProjectEvent'] | ResolversParentTypes['Github_PinnedEvent'] | ResolversParentTypes['Github_ReferencedEvent'] | ResolversParentTypes['Github_RemovedFromProjectEvent'] | ResolversParentTypes['Github_RenamedTitleEvent'] | ResolversParentTypes['Github_ReopenedEvent'] | ResolversParentTypes['Github_SubscribedEvent'] | ResolversParentTypes['Github_TransferredEvent'] | ResolversParentTypes['Github_UnassignedEvent'] | ResolversParentTypes['Github_UnlabeledEvent'] | ResolversParentTypes['Github_UnlockedEvent'] | ResolversParentTypes['Github_UnmarkedAsDuplicateEvent'] | ResolversParentTypes['Github_UnpinnedEvent'] | ResolversParentTypes['Github_UnsubscribedEvent'] | ResolversParentTypes['Github_UserBlockedEvent'];
  Github_IssueTimelineItemsConnection: Omit<Github_IssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_IssueTimelineItems']>>> };
  Github_IssueTimelineItemsEdge: Omit<Github_IssueTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_IssueTimelineItems']> };
  Github_JoinedGitHubContribution: Github_JoinedGitHubContribution;
  Github_Label: Github_Label;
  Github_LabelConnection: Github_LabelConnection;
  Github_LabelEdge: Github_LabelEdge;
  Github_LabelOrder: Github_LabelOrder;
  Github_Labelable: ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_LabeledEvent: Github_LabeledEvent;
  Github_Language: Github_Language;
  Github_LanguageConnection: Github_LanguageConnection;
  Github_LanguageEdge: Github_LanguageEdge;
  Github_LanguageOrder: Github_LanguageOrder;
  Github_License: Github_License;
  Github_LicenseRule: Github_LicenseRule;
  Github_LinkProjectV2ToRepositoryInput: Github_LinkProjectV2ToRepositoryInput;
  Github_LinkProjectV2ToRepositoryPayload: Github_LinkProjectV2ToRepositoryPayload;
  Github_LinkProjectV2ToTeamInput: Github_LinkProjectV2ToTeamInput;
  Github_LinkProjectV2ToTeamPayload: Github_LinkProjectV2ToTeamPayload;
  Github_LinkRepositoryToProjectInput: Github_LinkRepositoryToProjectInput;
  Github_LinkRepositoryToProjectPayload: Github_LinkRepositoryToProjectPayload;
  Github_LinkedBranch: Github_LinkedBranch;
  Github_LinkedBranchConnection: Github_LinkedBranchConnection;
  Github_LinkedBranchEdge: Github_LinkedBranchEdge;
  Github_LockLockableInput: Github_LockLockableInput;
  Github_LockLockablePayload: Github_LockLockablePayload;
  Github_Lockable: ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_LockedEvent: Github_LockedEvent;
  Github_Mannequin: Github_Mannequin;
  Github_MannequinConnection: Github_MannequinConnection;
  Github_MannequinEdge: Github_MannequinEdge;
  Github_MannequinOrder: Github_MannequinOrder;
  Github_MarkDiscussionCommentAsAnswerInput: Github_MarkDiscussionCommentAsAnswerInput;
  Github_MarkDiscussionCommentAsAnswerPayload: Github_MarkDiscussionCommentAsAnswerPayload;
  Github_MarkFileAsViewedInput: Github_MarkFileAsViewedInput;
  Github_MarkFileAsViewedPayload: Github_MarkFileAsViewedPayload;
  Github_MarkPullRequestReadyForReviewInput: Github_MarkPullRequestReadyForReviewInput;
  Github_MarkPullRequestReadyForReviewPayload: Github_MarkPullRequestReadyForReviewPayload;
  Github_MarkedAsDuplicateEvent: Omit<Github_MarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversParentTypes['Github_IssueOrPullRequest']>, duplicate?: Maybe<ResolversParentTypes['Github_IssueOrPullRequest']> };
  Github_MarketplaceCategory: Github_MarketplaceCategory;
  Github_MarketplaceListing: Github_MarketplaceListing;
  Github_MarketplaceListingConnection: Github_MarketplaceListingConnection;
  Github_MarketplaceListingEdge: Github_MarketplaceListingEdge;
  Github_MemberStatusable: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_Team'];
  Github_MembersCanDeleteReposClearAuditEntry: Omit<Github_MembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_MembersCanDeleteReposDisableAuditEntry: Omit<Github_MembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_MembersCanDeleteReposEnableAuditEntry: Omit<Github_MembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_MentionedEvent: Github_MentionedEvent;
  Github_MergeBranchInput: Github_MergeBranchInput;
  Github_MergeBranchPayload: Github_MergeBranchPayload;
  Github_MergePullRequestInput: Github_MergePullRequestInput;
  Github_MergePullRequestPayload: Github_MergePullRequestPayload;
  Github_MergedEvent: Github_MergedEvent;
  Github_Migration: ResolversParentTypes['Github_RepositoryMigration'];
  Github_MigrationSource: Github_MigrationSource;
  Github_Milestone: Github_Milestone;
  Github_MilestoneConnection: Github_MilestoneConnection;
  Github_MilestoneEdge: Github_MilestoneEdge;
  Github_MilestoneItem: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_MilestoneOrder: Github_MilestoneOrder;
  Github_MilestonedEvent: Omit<Github_MilestonedEvent, 'subject'> & { subject: ResolversParentTypes['Github_MilestoneItem'] };
  Github_Minimizable: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_GistComment'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_PullRequestReviewComment'];
  Github_MinimizeCommentInput: Github_MinimizeCommentInput;
  Github_MinimizeCommentPayload: Github_MinimizeCommentPayload;
  Github_MoveProjectCardInput: Github_MoveProjectCardInput;
  Github_MoveProjectCardPayload: Github_MoveProjectCardPayload;
  Github_MoveProjectColumnInput: Github_MoveProjectColumnInput;
  Github_MoveProjectColumnPayload: Github_MoveProjectColumnPayload;
  Github_MovedColumnsInProjectEvent: Github_MovedColumnsInProjectEvent;
  Github_Node: ResolversParentTypes['Github_AddedToProjectEvent'] | ResolversParentTypes['Github_App'] | ResolversParentTypes['Github_AssignedEvent'] | ResolversParentTypes['Github_AutoMergeDisabledEvent'] | ResolversParentTypes['Github_AutoMergeEnabledEvent'] | ResolversParentTypes['Github_AutoRebaseEnabledEvent'] | ResolversParentTypes['Github_AutoSquashEnabledEvent'] | ResolversParentTypes['Github_AutomaticBaseChangeFailedEvent'] | ResolversParentTypes['Github_AutomaticBaseChangeSucceededEvent'] | ResolversParentTypes['Github_BaseRefChangedEvent'] | ResolversParentTypes['Github_BaseRefDeletedEvent'] | ResolversParentTypes['Github_BaseRefForcePushedEvent'] | ResolversParentTypes['Github_Blob'] | ResolversParentTypes['Github_Bot'] | ResolversParentTypes['Github_BranchProtectionRule'] | ResolversParentTypes['Github_BypassForcePushAllowance'] | ResolversParentTypes['Github_BypassPullRequestAllowance'] | ResolversParentTypes['Github_CWE'] | ResolversParentTypes['Github_CheckRun'] | ResolversParentTypes['Github_CheckSuite'] | ResolversParentTypes['Github_ClosedEvent'] | ResolversParentTypes['Github_CodeOfConduct'] | ResolversParentTypes['Github_CommentDeletedEvent'] | ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_CommitCommentThread'] | ResolversParentTypes['Github_Comparison'] | ResolversParentTypes['Github_ConnectedEvent'] | ResolversParentTypes['Github_ConvertToDraftEvent'] | ResolversParentTypes['Github_ConvertedNoteToIssueEvent'] | ResolversParentTypes['Github_ConvertedToDiscussionEvent'] | ResolversParentTypes['Github_CrossReferencedEvent'] | ResolversParentTypes['Github_DemilestonedEvent'] | ResolversParentTypes['Github_DependencyGraphManifest'] | ResolversParentTypes['Github_DeployKey'] | ResolversParentTypes['Github_DeployedEvent'] | ResolversParentTypes['Github_Deployment'] | ResolversParentTypes['Github_DeploymentEnvironmentChangedEvent'] | ResolversParentTypes['Github_DeploymentReview'] | ResolversParentTypes['Github_DeploymentStatus'] | ResolversParentTypes['Github_DisconnectedEvent'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionCategory'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_DiscussionPoll'] | ResolversParentTypes['Github_DiscussionPollOption'] | ResolversParentTypes['Github_DraftIssue'] | ResolversParentTypes['Github_Enterprise'] | ResolversParentTypes['Github_EnterpriseAdministratorInvitation'] | ResolversParentTypes['Github_EnterpriseIdentityProvider'] | ResolversParentTypes['Github_EnterpriseRepositoryInfo'] | ResolversParentTypes['Github_EnterpriseServerInstallation'] | ResolversParentTypes['Github_EnterpriseServerUserAccount'] | ResolversParentTypes['Github_EnterpriseServerUserAccountEmail'] | ResolversParentTypes['Github_EnterpriseServerUserAccountsUpload'] | ResolversParentTypes['Github_EnterpriseUserAccount'] | ResolversParentTypes['Github_Environment'] | ResolversParentTypes['Github_ExternalIdentity'] | ResolversParentTypes['Github_Gist'] | ResolversParentTypes['Github_GistComment'] | ResolversParentTypes['Github_HeadRefDeletedEvent'] | ResolversParentTypes['Github_HeadRefForcePushedEvent'] | ResolversParentTypes['Github_HeadRefRestoredEvent'] | ResolversParentTypes['Github_IpAllowListEntry'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_Label'] | ResolversParentTypes['Github_LabeledEvent'] | ResolversParentTypes['Github_Language'] | ResolversParentTypes['Github_License'] | ResolversParentTypes['Github_LinkedBranch'] | ResolversParentTypes['Github_LockedEvent'] | ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_MarkedAsDuplicateEvent'] | ResolversParentTypes['Github_MarketplaceCategory'] | ResolversParentTypes['Github_MarketplaceListing'] | ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversParentTypes['Github_MentionedEvent'] | ResolversParentTypes['Github_MergedEvent'] | ResolversParentTypes['Github_MigrationSource'] | ResolversParentTypes['Github_Milestone'] | ResolversParentTypes['Github_MilestonedEvent'] | ResolversParentTypes['Github_MovedColumnsInProjectEvent'] | ResolversParentTypes['Github_OIDCProvider'] | ResolversParentTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversParentTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgAddMemberAuditEntry'] | ResolversParentTypes['Github_OrgBlockUserAuditEntry'] | ResolversParentTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgCreateAuditEntry'] | ResolversParentTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgDisableSamlAuditEntry'] | ResolversParentTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgEnableSamlAuditEntry'] | ResolversParentTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgInviteMemberAuditEntry'] | ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversParentTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversParentTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversParentTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversParentTypes['Github_OrgUnblockUserAuditEntry'] | ResolversParentTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_OrganizationIdentityProvider'] | ResolversParentTypes['Github_OrganizationInvitation'] | ResolversParentTypes['Github_OrganizationMigration'] | ResolversParentTypes['Github_Package'] | ResolversParentTypes['Github_PackageFile'] | ResolversParentTypes['Github_PackageTag'] | ResolversParentTypes['Github_PackageVersion'] | ResolversParentTypes['Github_PinnedDiscussion'] | ResolversParentTypes['Github_PinnedEvent'] | ResolversParentTypes['Github_PinnedIssue'] | ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversParentTypes['Github_Project'] | ResolversParentTypes['Github_ProjectCard'] | ResolversParentTypes['Github_ProjectColumn'] | ResolversParentTypes['Github_ProjectV2'] | ResolversParentTypes['Github_ProjectV2Field'] | ResolversParentTypes['Github_ProjectV2Item'] | ResolversParentTypes['Github_ProjectV2ItemFieldDateValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldIterationValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldNumberValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldSingleSelectValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldTextValue'] | ResolversParentTypes['Github_ProjectV2IterationField'] | ResolversParentTypes['Github_ProjectV2SingleSelectField'] | ResolversParentTypes['Github_ProjectV2View'] | ResolversParentTypes['Github_ProjectV2Workflow'] | ResolversParentTypes['Github_PublicKey'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestCommit'] | ResolversParentTypes['Github_PullRequestCommitCommentThread'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_PullRequestReviewThread'] | ResolversParentTypes['Github_PullRequestThread'] | ResolversParentTypes['Github_Push'] | ResolversParentTypes['Github_PushAllowance'] | ResolversParentTypes['Github_Reaction'] | ResolversParentTypes['Github_ReadyForReviewEvent'] | ResolversParentTypes['Github_Ref'] | ResolversParentTypes['Github_ReferencedEvent'] | ResolversParentTypes['Github_Release'] | ResolversParentTypes['Github_ReleaseAsset'] | ResolversParentTypes['Github_RemovedFromProjectEvent'] | ResolversParentTypes['Github_RenamedTitleEvent'] | ResolversParentTypes['Github_ReopenedEvent'] | ResolversParentTypes['Github_RepoAccessAuditEntry'] | ResolversParentTypes['Github_RepoAddMemberAuditEntry'] | ResolversParentTypes['Github_RepoAddTopicAuditEntry'] | ResolversParentTypes['Github_RepoArchivedAuditEntry'] | ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoCreateAuditEntry'] | ResolversParentTypes['Github_RepoDestroyAuditEntry'] | ResolversParentTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_RepositoryInvitation'] | ResolversParentTypes['Github_RepositoryMigration'] | ResolversParentTypes['Github_RepositoryTopic'] | ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversParentTypes['Github_RepositoryVulnerabilityAlert'] | ResolversParentTypes['Github_ReviewDismissalAllowance'] | ResolversParentTypes['Github_ReviewDismissedEvent'] | ResolversParentTypes['Github_ReviewRequest'] | ResolversParentTypes['Github_ReviewRequestRemovedEvent'] | ResolversParentTypes['Github_ReviewRequestedEvent'] | ResolversParentTypes['Github_SavedReply'] | ResolversParentTypes['Github_SecurityAdvisory'] | ResolversParentTypes['Github_SponsorsActivity'] | ResolversParentTypes['Github_SponsorsListing'] | ResolversParentTypes['Github_SponsorsListingFeaturedItem'] | ResolversParentTypes['Github_SponsorsTier'] | ResolversParentTypes['Github_Sponsorship'] | ResolversParentTypes['Github_SponsorshipNewsletter'] | ResolversParentTypes['Github_Status'] | ResolversParentTypes['Github_StatusCheckRollup'] | ResolversParentTypes['Github_StatusContext'] | ResolversParentTypes['Github_SubscribedEvent'] | ResolversParentTypes['Github_Tag'] | ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_TeamAddMemberAuditEntry'] | ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'] | ResolversParentTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'] | ResolversParentTypes['Github_Topic'] | ResolversParentTypes['Github_TransferredEvent'] | ResolversParentTypes['Github_Tree'] | ResolversParentTypes['Github_UnassignedEvent'] | ResolversParentTypes['Github_UnlabeledEvent'] | ResolversParentTypes['Github_UnlockedEvent'] | ResolversParentTypes['Github_UnmarkedAsDuplicateEvent'] | ResolversParentTypes['Github_UnpinnedEvent'] | ResolversParentTypes['Github_UnsubscribedEvent'] | ResolversParentTypes['Github_User'] | ResolversParentTypes['Github_UserBlockedEvent'] | ResolversParentTypes['Github_UserContentEdit'] | ResolversParentTypes['Github_UserStatus'] | ResolversParentTypes['Github_VerifiableDomain'] | ResolversParentTypes['Github_Workflow'] | ResolversParentTypes['Github_WorkflowRun'];
  Github_OIDCProvider: Github_OIDCProvider;
  Github_OauthApplicationAuditEntryData: ResolversParentTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry'];
  Github_OauthApplicationCreateAuditEntry: Omit<Github_OauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgAddBillingManagerAuditEntry: Omit<Github_OrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgAddMemberAuditEntry: Omit<Github_OrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgBlockUserAuditEntry: Omit<Github_OrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgConfigDisableCollaboratorsOnlyAuditEntry: Omit<Github_OrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgConfigEnableCollaboratorsOnlyAuditEntry: Omit<Github_OrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgCreateAuditEntry: Omit<Github_OrgCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgDisableOauthAppRestrictionsAuditEntry: Omit<Github_OrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgDisableSamlAuditEntry: Omit<Github_OrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgDisableTwoFactorRequirementAuditEntry: Omit<Github_OrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgEnableOauthAppRestrictionsAuditEntry: Omit<Github_OrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgEnableSamlAuditEntry: Omit<Github_OrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgEnableTwoFactorRequirementAuditEntry: Omit<Github_OrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgEnterpriseOwnerOrder: Github_OrgEnterpriseOwnerOrder;
  Github_OrgInviteMemberAuditEntry: Omit<Github_OrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgInviteToBusinessAuditEntry: Omit<Github_OrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgOauthAppAccessApprovedAuditEntry: Omit<Github_OrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgOauthAppAccessDeniedAuditEntry: Omit<Github_OrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgOauthAppAccessRequestedAuditEntry: Omit<Github_OrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgRemoveBillingManagerAuditEntry: Omit<Github_OrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgRemoveMemberAuditEntry: Omit<Github_OrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgRemoveOutsideCollaboratorAuditEntry: Omit<Github_OrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgRestoreMemberAuditEntry: Omit<Github_OrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']>, restoredMemberships?: Maybe<Array<ResolversParentTypes['Github_OrgRestoreMemberAuditEntryMembership']>> };
  Github_OrgRestoreMemberAuditEntryMembership: ResolversParentTypes['Github_OrgRestoreMemberMembershipOrganizationAuditEntryData'] | ResolversParentTypes['Github_OrgRestoreMemberMembershipRepositoryAuditEntryData'] | ResolversParentTypes['Github_OrgRestoreMemberMembershipTeamAuditEntryData'];
  Github_OrgRestoreMemberMembershipOrganizationAuditEntryData: Github_OrgRestoreMemberMembershipOrganizationAuditEntryData;
  Github_OrgRestoreMemberMembershipRepositoryAuditEntryData: Github_OrgRestoreMemberMembershipRepositoryAuditEntryData;
  Github_OrgRestoreMemberMembershipTeamAuditEntryData: Github_OrgRestoreMemberMembershipTeamAuditEntryData;
  Github_OrgUnblockUserAuditEntry: Omit<Github_OrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgUpdateDefaultRepositoryPermissionAuditEntry: Omit<Github_OrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgUpdateMemberAuditEntry: Omit<Github_OrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry: Omit<Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: Omit<Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_Organization: Github_Organization;
  Github_OrganizationAuditEntry: ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversParentTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversParentTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgAddMemberAuditEntry'] | ResolversParentTypes['Github_OrgBlockUserAuditEntry'] | ResolversParentTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgCreateAuditEntry'] | ResolversParentTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgDisableSamlAuditEntry'] | ResolversParentTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgEnableSamlAuditEntry'] | ResolversParentTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgInviteMemberAuditEntry'] | ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversParentTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversParentTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversParentTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversParentTypes['Github_OrgUnblockUserAuditEntry'] | ResolversParentTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversParentTypes['Github_RepoAccessAuditEntry'] | ResolversParentTypes['Github_RepoAddMemberAuditEntry'] | ResolversParentTypes['Github_RepoAddTopicAuditEntry'] | ResolversParentTypes['Github_RepoArchivedAuditEntry'] | ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoCreateAuditEntry'] | ResolversParentTypes['Github_RepoDestroyAuditEntry'] | ResolversParentTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversParentTypes['Github_TeamAddMemberAuditEntry'] | ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversParentTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_OrganizationAuditEntryConnection: Omit<Github_OrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_OrganizationAuditEntry']>>> };
  Github_OrganizationAuditEntryData: ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry'] | ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry'] | ResolversParentTypes['Github_OauthApplicationCreateAuditEntry'] | ResolversParentTypes['Github_OrgAddBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgAddMemberAuditEntry'] | ResolversParentTypes['Github_OrgBlockUserAuditEntry'] | ResolversParentTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_OrgCreateAuditEntry'] | ResolversParentTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgDisableSamlAuditEntry'] | ResolversParentTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] | ResolversParentTypes['Github_OrgEnableSamlAuditEntry'] | ResolversParentTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] | ResolversParentTypes['Github_OrgInviteMemberAuditEntry'] | ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] | ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] | ResolversParentTypes['Github_OrgRemoveBillingManagerAuditEntry'] | ResolversParentTypes['Github_OrgRemoveMemberAuditEntry'] | ResolversParentTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] | ResolversParentTypes['Github_OrgRestoreMemberAuditEntry'] | ResolversParentTypes['Github_OrgRestoreMemberMembershipOrganizationAuditEntryData'] | ResolversParentTypes['Github_OrgUnblockUserAuditEntry'] | ResolversParentTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | ResolversParentTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversParentTypes['Github_RepoAccessAuditEntry'] | ResolversParentTypes['Github_RepoAddMemberAuditEntry'] | ResolversParentTypes['Github_RepoAddTopicAuditEntry'] | ResolversParentTypes['Github_RepoArchivedAuditEntry'] | ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoCreateAuditEntry'] | ResolversParentTypes['Github_RepoDestroyAuditEntry'] | ResolversParentTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] | ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] | ResolversParentTypes['Github_TeamAddMemberAuditEntry'] | ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversParentTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_OrganizationAuditEntryEdge: Omit<Github_OrganizationAuditEntryEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_OrganizationAuditEntry']> };
  Github_OrganizationConnection: Github_OrganizationConnection;
  Github_OrganizationEdge: Github_OrganizationEdge;
  Github_OrganizationEnterpriseOwnerConnection: Github_OrganizationEnterpriseOwnerConnection;
  Github_OrganizationEnterpriseOwnerEdge: Github_OrganizationEnterpriseOwnerEdge;
  Github_OrganizationIdentityProvider: Github_OrganizationIdentityProvider;
  Github_OrganizationInvitation: Github_OrganizationInvitation;
  Github_OrganizationInvitationConnection: Github_OrganizationInvitationConnection;
  Github_OrganizationInvitationEdge: Github_OrganizationInvitationEdge;
  Github_OrganizationMemberConnection: Github_OrganizationMemberConnection;
  Github_OrganizationMemberEdge: Github_OrganizationMemberEdge;
  Github_OrganizationMigration: Github_OrganizationMigration;
  Github_OrganizationOrUser: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_OrganizationOrder: Github_OrganizationOrder;
  Github_OrganizationTeamsHovercardContext: Github_OrganizationTeamsHovercardContext;
  Github_OrganizationsHovercardContext: Github_OrganizationsHovercardContext;
  Github_Package: Github_Package;
  Github_PackageConnection: Github_PackageConnection;
  Github_PackageEdge: Github_PackageEdge;
  Github_PackageFile: Github_PackageFile;
  Github_PackageFileConnection: Github_PackageFileConnection;
  Github_PackageFileEdge: Github_PackageFileEdge;
  Github_PackageFileOrder: Github_PackageFileOrder;
  Github_PackageOrder: Github_PackageOrder;
  Github_PackageOwner: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_User'];
  Github_PackageStatistics: Github_PackageStatistics;
  Github_PackageTag: Github_PackageTag;
  Github_PackageVersion: Github_PackageVersion;
  Github_PackageVersionConnection: Github_PackageVersionConnection;
  Github_PackageVersionEdge: Github_PackageVersionEdge;
  Github_PackageVersionOrder: Github_PackageVersionOrder;
  Github_PackageVersionStatistics: Github_PackageVersionStatistics;
  Github_PageInfo: Github_PageInfo;
  Github_PermissionGranter: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_Team'];
  Github_PermissionSource: Omit<Github_PermissionSource, 'source'> & { source: ResolversParentTypes['Github_PermissionGranter'] };
  Github_PinIssueInput: Github_PinIssueInput;
  Github_PinIssuePayload: Github_PinIssuePayload;
  Github_PinnableItem: ResolversParentTypes['Github_Gist'] | ResolversParentTypes['Github_Repository'];
  Github_PinnableItemConnection: Omit<Github_PinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_PinnableItem']>>> };
  Github_PinnableItemEdge: Omit<Github_PinnableItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_PinnableItem']> };
  Github_PinnedDiscussion: Github_PinnedDiscussion;
  Github_PinnedDiscussionConnection: Github_PinnedDiscussionConnection;
  Github_PinnedDiscussionEdge: Github_PinnedDiscussionEdge;
  Github_PinnedEvent: Github_PinnedEvent;
  Github_PinnedIssue: Github_PinnedIssue;
  Github_PinnedIssueConnection: Github_PinnedIssueConnection;
  Github_PinnedIssueEdge: Github_PinnedIssueEdge;
  Github_PreciseDateTime: Scalars['Github_PreciseDateTime'];
  Github_PrivateRepositoryForkingDisableAuditEntry: Omit<Github_PrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_PrivateRepositoryForkingEnableAuditEntry: Omit<Github_PrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_ProfileItemShowcase: Github_ProfileItemShowcase;
  Github_ProfileOwner: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_Project: Github_Project;
  Github_ProjectCard: Omit<Github_ProjectCard, 'content'> & { content?: Maybe<ResolversParentTypes['Github_ProjectCardItem']> };
  Github_ProjectCardConnection: Github_ProjectCardConnection;
  Github_ProjectCardEdge: Github_ProjectCardEdge;
  Github_ProjectCardImport: Github_ProjectCardImport;
  Github_ProjectCardItem: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_ProjectColumn: Github_ProjectColumn;
  Github_ProjectColumnConnection: Github_ProjectColumnConnection;
  Github_ProjectColumnEdge: Github_ProjectColumnEdge;
  Github_ProjectColumnImport: Github_ProjectColumnImport;
  Github_ProjectConnection: Github_ProjectConnection;
  Github_ProjectEdge: Github_ProjectEdge;
  Github_ProjectOrder: Github_ProjectOrder;
  Github_ProjectOwner: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_User'];
  Github_ProjectProgress: Github_ProjectProgress;
  Github_ProjectV2: Omit<Github_ProjectV2, 'field'> & { field?: Maybe<ResolversParentTypes['Github_ProjectV2FieldConfiguration']> };
  Github_ProjectV2Connection: Github_ProjectV2Connection;
  Github_ProjectV2Edge: Github_ProjectV2Edge;
  Github_ProjectV2Field: Github_ProjectV2Field;
  Github_ProjectV2FieldCommon: ResolversParentTypes['Github_ProjectV2Field'] | ResolversParentTypes['Github_ProjectV2IterationField'] | ResolversParentTypes['Github_ProjectV2SingleSelectField'];
  Github_ProjectV2FieldConfiguration: ResolversParentTypes['Github_ProjectV2Field'] | ResolversParentTypes['Github_ProjectV2IterationField'] | ResolversParentTypes['Github_ProjectV2SingleSelectField'];
  Github_ProjectV2FieldConfigurationConnection: Omit<Github_ProjectV2FieldConfigurationConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_ProjectV2FieldConfiguration']>>> };
  Github_ProjectV2FieldConfigurationEdge: Omit<Github_ProjectV2FieldConfigurationEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_ProjectV2FieldConfiguration']> };
  Github_ProjectV2FieldConnection: Github_ProjectV2FieldConnection;
  Github_ProjectV2FieldEdge: Github_ProjectV2FieldEdge;
  Github_ProjectV2FieldOrder: Github_ProjectV2FieldOrder;
  Github_ProjectV2FieldValue: Github_ProjectV2FieldValue;
  Github_ProjectV2Filters: Github_ProjectV2Filters;
  Github_ProjectV2Item: Omit<Github_ProjectV2Item, 'content' | 'fieldValueByName'> & { content?: Maybe<ResolversParentTypes['Github_ProjectV2ItemContent']>, fieldValueByName?: Maybe<ResolversParentTypes['Github_ProjectV2ItemFieldValue']> };
  Github_ProjectV2ItemConnection: Github_ProjectV2ItemConnection;
  Github_ProjectV2ItemContent: ResolversParentTypes['Github_DraftIssue'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_ProjectV2ItemEdge: Github_ProjectV2ItemEdge;
  Github_ProjectV2ItemFieldDateValue: Omit<Github_ProjectV2ItemFieldDateValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldIterationValue: Omit<Github_ProjectV2ItemFieldIterationValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldLabelValue: Omit<Github_ProjectV2ItemFieldLabelValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldMilestoneValue: Omit<Github_ProjectV2ItemFieldMilestoneValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldNumberValue: Omit<Github_ProjectV2ItemFieldNumberValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldPullRequestValue: Omit<Github_ProjectV2ItemFieldPullRequestValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldRepositoryValue: Omit<Github_ProjectV2ItemFieldRepositoryValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldReviewerValue: Omit<Github_ProjectV2ItemFieldReviewerValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldSingleSelectValue: Omit<Github_ProjectV2ItemFieldSingleSelectValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldTextValue: Omit<Github_ProjectV2ItemFieldTextValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldUserValue: Omit<Github_ProjectV2ItemFieldUserValue, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2ItemFieldValue: ResolversParentTypes['Github_ProjectV2ItemFieldDateValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldIterationValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldLabelValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldMilestoneValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldNumberValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldPullRequestValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldRepositoryValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldReviewerValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldSingleSelectValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldTextValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldUserValue'];
  Github_ProjectV2ItemFieldValueCommon: ResolversParentTypes['Github_ProjectV2ItemFieldDateValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldIterationValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldNumberValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldSingleSelectValue'] | ResolversParentTypes['Github_ProjectV2ItemFieldTextValue'];
  Github_ProjectV2ItemFieldValueConnection: Omit<Github_ProjectV2ItemFieldValueConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_ProjectV2ItemFieldValue']>>> };
  Github_ProjectV2ItemFieldValueEdge: Omit<Github_ProjectV2ItemFieldValueEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_ProjectV2ItemFieldValue']> };
  Github_ProjectV2ItemFieldValueOrder: Github_ProjectV2ItemFieldValueOrder;
  Github_ProjectV2ItemOrder: Github_ProjectV2ItemOrder;
  Github_ProjectV2IterationField: Github_ProjectV2IterationField;
  Github_ProjectV2IterationFieldConfiguration: Github_ProjectV2IterationFieldConfiguration;
  Github_ProjectV2IterationFieldIteration: Github_ProjectV2IterationFieldIteration;
  Github_ProjectV2Order: Github_ProjectV2Order;
  Github_ProjectV2Owner: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_User'];
  Github_ProjectV2Recent: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_User'];
  Github_ProjectV2SingleSelectField: Github_ProjectV2SingleSelectField;
  Github_ProjectV2SingleSelectFieldOption: Github_ProjectV2SingleSelectFieldOption;
  Github_ProjectV2SortBy: Github_ProjectV2SortBy;
  Github_ProjectV2SortByConnection: Github_ProjectV2SortByConnection;
  Github_ProjectV2SortByEdge: Github_ProjectV2SortByEdge;
  Github_ProjectV2SortByField: Omit<Github_ProjectV2SortByField, 'field'> & { field: ResolversParentTypes['Github_ProjectV2FieldConfiguration'] };
  Github_ProjectV2SortByFieldConnection: Github_ProjectV2SortByFieldConnection;
  Github_ProjectV2SortByFieldEdge: Github_ProjectV2SortByFieldEdge;
  Github_ProjectV2View: Github_ProjectV2View;
  Github_ProjectV2ViewConnection: Github_ProjectV2ViewConnection;
  Github_ProjectV2ViewEdge: Github_ProjectV2ViewEdge;
  Github_ProjectV2ViewOrder: Github_ProjectV2ViewOrder;
  Github_ProjectV2Workflow: Github_ProjectV2Workflow;
  Github_ProjectV2WorkflowConnection: Github_ProjectV2WorkflowConnection;
  Github_ProjectV2WorkflowEdge: Github_ProjectV2WorkflowEdge;
  Github_ProjectV2WorkflowOrder: Github_ProjectV2WorkflowOrder;
  Github_PublicKey: Github_PublicKey;
  Github_PublicKeyConnection: Github_PublicKeyConnection;
  Github_PublicKeyEdge: Github_PublicKeyEdge;
  Github_PublishSponsorsTierInput: Github_PublishSponsorsTierInput;
  Github_PublishSponsorsTierPayload: Github_PublishSponsorsTierPayload;
  Github_PullRequest: Github_PullRequest;
  Github_PullRequestChangedFile: Github_PullRequestChangedFile;
  Github_PullRequestChangedFileConnection: Github_PullRequestChangedFileConnection;
  Github_PullRequestChangedFileEdge: Github_PullRequestChangedFileEdge;
  Github_PullRequestCommit: Github_PullRequestCommit;
  Github_PullRequestCommitCommentThread: Github_PullRequestCommitCommentThread;
  Github_PullRequestCommitConnection: Github_PullRequestCommitConnection;
  Github_PullRequestCommitEdge: Github_PullRequestCommitEdge;
  Github_PullRequestConnection: Github_PullRequestConnection;
  Github_PullRequestContributionsByRepository: Github_PullRequestContributionsByRepository;
  Github_PullRequestEdge: Github_PullRequestEdge;
  Github_PullRequestOrder: Github_PullRequestOrder;
  Github_PullRequestReview: Github_PullRequestReview;
  Github_PullRequestReviewComment: Github_PullRequestReviewComment;
  Github_PullRequestReviewCommentConnection: Github_PullRequestReviewCommentConnection;
  Github_PullRequestReviewCommentEdge: Github_PullRequestReviewCommentEdge;
  Github_PullRequestReviewConnection: Github_PullRequestReviewConnection;
  Github_PullRequestReviewContributionsByRepository: Github_PullRequestReviewContributionsByRepository;
  Github_PullRequestReviewEdge: Github_PullRequestReviewEdge;
  Github_PullRequestReviewThread: Github_PullRequestReviewThread;
  Github_PullRequestReviewThreadConnection: Github_PullRequestReviewThreadConnection;
  Github_PullRequestReviewThreadEdge: Github_PullRequestReviewThreadEdge;
  Github_PullRequestRevisionMarker: Github_PullRequestRevisionMarker;
  Github_PullRequestTemplate: Github_PullRequestTemplate;
  Github_PullRequestThread: Github_PullRequestThread;
  Github_PullRequestTimelineConnection: Omit<Github_PullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_PullRequestTimelineItem']>>> };
  Github_PullRequestTimelineItem: ResolversParentTypes['Github_AssignedEvent'] | ResolversParentTypes['Github_BaseRefDeletedEvent'] | ResolversParentTypes['Github_BaseRefForcePushedEvent'] | ResolversParentTypes['Github_ClosedEvent'] | ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_CommitCommentThread'] | ResolversParentTypes['Github_CrossReferencedEvent'] | ResolversParentTypes['Github_DemilestonedEvent'] | ResolversParentTypes['Github_DeployedEvent'] | ResolversParentTypes['Github_DeploymentEnvironmentChangedEvent'] | ResolversParentTypes['Github_HeadRefDeletedEvent'] | ResolversParentTypes['Github_HeadRefForcePushedEvent'] | ResolversParentTypes['Github_HeadRefRestoredEvent'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_LabeledEvent'] | ResolversParentTypes['Github_LockedEvent'] | ResolversParentTypes['Github_MergedEvent'] | ResolversParentTypes['Github_MilestonedEvent'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_PullRequestReviewThread'] | ResolversParentTypes['Github_ReferencedEvent'] | ResolversParentTypes['Github_RenamedTitleEvent'] | ResolversParentTypes['Github_ReopenedEvent'] | ResolversParentTypes['Github_ReviewDismissedEvent'] | ResolversParentTypes['Github_ReviewRequestRemovedEvent'] | ResolversParentTypes['Github_ReviewRequestedEvent'] | ResolversParentTypes['Github_SubscribedEvent'] | ResolversParentTypes['Github_UnassignedEvent'] | ResolversParentTypes['Github_UnlabeledEvent'] | ResolversParentTypes['Github_UnlockedEvent'] | ResolversParentTypes['Github_UnsubscribedEvent'] | ResolversParentTypes['Github_UserBlockedEvent'];
  Github_PullRequestTimelineItemEdge: Omit<Github_PullRequestTimelineItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_PullRequestTimelineItem']> };
  Github_PullRequestTimelineItems: ResolversParentTypes['Github_AddedToProjectEvent'] | ResolversParentTypes['Github_AssignedEvent'] | ResolversParentTypes['Github_AutoMergeDisabledEvent'] | ResolversParentTypes['Github_AutoMergeEnabledEvent'] | ResolversParentTypes['Github_AutoRebaseEnabledEvent'] | ResolversParentTypes['Github_AutoSquashEnabledEvent'] | ResolversParentTypes['Github_AutomaticBaseChangeFailedEvent'] | ResolversParentTypes['Github_AutomaticBaseChangeSucceededEvent'] | ResolversParentTypes['Github_BaseRefChangedEvent'] | ResolversParentTypes['Github_BaseRefDeletedEvent'] | ResolversParentTypes['Github_BaseRefForcePushedEvent'] | ResolversParentTypes['Github_ClosedEvent'] | ResolversParentTypes['Github_CommentDeletedEvent'] | ResolversParentTypes['Github_ConnectedEvent'] | ResolversParentTypes['Github_ConvertToDraftEvent'] | ResolversParentTypes['Github_ConvertedNoteToIssueEvent'] | ResolversParentTypes['Github_ConvertedToDiscussionEvent'] | ResolversParentTypes['Github_CrossReferencedEvent'] | ResolversParentTypes['Github_DemilestonedEvent'] | ResolversParentTypes['Github_DeployedEvent'] | ResolversParentTypes['Github_DeploymentEnvironmentChangedEvent'] | ResolversParentTypes['Github_DisconnectedEvent'] | ResolversParentTypes['Github_HeadRefDeletedEvent'] | ResolversParentTypes['Github_HeadRefForcePushedEvent'] | ResolversParentTypes['Github_HeadRefRestoredEvent'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_LabeledEvent'] | ResolversParentTypes['Github_LockedEvent'] | ResolversParentTypes['Github_MarkedAsDuplicateEvent'] | ResolversParentTypes['Github_MentionedEvent'] | ResolversParentTypes['Github_MergedEvent'] | ResolversParentTypes['Github_MilestonedEvent'] | ResolversParentTypes['Github_MovedColumnsInProjectEvent'] | ResolversParentTypes['Github_PinnedEvent'] | ResolversParentTypes['Github_PullRequestCommit'] | ResolversParentTypes['Github_PullRequestCommitCommentThread'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewThread'] | ResolversParentTypes['Github_PullRequestRevisionMarker'] | ResolversParentTypes['Github_ReadyForReviewEvent'] | ResolversParentTypes['Github_ReferencedEvent'] | ResolversParentTypes['Github_RemovedFromProjectEvent'] | ResolversParentTypes['Github_RenamedTitleEvent'] | ResolversParentTypes['Github_ReopenedEvent'] | ResolversParentTypes['Github_ReviewDismissedEvent'] | ResolversParentTypes['Github_ReviewRequestRemovedEvent'] | ResolversParentTypes['Github_ReviewRequestedEvent'] | ResolversParentTypes['Github_SubscribedEvent'] | ResolversParentTypes['Github_TransferredEvent'] | ResolversParentTypes['Github_UnassignedEvent'] | ResolversParentTypes['Github_UnlabeledEvent'] | ResolversParentTypes['Github_UnlockedEvent'] | ResolversParentTypes['Github_UnmarkedAsDuplicateEvent'] | ResolversParentTypes['Github_UnpinnedEvent'] | ResolversParentTypes['Github_UnsubscribedEvent'] | ResolversParentTypes['Github_UserBlockedEvent'];
  Github_PullRequestTimelineItemsConnection: Omit<Github_PullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_PullRequestTimelineItems']>>> };
  Github_PullRequestTimelineItemsEdge: Omit<Github_PullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_PullRequestTimelineItems']> };
  Github_Push: Github_Push;
  Github_PushAllowance: Omit<Github_PushAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_PushAllowanceActor']> };
  Github_PushAllowanceActor: ResolversParentTypes['Github_App'] | ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_User'];
  Github_PushAllowanceConnection: Github_PushAllowanceConnection;
  Github_PushAllowanceEdge: Github_PushAllowanceEdge;
  Github_RateLimit: Github_RateLimit;
  Github_Reactable: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_Release'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'];
  Github_ReactingUserConnection: Github_ReactingUserConnection;
  Github_ReactingUserEdge: Github_ReactingUserEdge;
  Github_Reaction: Github_Reaction;
  Github_ReactionConnection: Github_ReactionConnection;
  Github_ReactionEdge: Github_ReactionEdge;
  Github_ReactionGroup: Github_ReactionGroup;
  Github_ReactionOrder: Github_ReactionOrder;
  Github_Reactor: ResolversParentTypes['Github_Bot'] | ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_ReactorConnection: Omit<Github_ReactorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_Reactor']>>> };
  Github_ReactorEdge: Omit<Github_ReactorEdge, 'node'> & { node: ResolversParentTypes['Github_Reactor'] };
  Github_ReadyForReviewEvent: Github_ReadyForReviewEvent;
  Github_Ref: Github_Ref;
  Github_RefConnection: Github_RefConnection;
  Github_RefEdge: Github_RefEdge;
  Github_RefOrder: Github_RefOrder;
  Github_RefUpdate: Github_RefUpdate;
  Github_RefUpdateRule: Github_RefUpdateRule;
  Github_ReferencedEvent: Omit<Github_ReferencedEvent, 'subject'> & { subject: ResolversParentTypes['Github_ReferencedSubject'] };
  Github_ReferencedSubject: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput: Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload;
  Github_RegenerateVerifiableDomainTokenInput: Github_RegenerateVerifiableDomainTokenInput;
  Github_RegenerateVerifiableDomainTokenPayload: Github_RegenerateVerifiableDomainTokenPayload;
  Github_RejectDeploymentsInput: Github_RejectDeploymentsInput;
  Github_RejectDeploymentsPayload: Github_RejectDeploymentsPayload;
  Github_Release: Github_Release;
  Github_ReleaseAsset: Github_ReleaseAsset;
  Github_ReleaseAssetConnection: Github_ReleaseAssetConnection;
  Github_ReleaseAssetEdge: Github_ReleaseAssetEdge;
  Github_ReleaseConnection: Github_ReleaseConnection;
  Github_ReleaseEdge: Github_ReleaseEdge;
  Github_ReleaseOrder: Github_ReleaseOrder;
  Github_RemoveAssigneesFromAssignableInput: Github_RemoveAssigneesFromAssignableInput;
  Github_RemoveAssigneesFromAssignablePayload: Github_RemoveAssigneesFromAssignablePayload;
  Github_RemoveEnterpriseAdminInput: Github_RemoveEnterpriseAdminInput;
  Github_RemoveEnterpriseAdminPayload: Github_RemoveEnterpriseAdminPayload;
  Github_RemoveEnterpriseIdentityProviderInput: Github_RemoveEnterpriseIdentityProviderInput;
  Github_RemoveEnterpriseIdentityProviderPayload: Github_RemoveEnterpriseIdentityProviderPayload;
  Github_RemoveEnterpriseMemberInput: Github_RemoveEnterpriseMemberInput;
  Github_RemoveEnterpriseMemberPayload: Github_RemoveEnterpriseMemberPayload;
  Github_RemoveEnterpriseOrganizationInput: Github_RemoveEnterpriseOrganizationInput;
  Github_RemoveEnterpriseOrganizationPayload: Github_RemoveEnterpriseOrganizationPayload;
  Github_RemoveEnterpriseSupportEntitlementInput: Github_RemoveEnterpriseSupportEntitlementInput;
  Github_RemoveEnterpriseSupportEntitlementPayload: Github_RemoveEnterpriseSupportEntitlementPayload;
  Github_RemoveLabelsFromLabelableInput: Github_RemoveLabelsFromLabelableInput;
  Github_RemoveLabelsFromLabelablePayload: Github_RemoveLabelsFromLabelablePayload;
  Github_RemoveOutsideCollaboratorInput: Github_RemoveOutsideCollaboratorInput;
  Github_RemoveOutsideCollaboratorPayload: Github_RemoveOutsideCollaboratorPayload;
  Github_RemoveReactionInput: Github_RemoveReactionInput;
  Github_RemoveReactionPayload: Github_RemoveReactionPayload;
  Github_RemoveStarInput: Github_RemoveStarInput;
  Github_RemoveStarPayload: Github_RemoveStarPayload;
  Github_RemoveUpvoteInput: Github_RemoveUpvoteInput;
  Github_RemoveUpvotePayload: Github_RemoveUpvotePayload;
  Github_RemovedFromProjectEvent: Github_RemovedFromProjectEvent;
  Github_RenamedTitleEvent: Omit<Github_RenamedTitleEvent, 'subject'> & { subject: ResolversParentTypes['Github_RenamedTitleSubject'] };
  Github_RenamedTitleSubject: ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'];
  Github_ReopenIssueInput: Github_ReopenIssueInput;
  Github_ReopenIssuePayload: Github_ReopenIssuePayload;
  Github_ReopenPullRequestInput: Github_ReopenPullRequestInput;
  Github_ReopenPullRequestPayload: Github_ReopenPullRequestPayload;
  Github_ReopenedEvent: Github_ReopenedEvent;
  Github_RepoAccessAuditEntry: Omit<Github_RepoAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoAddMemberAuditEntry: Omit<Github_RepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoAddTopicAuditEntry: Omit<Github_RepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoArchivedAuditEntry: Omit<Github_RepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoChangeMergeSettingAuditEntry: Omit<Github_RepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigDisableAnonymousGitAccessAuditEntry: Omit<Github_RepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigDisableCollaboratorsOnlyAuditEntry: Omit<Github_RepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigDisableContributorsOnlyAuditEntry: Omit<Github_RepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigDisableSockpuppetDisallowedAuditEntry: Omit<Github_RepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigEnableAnonymousGitAccessAuditEntry: Omit<Github_RepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigEnableCollaboratorsOnlyAuditEntry: Omit<Github_RepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigEnableContributorsOnlyAuditEntry: Omit<Github_RepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigEnableSockpuppetDisallowedAuditEntry: Omit<Github_RepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigLockAnonymousGitAccessAuditEntry: Omit<Github_RepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoConfigUnlockAnonymousGitAccessAuditEntry: Omit<Github_RepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoCreateAuditEntry: Omit<Github_RepoCreateAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoDestroyAuditEntry: Omit<Github_RepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoRemoveMemberAuditEntry: Omit<Github_RepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepoRemoveTopicAuditEntry: Omit<Github_RepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_Repository: Omit<Github_Repository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<ResolversParentTypes['Github_IssueOrPullRequest']> };
  Github_RepositoryAuditEntryData: ResolversParentTypes['Github_OrgRestoreMemberMembershipRepositoryAuditEntryData'] | ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] | ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] | ResolversParentTypes['Github_RepoAccessAuditEntry'] | ResolversParentTypes['Github_RepoAddMemberAuditEntry'] | ResolversParentTypes['Github_RepoAddTopicAuditEntry'] | ResolversParentTypes['Github_RepoArchivedAuditEntry'] | ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] | ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] | ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] | ResolversParentTypes['Github_RepoCreateAuditEntry'] | ResolversParentTypes['Github_RepoDestroyAuditEntry'] | ResolversParentTypes['Github_RepoRemoveMemberAuditEntry'] | ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'] | ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_RepositoryCodeowners: Github_RepositoryCodeowners;
  Github_RepositoryCodeownersError: Github_RepositoryCodeownersError;
  Github_RepositoryCollaboratorConnection: Github_RepositoryCollaboratorConnection;
  Github_RepositoryCollaboratorEdge: Github_RepositoryCollaboratorEdge;
  Github_RepositoryConnection: Github_RepositoryConnection;
  Github_RepositoryContactLink: Github_RepositoryContactLink;
  Github_RepositoryDiscussionAuthor: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_RepositoryDiscussionCommentAuthor: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_RepositoryEdge: Github_RepositoryEdge;
  Github_RepositoryInfo: ResolversParentTypes['Github_Repository'];
  Github_RepositoryInteractionAbility: Github_RepositoryInteractionAbility;
  Github_RepositoryInvitation: Github_RepositoryInvitation;
  Github_RepositoryInvitationConnection: Github_RepositoryInvitationConnection;
  Github_RepositoryInvitationEdge: Github_RepositoryInvitationEdge;
  Github_RepositoryInvitationOrder: Github_RepositoryInvitationOrder;
  Github_RepositoryMigration: Github_RepositoryMigration;
  Github_RepositoryMigrationConnection: Github_RepositoryMigrationConnection;
  Github_RepositoryMigrationEdge: Github_RepositoryMigrationEdge;
  Github_RepositoryMigrationOrder: Github_RepositoryMigrationOrder;
  Github_RepositoryNode: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_CommitCommentThread'] | ResolversParentTypes['Github_DependabotUpdate'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionCategory'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_PinnedDiscussion'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestCommitCommentThread'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_RepositoryVulnerabilityAlert'];
  Github_RepositoryOrder: Github_RepositoryOrder;
  Github_RepositoryOwner: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_RepositoryTopic: Github_RepositoryTopic;
  Github_RepositoryTopicConnection: Github_RepositoryTopicConnection;
  Github_RepositoryTopicEdge: Github_RepositoryTopicEdge;
  Github_RepositoryVisibilityChangeDisableAuditEntry: Omit<Github_RepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepositoryVisibilityChangeEnableAuditEntry: Omit<Github_RepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_RepositoryVulnerabilityAlert: Github_RepositoryVulnerabilityAlert;
  Github_RepositoryVulnerabilityAlertConnection: Github_RepositoryVulnerabilityAlertConnection;
  Github_RepositoryVulnerabilityAlertEdge: Github_RepositoryVulnerabilityAlertEdge;
  Github_RequestReviewsInput: Github_RequestReviewsInput;
  Github_RequestReviewsPayload: Github_RequestReviewsPayload;
  Github_RequestedReviewer: ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_User'];
  Github_RequestedReviewerConnection: Omit<Github_RequestedReviewerConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_RequestedReviewer']>>> };
  Github_RequestedReviewerEdge: Omit<Github_RequestedReviewerEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_RequestedReviewer']> };
  Github_RequirableByPullRequest: ResolversParentTypes['Github_CheckRun'] | ResolversParentTypes['Github_StatusContext'];
  Github_RequiredStatusCheckDescription: Github_RequiredStatusCheckDescription;
  Github_RequiredStatusCheckInput: Github_RequiredStatusCheckInput;
  Github_RerequestCheckSuiteInput: Github_RerequestCheckSuiteInput;
  Github_RerequestCheckSuitePayload: Github_RerequestCheckSuitePayload;
  Github_ResolveReviewThreadInput: Github_ResolveReviewThreadInput;
  Github_ResolveReviewThreadPayload: Github_ResolveReviewThreadPayload;
  Github_RestrictedContribution: Github_RestrictedContribution;
  Github_RetireSponsorsTierInput: Github_RetireSponsorsTierInput;
  Github_RetireSponsorsTierPayload: Github_RetireSponsorsTierPayload;
  Github_RevertPullRequestInput: Github_RevertPullRequestInput;
  Github_RevertPullRequestPayload: Github_RevertPullRequestPayload;
  Github_ReviewDismissalAllowance: Omit<Github_ReviewDismissalAllowance, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_ReviewDismissalAllowanceActor']> };
  Github_ReviewDismissalAllowanceActor: ResolversParentTypes['Github_App'] | ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_User'];
  Github_ReviewDismissalAllowanceConnection: Github_ReviewDismissalAllowanceConnection;
  Github_ReviewDismissalAllowanceEdge: Github_ReviewDismissalAllowanceEdge;
  Github_ReviewDismissedEvent: Github_ReviewDismissedEvent;
  Github_ReviewRequest: Omit<Github_ReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['Github_RequestedReviewer']> };
  Github_ReviewRequestConnection: Github_ReviewRequestConnection;
  Github_ReviewRequestEdge: Github_ReviewRequestEdge;
  Github_ReviewRequestRemovedEvent: Omit<Github_ReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['Github_RequestedReviewer']> };
  Github_ReviewRequestedEvent: Omit<Github_ReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<ResolversParentTypes['Github_RequestedReviewer']> };
  Github_ReviewStatusHovercardContext: Github_ReviewStatusHovercardContext;
  Github_RevokeEnterpriseOrganizationsMigratorRoleInput: Github_RevokeEnterpriseOrganizationsMigratorRoleInput;
  Github_RevokeEnterpriseOrganizationsMigratorRolePayload: Github_RevokeEnterpriseOrganizationsMigratorRolePayload;
  Github_RevokeMigratorRoleInput: Github_RevokeMigratorRoleInput;
  Github_RevokeMigratorRolePayload: Github_RevokeMigratorRolePayload;
  Github_SavedReply: Github_SavedReply;
  Github_SavedReplyConnection: Github_SavedReplyConnection;
  Github_SavedReplyEdge: Github_SavedReplyEdge;
  Github_SavedReplyOrder: Github_SavedReplyOrder;
  Github_SearchResultItem: ResolversParentTypes['Github_App'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_MarketplaceListing'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_User'];
  Github_SearchResultItemConnection: Omit<Github_SearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_SearchResultItem']>>> };
  Github_SearchResultItemEdge: Omit<Github_SearchResultItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_SearchResultItem']> };
  Github_SecurityAdvisory: Github_SecurityAdvisory;
  Github_SecurityAdvisoryConnection: Github_SecurityAdvisoryConnection;
  Github_SecurityAdvisoryEdge: Github_SecurityAdvisoryEdge;
  Github_SecurityAdvisoryIdentifier: Github_SecurityAdvisoryIdentifier;
  Github_SecurityAdvisoryIdentifierFilter: Github_SecurityAdvisoryIdentifierFilter;
  Github_SecurityAdvisoryOrder: Github_SecurityAdvisoryOrder;
  Github_SecurityAdvisoryPackage: Github_SecurityAdvisoryPackage;
  Github_SecurityAdvisoryPackageVersion: Github_SecurityAdvisoryPackageVersion;
  Github_SecurityAdvisoryReference: Github_SecurityAdvisoryReference;
  Github_SecurityVulnerability: Github_SecurityVulnerability;
  Github_SecurityVulnerabilityConnection: Github_SecurityVulnerabilityConnection;
  Github_SecurityVulnerabilityEdge: Github_SecurityVulnerabilityEdge;
  Github_SecurityVulnerabilityOrder: Github_SecurityVulnerabilityOrder;
  Github_SetEnterpriseIdentityProviderInput: Github_SetEnterpriseIdentityProviderInput;
  Github_SetEnterpriseIdentityProviderPayload: Github_SetEnterpriseIdentityProviderPayload;
  Github_SetOrganizationInteractionLimitInput: Github_SetOrganizationInteractionLimitInput;
  Github_SetOrganizationInteractionLimitPayload: Github_SetOrganizationInteractionLimitPayload;
  Github_SetRepositoryInteractionLimitInput: Github_SetRepositoryInteractionLimitInput;
  Github_SetRepositoryInteractionLimitPayload: Github_SetRepositoryInteractionLimitPayload;
  Github_SetUserInteractionLimitInput: Github_SetUserInteractionLimitInput;
  Github_SetUserInteractionLimitPayload: Github_SetUserInteractionLimitPayload;
  Github_SmimeSignature: Github_SmimeSignature;
  Github_Sponsor: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_SponsorConnection: Omit<Github_SponsorConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_Sponsor']>>> };
  Github_SponsorEdge: Omit<Github_SponsorEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_Sponsor']> };
  Github_SponsorOrder: Github_SponsorOrder;
  Github_Sponsorable: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_SponsorableItem: ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_User'];
  Github_SponsorableItemConnection: Omit<Github_SponsorableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_SponsorableItem']>>> };
  Github_SponsorableItemEdge: Omit<Github_SponsorableItemEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_SponsorableItem']> };
  Github_SponsorableOrder: Github_SponsorableOrder;
  Github_SponsorsActivity: Omit<Github_SponsorsActivity, 'sponsor'> & { sponsor?: Maybe<ResolversParentTypes['Github_Sponsor']> };
  Github_SponsorsActivityConnection: Github_SponsorsActivityConnection;
  Github_SponsorsActivityEdge: Github_SponsorsActivityEdge;
  Github_SponsorsActivityOrder: Github_SponsorsActivityOrder;
  Github_SponsorsGoal: Github_SponsorsGoal;
  Github_SponsorsListing: Github_SponsorsListing;
  Github_SponsorsListingFeatureableItem: ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_User'];
  Github_SponsorsListingFeaturedItem: Omit<Github_SponsorsListingFeaturedItem, 'featureable'> & { featureable: ResolversParentTypes['Github_SponsorsListingFeatureableItem'] };
  Github_SponsorsTier: Github_SponsorsTier;
  Github_SponsorsTierAdminInfo: Github_SponsorsTierAdminInfo;
  Github_SponsorsTierConnection: Github_SponsorsTierConnection;
  Github_SponsorsTierEdge: Github_SponsorsTierEdge;
  Github_SponsorsTierOrder: Github_SponsorsTierOrder;
  Github_Sponsorship: Omit<Github_Sponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<ResolversParentTypes['Github_Sponsor']> };
  Github_SponsorshipConnection: Github_SponsorshipConnection;
  Github_SponsorshipEdge: Github_SponsorshipEdge;
  Github_SponsorshipNewsletter: Github_SponsorshipNewsletter;
  Github_SponsorshipNewsletterConnection: Github_SponsorshipNewsletterConnection;
  Github_SponsorshipNewsletterEdge: Github_SponsorshipNewsletterEdge;
  Github_SponsorshipNewsletterOrder: Github_SponsorshipNewsletterOrder;
  Github_SponsorshipOrder: Github_SponsorshipOrder;
  Github_SshSignature: Github_SshSignature;
  Github_StarOrder: Github_StarOrder;
  Github_StargazerConnection: Github_StargazerConnection;
  Github_StargazerEdge: Github_StargazerEdge;
  Github_Starrable: ResolversParentTypes['Github_Gist'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_Topic'];
  Github_StarredRepositoryConnection: Github_StarredRepositoryConnection;
  Github_StarredRepositoryEdge: Github_StarredRepositoryEdge;
  Github_StartOrganizationMigrationInput: Github_StartOrganizationMigrationInput;
  Github_StartOrganizationMigrationPayload: Github_StartOrganizationMigrationPayload;
  Github_StartRepositoryMigrationInput: Github_StartRepositoryMigrationInput;
  Github_StartRepositoryMigrationPayload: Github_StartRepositoryMigrationPayload;
  Github_Status: Github_Status;
  Github_StatusCheckRollup: Github_StatusCheckRollup;
  Github_StatusCheckRollupContext: ResolversParentTypes['Github_CheckRun'] | ResolversParentTypes['Github_StatusContext'];
  Github_StatusCheckRollupContextConnection: Omit<Github_StatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<ResolversParentTypes['Github_StatusCheckRollupContext']>>> };
  Github_StatusCheckRollupContextEdge: Omit<Github_StatusCheckRollupContextEdge, 'node'> & { node?: Maybe<ResolversParentTypes['Github_StatusCheckRollupContext']> };
  Github_StatusContext: Github_StatusContext;
  Github_StatusContextStateCount: Github_StatusContextStateCount;
  Github_StripeConnectAccount: Github_StripeConnectAccount;
  Github_SubmitPullRequestReviewInput: Github_SubmitPullRequestReviewInput;
  Github_SubmitPullRequestReviewPayload: Github_SubmitPullRequestReviewPayload;
  Github_Submodule: Github_Submodule;
  Github_SubmoduleConnection: Github_SubmoduleConnection;
  Github_SubmoduleEdge: Github_SubmoduleEdge;
  Github_Subscribable: ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_Team'] | ResolversParentTypes['Github_TeamDiscussion'];
  Github_SubscribedEvent: Github_SubscribedEvent;
  Github_SuggestedReviewer: Github_SuggestedReviewer;
  Github_Tag: Github_Tag;
  Github_Team: Github_Team;
  Github_TeamAddMemberAuditEntry: Omit<Github_TeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_TeamAddRepositoryAuditEntry: Omit<Github_TeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_TeamAuditEntryData: ResolversParentTypes['Github_OrgRestoreMemberMembershipTeamAuditEntryData'] | ResolversParentTypes['Github_TeamAddMemberAuditEntry'] | ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] | ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry'] | ResolversParentTypes['Github_TeamRemoveMemberAuditEntry'] | ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'];
  Github_TeamChangeParentTeamAuditEntry: Omit<Github_TeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_TeamConnection: Github_TeamConnection;
  Github_TeamDiscussion: Github_TeamDiscussion;
  Github_TeamDiscussionComment: Github_TeamDiscussionComment;
  Github_TeamDiscussionCommentConnection: Github_TeamDiscussionCommentConnection;
  Github_TeamDiscussionCommentEdge: Github_TeamDiscussionCommentEdge;
  Github_TeamDiscussionCommentOrder: Github_TeamDiscussionCommentOrder;
  Github_TeamDiscussionConnection: Github_TeamDiscussionConnection;
  Github_TeamDiscussionEdge: Github_TeamDiscussionEdge;
  Github_TeamDiscussionOrder: Github_TeamDiscussionOrder;
  Github_TeamEdge: Github_TeamEdge;
  Github_TeamMemberConnection: Github_TeamMemberConnection;
  Github_TeamMemberEdge: Github_TeamMemberEdge;
  Github_TeamMemberOrder: Github_TeamMemberOrder;
  Github_TeamOrder: Github_TeamOrder;
  Github_TeamRemoveMemberAuditEntry: Omit<Github_TeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_TeamRemoveRepositoryAuditEntry: Omit<Github_TeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<ResolversParentTypes['Github_AuditEntryActor']> };
  Github_TeamRepositoryConnection: Github_TeamRepositoryConnection;
  Github_TeamRepositoryEdge: Github_TeamRepositoryEdge;
  Github_TeamRepositoryOrder: Github_TeamRepositoryOrder;
  Github_TextMatch: Github_TextMatch;
  Github_TextMatchHighlight: Github_TextMatchHighlight;
  Github_Topic: Github_Topic;
  Github_TopicAuditEntryData: ResolversParentTypes['Github_RepoAddTopicAuditEntry'] | ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'];
  Github_TransferEnterpriseOrganizationInput: Github_TransferEnterpriseOrganizationInput;
  Github_TransferEnterpriseOrganizationPayload: Github_TransferEnterpriseOrganizationPayload;
  Github_TransferIssueInput: Github_TransferIssueInput;
  Github_TransferIssuePayload: Github_TransferIssuePayload;
  Github_TransferredEvent: Github_TransferredEvent;
  Github_Tree: Github_Tree;
  Github_TreeEntry: Github_TreeEntry;
  Github_URI: Scalars['Github_URI'];
  Github_UnarchiveProjectV2ItemInput: Github_UnarchiveProjectV2ItemInput;
  Github_UnarchiveProjectV2ItemPayload: Github_UnarchiveProjectV2ItemPayload;
  Github_UnarchiveRepositoryInput: Github_UnarchiveRepositoryInput;
  Github_UnarchiveRepositoryPayload: Github_UnarchiveRepositoryPayload;
  Github_UnassignedEvent: Omit<Github_UnassignedEvent, 'assignee'> & { assignee?: Maybe<ResolversParentTypes['Github_Assignee']> };
  Github_UnfollowOrganizationInput: Github_UnfollowOrganizationInput;
  Github_UnfollowOrganizationPayload: Github_UnfollowOrganizationPayload;
  Github_UnfollowUserInput: Github_UnfollowUserInput;
  Github_UnfollowUserPayload: Github_UnfollowUserPayload;
  Github_UniformResourceLocatable: ResolversParentTypes['Github_Bot'] | ResolversParentTypes['Github_CheckRun'] | ResolversParentTypes['Github_ClosedEvent'] | ResolversParentTypes['Github_Commit'] | ResolversParentTypes['Github_ConvertToDraftEvent'] | ResolversParentTypes['Github_CrossReferencedEvent'] | ResolversParentTypes['Github_Gist'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_Mannequin'] | ResolversParentTypes['Github_MergedEvent'] | ResolversParentTypes['Github_Milestone'] | ResolversParentTypes['Github_Organization'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestCommit'] | ResolversParentTypes['Github_ReadyForReviewEvent'] | ResolversParentTypes['Github_Release'] | ResolversParentTypes['Github_Repository'] | ResolversParentTypes['Github_RepositoryTopic'] | ResolversParentTypes['Github_ReviewDismissedEvent'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'] | ResolversParentTypes['Github_User'] | ResolversParentTypes['Github_WorkflowRun'];
  Github_UnknownSignature: Github_UnknownSignature;
  Github_UnlabeledEvent: Github_UnlabeledEvent;
  Github_UnlinkProjectV2FromRepositoryInput: Github_UnlinkProjectV2FromRepositoryInput;
  Github_UnlinkProjectV2FromRepositoryPayload: Github_UnlinkProjectV2FromRepositoryPayload;
  Github_UnlinkProjectV2FromTeamInput: Github_UnlinkProjectV2FromTeamInput;
  Github_UnlinkProjectV2FromTeamPayload: Github_UnlinkProjectV2FromTeamPayload;
  Github_UnlinkRepositoryFromProjectInput: Github_UnlinkRepositoryFromProjectInput;
  Github_UnlinkRepositoryFromProjectPayload: Github_UnlinkRepositoryFromProjectPayload;
  Github_UnlockLockableInput: Github_UnlockLockableInput;
  Github_UnlockLockablePayload: Github_UnlockLockablePayload;
  Github_UnlockedEvent: Github_UnlockedEvent;
  Github_UnmarkDiscussionCommentAsAnswerInput: Github_UnmarkDiscussionCommentAsAnswerInput;
  Github_UnmarkDiscussionCommentAsAnswerPayload: Github_UnmarkDiscussionCommentAsAnswerPayload;
  Github_UnmarkFileAsViewedInput: Github_UnmarkFileAsViewedInput;
  Github_UnmarkFileAsViewedPayload: Github_UnmarkFileAsViewedPayload;
  Github_UnmarkIssueAsDuplicateInput: Github_UnmarkIssueAsDuplicateInput;
  Github_UnmarkIssueAsDuplicatePayload: Omit<Github_UnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<ResolversParentTypes['Github_IssueOrPullRequest']> };
  Github_UnmarkedAsDuplicateEvent: Omit<Github_UnmarkedAsDuplicateEvent, 'canonical' | 'duplicate'> & { canonical?: Maybe<ResolversParentTypes['Github_IssueOrPullRequest']>, duplicate?: Maybe<ResolversParentTypes['Github_IssueOrPullRequest']> };
  Github_UnminimizeCommentInput: Github_UnminimizeCommentInput;
  Github_UnminimizeCommentPayload: Github_UnminimizeCommentPayload;
  Github_UnpinIssueInput: Github_UnpinIssueInput;
  Github_UnpinIssuePayload: Github_UnpinIssuePayload;
  Github_UnpinnedEvent: Github_UnpinnedEvent;
  Github_UnresolveReviewThreadInput: Github_UnresolveReviewThreadInput;
  Github_UnresolveReviewThreadPayload: Github_UnresolveReviewThreadPayload;
  Github_UnsubscribedEvent: Github_UnsubscribedEvent;
  Github_Updatable: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_GistComment'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_Project'] | ResolversParentTypes['Github_ProjectV2'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'];
  Github_UpdatableComment: ResolversParentTypes['Github_CommitComment'] | ResolversParentTypes['Github_DiscussionComment'] | ResolversParentTypes['Github_GistComment'] | ResolversParentTypes['Github_Issue'] | ResolversParentTypes['Github_IssueComment'] | ResolversParentTypes['Github_PullRequest'] | ResolversParentTypes['Github_PullRequestReview'] | ResolversParentTypes['Github_PullRequestReviewComment'] | ResolversParentTypes['Github_TeamDiscussion'] | ResolversParentTypes['Github_TeamDiscussionComment'];
  Github_UpdateBranchProtectionRuleInput: Github_UpdateBranchProtectionRuleInput;
  Github_UpdateBranchProtectionRulePayload: Github_UpdateBranchProtectionRulePayload;
  Github_UpdateCheckRunInput: Github_UpdateCheckRunInput;
  Github_UpdateCheckRunPayload: Github_UpdateCheckRunPayload;
  Github_UpdateCheckSuitePreferencesInput: Github_UpdateCheckSuitePreferencesInput;
  Github_UpdateCheckSuitePreferencesPayload: Github_UpdateCheckSuitePreferencesPayload;
  Github_UpdateDiscussionCommentInput: Github_UpdateDiscussionCommentInput;
  Github_UpdateDiscussionCommentPayload: Github_UpdateDiscussionCommentPayload;
  Github_UpdateDiscussionInput: Github_UpdateDiscussionInput;
  Github_UpdateDiscussionPayload: Github_UpdateDiscussionPayload;
  Github_UpdateEnterpriseAdministratorRoleInput: Github_UpdateEnterpriseAdministratorRoleInput;
  Github_UpdateEnterpriseAdministratorRolePayload: Github_UpdateEnterpriseAdministratorRolePayload;
  Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload;
  Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput: Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload;
  Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload;
  Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload;
  Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput: Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload;
  Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload;
  Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload;
  Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput: Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
  Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload: Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload;
  Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload;
  Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload;
  Github_UpdateEnterpriseOrganizationProjectsSettingInput: Github_UpdateEnterpriseOrganizationProjectsSettingInput;
  Github_UpdateEnterpriseOrganizationProjectsSettingPayload: Github_UpdateEnterpriseOrganizationProjectsSettingPayload;
  Github_UpdateEnterpriseOwnerOrganizationRoleInput: Github_UpdateEnterpriseOwnerOrganizationRoleInput;
  Github_UpdateEnterpriseOwnerOrganizationRolePayload: Github_UpdateEnterpriseOwnerOrganizationRolePayload;
  Github_UpdateEnterpriseProfileInput: Github_UpdateEnterpriseProfileInput;
  Github_UpdateEnterpriseProfilePayload: Github_UpdateEnterpriseProfilePayload;
  Github_UpdateEnterpriseRepositoryProjectsSettingInput: Github_UpdateEnterpriseRepositoryProjectsSettingInput;
  Github_UpdateEnterpriseRepositoryProjectsSettingPayload: Github_UpdateEnterpriseRepositoryProjectsSettingPayload;
  Github_UpdateEnterpriseTeamDiscussionsSettingInput: Github_UpdateEnterpriseTeamDiscussionsSettingInput;
  Github_UpdateEnterpriseTeamDiscussionsSettingPayload: Github_UpdateEnterpriseTeamDiscussionsSettingPayload;
  Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload;
  Github_UpdateEnvironmentInput: Github_UpdateEnvironmentInput;
  Github_UpdateEnvironmentPayload: Github_UpdateEnvironmentPayload;
  Github_UpdateIpAllowListEnabledSettingInput: Github_UpdateIpAllowListEnabledSettingInput;
  Github_UpdateIpAllowListEnabledSettingPayload: Omit<Github_UpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['Github_IpAllowListOwner']> };
  Github_UpdateIpAllowListEntryInput: Github_UpdateIpAllowListEntryInput;
  Github_UpdateIpAllowListEntryPayload: Github_UpdateIpAllowListEntryPayload;
  Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput: Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
  Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload: Omit<Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['Github_IpAllowListOwner']> };
  Github_UpdateIssueCommentInput: Github_UpdateIssueCommentInput;
  Github_UpdateIssueCommentPayload: Github_UpdateIssueCommentPayload;
  Github_UpdateIssueInput: Github_UpdateIssueInput;
  Github_UpdateIssuePayload: Github_UpdateIssuePayload;
  Github_UpdateLabelInput: Github_UpdateLabelInput;
  Github_UpdateLabelPayload: Github_UpdateLabelPayload;
  Github_UpdateNotificationRestrictionSettingInput: Github_UpdateNotificationRestrictionSettingInput;
  Github_UpdateNotificationRestrictionSettingPayload: Omit<Github_UpdateNotificationRestrictionSettingPayload, 'owner'> & { owner?: Maybe<ResolversParentTypes['Github_VerifiableDomainOwner']> };
  Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
  Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload;
  Github_UpdateOrganizationWebCommitSignoffSettingInput: Github_UpdateOrganizationWebCommitSignoffSettingInput;
  Github_UpdateOrganizationWebCommitSignoffSettingPayload: Github_UpdateOrganizationWebCommitSignoffSettingPayload;
  Github_UpdateProjectCardInput: Github_UpdateProjectCardInput;
  Github_UpdateProjectCardPayload: Github_UpdateProjectCardPayload;
  Github_UpdateProjectColumnInput: Github_UpdateProjectColumnInput;
  Github_UpdateProjectColumnPayload: Github_UpdateProjectColumnPayload;
  Github_UpdateProjectInput: Github_UpdateProjectInput;
  Github_UpdateProjectPayload: Github_UpdateProjectPayload;
  Github_UpdateProjectV2DraftIssueInput: Github_UpdateProjectV2DraftIssueInput;
  Github_UpdateProjectV2DraftIssuePayload: Github_UpdateProjectV2DraftIssuePayload;
  Github_UpdateProjectV2Input: Github_UpdateProjectV2Input;
  Github_UpdateProjectV2ItemFieldValueInput: Github_UpdateProjectV2ItemFieldValueInput;
  Github_UpdateProjectV2ItemFieldValuePayload: Github_UpdateProjectV2ItemFieldValuePayload;
  Github_UpdateProjectV2ItemPositionInput: Github_UpdateProjectV2ItemPositionInput;
  Github_UpdateProjectV2ItemPositionPayload: Github_UpdateProjectV2ItemPositionPayload;
  Github_UpdateProjectV2Payload: Github_UpdateProjectV2Payload;
  Github_UpdatePullRequestBranchInput: Github_UpdatePullRequestBranchInput;
  Github_UpdatePullRequestBranchPayload: Github_UpdatePullRequestBranchPayload;
  Github_UpdatePullRequestInput: Github_UpdatePullRequestInput;
  Github_UpdatePullRequestPayload: Github_UpdatePullRequestPayload;
  Github_UpdatePullRequestReviewCommentInput: Github_UpdatePullRequestReviewCommentInput;
  Github_UpdatePullRequestReviewCommentPayload: Github_UpdatePullRequestReviewCommentPayload;
  Github_UpdatePullRequestReviewInput: Github_UpdatePullRequestReviewInput;
  Github_UpdatePullRequestReviewPayload: Github_UpdatePullRequestReviewPayload;
  Github_UpdateRefInput: Github_UpdateRefInput;
  Github_UpdateRefPayload: Github_UpdateRefPayload;
  Github_UpdateRefsInput: Github_UpdateRefsInput;
  Github_UpdateRefsPayload: Github_UpdateRefsPayload;
  Github_UpdateRepositoryInput: Github_UpdateRepositoryInput;
  Github_UpdateRepositoryPayload: Github_UpdateRepositoryPayload;
  Github_UpdateRepositoryWebCommitSignoffSettingInput: Github_UpdateRepositoryWebCommitSignoffSettingInput;
  Github_UpdateRepositoryWebCommitSignoffSettingPayload: Github_UpdateRepositoryWebCommitSignoffSettingPayload;
  Github_UpdateSponsorshipPreferencesInput: Github_UpdateSponsorshipPreferencesInput;
  Github_UpdateSponsorshipPreferencesPayload: Github_UpdateSponsorshipPreferencesPayload;
  Github_UpdateSubscriptionInput: Github_UpdateSubscriptionInput;
  Github_UpdateSubscriptionPayload: Github_UpdateSubscriptionPayload;
  Github_UpdateTeamDiscussionCommentInput: Github_UpdateTeamDiscussionCommentInput;
  Github_UpdateTeamDiscussionCommentPayload: Github_UpdateTeamDiscussionCommentPayload;
  Github_UpdateTeamDiscussionInput: Github_UpdateTeamDiscussionInput;
  Github_UpdateTeamDiscussionPayload: Github_UpdateTeamDiscussionPayload;
  Github_UpdateTeamReviewAssignmentInput: Github_UpdateTeamReviewAssignmentInput;
  Github_UpdateTeamReviewAssignmentPayload: Github_UpdateTeamReviewAssignmentPayload;
  Github_UpdateTeamsRepositoryInput: Github_UpdateTeamsRepositoryInput;
  Github_UpdateTeamsRepositoryPayload: Github_UpdateTeamsRepositoryPayload;
  Github_UpdateTopicsInput: Github_UpdateTopicsInput;
  Github_UpdateTopicsPayload: Github_UpdateTopicsPayload;
  Github_User: Github_User;
  Github_UserBlockedEvent: Github_UserBlockedEvent;
  Github_UserConnection: Github_UserConnection;
  Github_UserContentEdit: Github_UserContentEdit;
  Github_UserContentEditConnection: Github_UserContentEditConnection;
  Github_UserContentEditEdge: Github_UserContentEditEdge;
  Github_UserEdge: Github_UserEdge;
  Github_UserEmailMetadata: Github_UserEmailMetadata;
  Github_UserStatus: Github_UserStatus;
  Github_UserStatusConnection: Github_UserStatusConnection;
  Github_UserStatusEdge: Github_UserStatusEdge;
  Github_UserStatusOrder: Github_UserStatusOrder;
  Github_VerifiableDomain: Omit<Github_VerifiableDomain, 'owner'> & { owner: ResolversParentTypes['Github_VerifiableDomainOwner'] };
  Github_VerifiableDomainConnection: Github_VerifiableDomainConnection;
  Github_VerifiableDomainEdge: Github_VerifiableDomainEdge;
  Github_VerifiableDomainOrder: Github_VerifiableDomainOrder;
  Github_VerifiableDomainOwner: ResolversParentTypes['Github_Enterprise'] | ResolversParentTypes['Github_Organization'];
  Github_VerifyVerifiableDomainInput: Github_VerifyVerifiableDomainInput;
  Github_VerifyVerifiableDomainPayload: Github_VerifyVerifiableDomainPayload;
  Github_ViewerHovercardContext: Github_ViewerHovercardContext;
  Github_Votable: ResolversParentTypes['Github_Discussion'] | ResolversParentTypes['Github_DiscussionComment'];
  Github_Workflow: Github_Workflow;
  Github_WorkflowRun: Github_WorkflowRun;
  Github_WorkflowRunConnection: Github_WorkflowRunConnection;
  Github_WorkflowRunEdge: Github_WorkflowRunEdge;
  Github_WorkflowRunOrder: Github_WorkflowRunOrder;
  Github_X509Certificate: Scalars['Github_X509Certificate'];
  github_1Query: github_1Query;
  github_1Mutation: github_1Mutation;
}>;

export type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  aws_lambda_1?: Resolver<ResolversTypes['aws_lambda_1Query'], ParentType, ContextType>;
  github_1?: Resolver<ResolversTypes['github_1Query'], ParentType, ContextType>;
}>;

export type AWSLambda_ListFunctionsResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_ListFunctionsResponse'] = ResolversParentTypes['AWSLambda_ListFunctionsResponse']> = ResolversObject<{
  functions?: Resolver<Maybe<Array<Maybe<ResolversTypes['AWSLambda_FunctionsListItem']>>>, ParentType, ContextType>;
  nextMarker?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_FunctionsListItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_FunctionsListItem'] = ResolversParentTypes['AWSLambda_FunctionsListItem']> = ResolversObject<{
  codeSha256?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  codeSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deadLetterConfig?: Resolver<Maybe<ResolversTypes['AWSLambda_DeadLetterConfig']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['AWSLambda_Environment']>, ParentType, ContextType>;
  fileSystemConfigs?: Resolver<Maybe<Array<Maybe<ResolversTypes['AWSLambda_FileSystemConfigsListItem']>>>, ParentType, ContextType>;
  functionArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  functionName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  handler?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  imageConfigResponse?: Resolver<Maybe<ResolversTypes['AWSLambda_ImageConfigResponse']>, ParentType, ContextType>;
  kMSKeyArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModified?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastUpdateStatus?: Resolver<Maybe<ResolversTypes['AWSLambda_LastUpdateStatus']>, ParentType, ContextType>;
  lastUpdateStatusReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastUpdateStatusReasonCode?: Resolver<Maybe<ResolversTypes['AWSLambda_LastUpdateStatusReasonCode']>, ParentType, ContextType>;
  layers?: Resolver<Maybe<Array<Maybe<ResolversTypes['AWSLambda_LayersListItem']>>>, ParentType, ContextType>;
  masterArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  memorySize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  packageType?: Resolver<Maybe<ResolversTypes['AWSLambda_PackageType']>, ParentType, ContextType>;
  revisionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  runtime?: Resolver<Maybe<ResolversTypes['AWSLambda_Runtime']>, ParentType, ContextType>;
  signingJobArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signingProfileVersionArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['AWSLambda_State']>, ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stateReasonCode?: Resolver<Maybe<ResolversTypes['AWSLambda_StateReasonCode']>, ParentType, ContextType>;
  timeout?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  tracingConfig?: Resolver<Maybe<ResolversTypes['AWSLambda_TracingConfig']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vpcConfig?: Resolver<Maybe<ResolversTypes['AWSLambda_VpcConfig']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_DeadLetterConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_DeadLetterConfig'] = ResolversParentTypes['AWSLambda_DeadLetterConfig']> = ResolversObject<{
  targetArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_EnvironmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_Environment'] = ResolversParentTypes['AWSLambda_Environment']> = ResolversObject<{
  error?: Resolver<Maybe<ResolversTypes['AWSLambda_Error']>, ParentType, ContextType>;
  variables?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_ErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_Error'] = ResolversParentTypes['AWSLambda_Error']> = ResolversObject<{
  errorCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JSONScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type AWSLambda_FileSystemConfigsListItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_FileSystemConfigsListItem'] = ResolversParentTypes['AWSLambda_FileSystemConfigsListItem']> = ResolversObject<{
  arn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  localMountPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_ImageConfigResponseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_ImageConfigResponse'] = ResolversParentTypes['AWSLambda_ImageConfigResponse']> = ResolversObject<{
  error?: Resolver<Maybe<ResolversTypes['AWSLambda_Error2']>, ParentType, ContextType>;
  imageConfig?: Resolver<Maybe<ResolversTypes['AWSLambda_ImageConfig']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_Error2Resolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_Error2'] = ResolversParentTypes['AWSLambda_Error2']> = ResolversObject<{
  errorCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_ImageConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_ImageConfig'] = ResolversParentTypes['AWSLambda_ImageConfig']> = ResolversObject<{
  command?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  entryPoint?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  workingDirectory?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_LayersListItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_LayersListItem'] = ResolversParentTypes['AWSLambda_LayersListItem']> = ResolversObject<{
  arn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  codeSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  signingJobArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signingProfileVersionArn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_TracingConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_TracingConfig'] = ResolversParentTypes['AWSLambda_TracingConfig']> = ResolversObject<{
  mode?: Resolver<Maybe<ResolversTypes['AWSLambda_Mode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AWSLambda_VpcConfigResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['AWSLambda_VpcConfig'] = ResolversParentTypes['AWSLambda_VpcConfig']> = ResolversObject<{
  securityGroupIds?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  subnetIds?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  vpcId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type aws_lambda_1QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['aws_lambda_1Query'] = ResolversParentTypes['aws_lambda_1Query']> = ResolversObject<{
  listFunctionsResponse?: Resolver<Maybe<ResolversTypes['AWSLambda_ListFunctionsResponse']>, ParentType, ContextType, Partial<aws_lambda_1QuerylistFunctionsResponseArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type MutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = ResolversObject<{
  github_1?: Resolver<ResolversTypes['github_1Mutation'], ParentType, ContextType>;
}>;

export type Github_AbortQueuedMigrationsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AbortQueuedMigrationsPayload'] = ResolversParentTypes['Github_AbortQueuedMigrationsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AcceptEnterpriseAdministratorInvitationPayload'] = ResolversParentTypes['Github_AcceptEnterpriseAdministratorInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AcceptTopicSuggestionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AcceptTopicSuggestionPayload'] = ResolversParentTypes['Github_AcceptTopicSuggestionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Github_Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Actor'] = ResolversParentTypes['Github_Actor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Bot' | 'Github_EnterpriseUserAccount' | 'Github_Mannequin' | 'Github_Organization' | 'Github_User', ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_ActoravatarUrlArgs>>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
}>;

export type Github_ActorLocationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ActorLocation'] = ResolversParentTypes['Github_ActorLocation']> = ResolversObject<{
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  regionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddAssigneesToAssignablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddAssigneesToAssignablePayload'] = ResolversParentTypes['Github_AddAssigneesToAssignablePayload']> = ResolversObject<{
  assignable?: Resolver<Maybe<ResolversTypes['Github_Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddCommentPayload'] = ResolversParentTypes['Github_AddCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['Github_IssueCommentEdge']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Github_Node']>, ParentType, ContextType>;
  timelineEdge?: Resolver<Maybe<ResolversTypes['Github_IssueTimelineItemEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddDiscussionCommentPayload'] = ResolversParentTypes['Github_AddDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Github_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddDiscussionPollVotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddDiscussionPollVotePayload'] = ResolversParentTypes['Github_AddDiscussionPollVotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pollOption?: Resolver<Maybe<ResolversTypes['Github_DiscussionPollOption']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddEnterpriseOrganizationMemberPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddEnterpriseOrganizationMemberPayload'] = ResolversParentTypes['Github_AddEnterpriseOrganizationMemberPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  users?: Resolver<Maybe<Array<ResolversTypes['Github_User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddEnterpriseSupportEntitlementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddEnterpriseSupportEntitlementPayload'] = ResolversParentTypes['Github_AddEnterpriseSupportEntitlementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddLabelsToLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddLabelsToLabelablePayload'] = ResolversParentTypes['Github_AddLabelsToLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['Github_Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddProjectCardPayload'] = ResolversParentTypes['Github_AddProjectCardPayload']> = ResolversObject<{
  cardEdge?: Resolver<Maybe<ResolversTypes['Github_ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<ResolversTypes['Github_ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddProjectColumnPayload'] = ResolversParentTypes['Github_AddProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<ResolversTypes['Github_ProjectColumnEdge']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddProjectV2DraftIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddProjectV2DraftIssuePayload'] = ResolversParentTypes['Github_AddProjectV2DraftIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectItem?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddProjectV2ItemByIdPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddProjectV2ItemByIdPayload'] = ResolversParentTypes['Github_AddProjectV2ItemByIdPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddPullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddPullRequestReviewCommentPayload'] = ResolversParentTypes['Github_AddPullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewComment']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewCommentEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddPullRequestReviewPayload'] = ResolversParentTypes['Github_AddPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddPullRequestReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddPullRequestReviewThreadPayload'] = ResolversParentTypes['Github_AddPullRequestReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddReactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddReactionPayload'] = ResolversParentTypes['Github_AddReactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<ResolversTypes['Github_Reaction']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Github_Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddStarPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddStarPayload'] = ResolversParentTypes['Github_AddStarPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<ResolversTypes['Github_Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddUpvotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddUpvotePayload'] = ResolversParentTypes['Github_AddUpvotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Github_Votable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddVerifiableDomainPayload'] = ResolversParentTypes['Github_AddVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AddedToProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AddedToProjectEvent'] = ResolversParentTypes['Github_AddedToProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['Github_ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AnnouncementBannerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AnnouncementBanner'] = ResolversParentTypes['Github_AnnouncementBanner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Enterprise' | 'Github_Organization', ParentType, ContextType>;
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
}>;

export type Github_AppResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_App'] = ResolversParentTypes['Github_App']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['Github_IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<Github_AppipAllowListEntriesArgs, 'orderBy'>>;
  logoBackgroundColor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_ApplogoUrlArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ApproveDeploymentsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ApproveDeploymentsPayload'] = ResolversParentTypes['Github_ApproveDeploymentsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployments?: Resolver<Maybe<Array<ResolversTypes['Github_Deployment']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ApproveVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ApproveVerifiableDomainPayload'] = ResolversParentTypes['Github_ApproveVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ArchiveProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ArchiveProjectV2ItemPayload'] = ResolversParentTypes['Github_ArchiveProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ArchiveRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ArchiveRepositoryPayload'] = ResolversParentTypes['Github_ArchiveRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AssignableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Assignable'] = ResolversParentTypes['Github_Assignable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_AssignableassigneesArgs>>;
}>;

export type Github_AssignedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AssignedEvent'] = ResolversParentTypes['Github_AssignedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes['Github_Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['Github_Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AssigneeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Assignee'] = ResolversParentTypes['Github_Assignee']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Bot' | 'Github_Mannequin' | 'Github_Organization' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_AuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AuditEntry'] = ResolversParentTypes['Github_AuditEntry']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_MembersCanDeleteReposClearAuditEntry' | 'Github_MembersCanDeleteReposDisableAuditEntry' | 'Github_MembersCanDeleteReposEnableAuditEntry' | 'Github_OauthApplicationCreateAuditEntry' | 'Github_OrgAddBillingManagerAuditEntry' | 'Github_OrgAddMemberAuditEntry' | 'Github_OrgBlockUserAuditEntry' | 'Github_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_OrgCreateAuditEntry' | 'Github_OrgDisableOauthAppRestrictionsAuditEntry' | 'Github_OrgDisableSamlAuditEntry' | 'Github_OrgDisableTwoFactorRequirementAuditEntry' | 'Github_OrgEnableOauthAppRestrictionsAuditEntry' | 'Github_OrgEnableSamlAuditEntry' | 'Github_OrgEnableTwoFactorRequirementAuditEntry' | 'Github_OrgInviteMemberAuditEntry' | 'Github_OrgInviteToBusinessAuditEntry' | 'Github_OrgOauthAppAccessApprovedAuditEntry' | 'Github_OrgOauthAppAccessDeniedAuditEntry' | 'Github_OrgOauthAppAccessRequestedAuditEntry' | 'Github_OrgRemoveBillingManagerAuditEntry' | 'Github_OrgRemoveMemberAuditEntry' | 'Github_OrgRemoveOutsideCollaboratorAuditEntry' | 'Github_OrgRestoreMemberAuditEntry' | 'Github_OrgUnblockUserAuditEntry' | 'Github_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'Github_OrgUpdateMemberAuditEntry' | 'Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'Github_PrivateRepositoryForkingDisableAuditEntry' | 'Github_PrivateRepositoryForkingEnableAuditEntry' | 'Github_RepoAccessAuditEntry' | 'Github_RepoAddMemberAuditEntry' | 'Github_RepoAddTopicAuditEntry' | 'Github_RepoArchivedAuditEntry' | 'Github_RepoChangeMergeSettingAuditEntry' | 'Github_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigDisableContributorsOnlyAuditEntry' | 'Github_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigEnableContributorsOnlyAuditEntry' | 'Github_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigLockAnonymousGitAccessAuditEntry' | 'Github_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'Github_RepoCreateAuditEntry' | 'Github_RepoDestroyAuditEntry' | 'Github_RepoRemoveMemberAuditEntry' | 'Github_RepoRemoveTopicAuditEntry' | 'Github_RepositoryVisibilityChangeDisableAuditEntry' | 'Github_RepositoryVisibilityChangeEnableAuditEntry' | 'Github_TeamAddMemberAuditEntry' | 'Github_TeamAddRepositoryAuditEntry' | 'Github_TeamChangeParentTeamAuditEntry' | 'Github_TeamRemoveMemberAuditEntry' | 'Github_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_AuditEntryActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AuditEntryActor'] = ResolversParentTypes['Github_AuditEntryActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Bot' | 'Github_Organization' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_AutoMergeDisabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutoMergeDisabledEvent'] = ResolversParentTypes['Github_AutoMergeDisabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  disabler?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reasonCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AutoMergeEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutoMergeEnabledEvent'] = ResolversParentTypes['Github_AutoMergeEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AutoMergeRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutoMergeRequest'] = ResolversParentTypes['Github_AutoMergeRequest']> = ResolversObject<{
  authorEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commitBody?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commitHeadline?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enabledAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  enabledBy?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  mergeMethod?: Resolver<ResolversTypes['Github_PullRequestMergeMethod'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AutoRebaseEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutoRebaseEnabledEvent'] = ResolversParentTypes['Github_AutoRebaseEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AutoSquashEnabledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutoSquashEnabledEvent'] = ResolversParentTypes['Github_AutoSquashEnabledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enabler?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AutomaticBaseChangeFailedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutomaticBaseChangeFailedEvent'] = ResolversParentTypes['Github_AutomaticBaseChangeFailedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_AutomaticBaseChangeSucceededEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_AutomaticBaseChangeSucceededEvent'] = ResolversParentTypes['Github_AutomaticBaseChangeSucceededEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Github_Base64StringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_Base64String'], any> {
  name: 'Github_Base64String';
}

export type Github_BaseRefChangedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BaseRefChangedEvent'] = ResolversParentTypes['Github_BaseRefChangedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currentRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BaseRefDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BaseRefDeletedEvent'] = ResolversParentTypes['Github_BaseRefDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  baseRefName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BaseRefForcePushedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BaseRefForcePushedEvent'] = ResolversParentTypes['Github_BaseRefForcePushedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BlameResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Blame'] = ResolversParentTypes['Github_Blame']> = ResolversObject<{
  ranges?: Resolver<Array<ResolversTypes['Github_BlameRange']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BlameRangeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BlameRange'] = ResolversParentTypes['Github_BlameRange']> = ResolversObject<{
  age?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commit?: Resolver<ResolversTypes['Github_Commit'], ParentType, ContextType>;
  endingLine?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startingLine?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BlobResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Blob'] = ResolversParentTypes['Github_Blob']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  byteSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isBinary?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BotResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Bot'] = ResolversParentTypes['Github_Bot']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_BotavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BranchActorAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchActorAllowanceActor'] = ResolversParentTypes['Github_BranchActorAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_App' | 'Github_Team' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_BranchProtectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchProtectionRule'] = ResolversParentTypes['Github_BranchProtectionRule']> = ResolversObject<{
  allowsDeletions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowsForcePushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  blocksCreations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  branchProtectionRuleConflicts?: Resolver<ResolversTypes['Github_BranchProtectionRuleConflictConnection'], ParentType, ContextType, Partial<Github_BranchProtectionRulebranchProtectionRuleConflictsArgs>>;
  bypassForcePushAllowances?: Resolver<ResolversTypes['Github_BypassForcePushAllowanceConnection'], ParentType, ContextType, Partial<Github_BranchProtectionRulebypassForcePushAllowancesArgs>>;
  bypassPullRequestAllowances?: Resolver<ResolversTypes['Github_BypassPullRequestAllowanceConnection'], ParentType, ContextType, Partial<Github_BranchProtectionRulebypassPullRequestAllowancesArgs>>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dismissesStaleReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAdminEnforced?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lockAllowsFetchAndMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lockBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  matchingRefs?: Resolver<ResolversTypes['Github_RefConnection'], ParentType, ContextType, Partial<Github_BranchProtectionRulematchingRefsArgs>>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pushAllowances?: Resolver<ResolversTypes['Github_PushAllowanceConnection'], ParentType, ContextType, Partial<Github_BranchProtectionRulepushAllowancesArgs>>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  requireLastPushApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiredStatusChecks?: Resolver<Maybe<Array<ResolversTypes['Github_RequiredStatusCheckDescription']>>, ParentType, ContextType>;
  requiresApprovingReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCommitSignatures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresConversationResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresLinearHistory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStatusChecks?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStrictStatusChecks?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsPushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsReviewDismissals?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewDismissalAllowances?: Resolver<ResolversTypes['Github_ReviewDismissalAllowanceConnection'], ParentType, ContextType, Partial<Github_BranchProtectionRulereviewDismissalAllowancesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BranchProtectionRuleConflictResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchProtectionRuleConflict'] = ResolversParentTypes['Github_BranchProtectionRuleConflict']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  conflictingBranchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BranchProtectionRuleConflictConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchProtectionRuleConflictConnection'] = ResolversParentTypes['Github_BranchProtectionRuleConflictConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BranchProtectionRuleConflictEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BranchProtectionRuleConflict']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BranchProtectionRuleConflictEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchProtectionRuleConflictEdge'] = ResolversParentTypes['Github_BranchProtectionRuleConflictEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRuleConflict']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BranchProtectionRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchProtectionRuleConnection'] = ResolversParentTypes['Github_BranchProtectionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BranchProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BranchProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BranchProtectionRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BranchProtectionRuleEdge'] = ResolversParentTypes['Github_BranchProtectionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BypassForcePushAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BypassForcePushAllowance'] = ResolversParentTypes['Github_BypassForcePushAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_BranchActorAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BypassForcePushAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BypassForcePushAllowanceConnection'] = ResolversParentTypes['Github_BypassForcePushAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BypassForcePushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BypassForcePushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BypassForcePushAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BypassForcePushAllowanceEdge'] = ResolversParentTypes['Github_BypassForcePushAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_BypassForcePushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BypassPullRequestAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BypassPullRequestAllowance'] = ResolversParentTypes['Github_BypassPullRequestAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_BranchActorAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BypassPullRequestAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BypassPullRequestAllowanceConnection'] = ResolversParentTypes['Github_BypassPullRequestAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BypassPullRequestAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_BypassPullRequestAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_BypassPullRequestAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_BypassPullRequestAllowanceEdge'] = ResolversParentTypes['Github_BypassPullRequestAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_BypassPullRequestAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CVSSResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CVSS'] = ResolversParentTypes['Github_CVSS']> = ResolversObject<{
  score?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  vectorString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CWEResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CWE'] = ResolversParentTypes['Github_CWE']> = ResolversObject<{
  cweId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CWEConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CWEConnection'] = ResolversParentTypes['Github_CWEConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CWEEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CWE']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CWEEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CWEEdge'] = ResolversParentTypes['Github_CWEEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CWE']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CancelEnterpriseAdminInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CancelEnterpriseAdminInvitationPayload'] = ResolversParentTypes['Github_CancelEnterpriseAdminInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CancelSponsorshipPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CancelSponsorshipPayload'] = ResolversParentTypes['Github_CancelSponsorshipPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ChangeUserStatusPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ChangeUserStatusPayload'] = ResolversParentTypes['Github_ChangeUserStatusPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Github_UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckAnnotationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckAnnotation'] = ResolversParentTypes['Github_CheckAnnotation']> = ResolversObject<{
  annotationLevel?: Resolver<Maybe<ResolversTypes['Github_CheckAnnotationLevel']>, ParentType, ContextType>;
  blobUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  location?: Resolver<ResolversTypes['Github_CheckAnnotationSpan'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rawDetails?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckAnnotationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckAnnotationConnection'] = ResolversParentTypes['Github_CheckAnnotationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckAnnotationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckAnnotation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckAnnotationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckAnnotationEdge'] = ResolversParentTypes['Github_CheckAnnotationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CheckAnnotation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckAnnotationPositionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckAnnotationPosition'] = ResolversParentTypes['Github_CheckAnnotationPosition']> = ResolversObject<{
  column?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  line?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckAnnotationSpanResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckAnnotationSpan'] = ResolversParentTypes['Github_CheckAnnotationSpan']> = ResolversObject<{
  end?: Resolver<ResolversTypes['Github_CheckAnnotationPosition'], ParentType, ContextType>;
  start?: Resolver<ResolversTypes['Github_CheckAnnotationPosition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckRunResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckRun'] = ResolversParentTypes['Github_CheckRun']> = ResolversObject<{
  annotations?: Resolver<Maybe<ResolversTypes['Github_CheckAnnotationConnection']>, ParentType, ContextType, Partial<Github_CheckRunannotationsArgs>>;
  checkSuite?: Resolver<ResolversTypes['Github_CheckSuite'], ParentType, ContextType>;
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['Github_CheckConclusionState']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<ResolversTypes['Github_Deployment']>, ParentType, ContextType>;
  detailsUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<Github_CheckRunisRequiredArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingDeploymentRequest?: Resolver<Maybe<ResolversTypes['Github_DeploymentRequest']>, ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  startedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['Github_CheckStatusState'], ParentType, ContextType>;
  steps?: Resolver<Maybe<ResolversTypes['Github_CheckStepConnection']>, ParentType, ContextType, Partial<Github_CheckRunstepsArgs>>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckRunConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckRunConnection'] = ResolversParentTypes['Github_CheckRunConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckRunEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckRunEdge'] = ResolversParentTypes['Github_CheckRunEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CheckRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckRunStateCountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckRunStateCount'] = ResolversParentTypes['Github_CheckRunStateCount']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_CheckRunState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckStepResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckStep'] = ResolversParentTypes['Github_CheckStep']> = ResolversObject<{
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['Github_CheckConclusionState']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  secondsToCompletion?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  startedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['Github_CheckStatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckStepConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckStepConnection'] = ResolversParentTypes['Github_CheckStepConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckStepEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckStep']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckStepEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckStepEdge'] = ResolversParentTypes['Github_CheckStepEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CheckStep']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckSuiteResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckSuite'] = ResolversParentTypes['Github_CheckSuite']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['Github_App']>, ParentType, ContextType>;
  branch?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  checkRuns?: Resolver<Maybe<ResolversTypes['Github_CheckRunConnection']>, ParentType, ContextType, Partial<Github_CheckSuitecheckRunsArgs>>;
  commit?: Resolver<ResolversTypes['Github_Commit'], ParentType, ContextType>;
  conclusion?: Resolver<Maybe<ResolversTypes['Github_CheckConclusionState']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  matchingPullRequests?: Resolver<Maybe<ResolversTypes['Github_PullRequestConnection']>, ParentType, ContextType, Partial<Github_CheckSuitematchingPullRequestsArgs>>;
  push?: Resolver<Maybe<ResolversTypes['Github_Push']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['Github_CheckStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  workflowRun?: Resolver<Maybe<ResolversTypes['Github_WorkflowRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckSuiteConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckSuiteConnection'] = ResolversParentTypes['Github_CheckSuiteConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckSuiteEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CheckSuite']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CheckSuiteEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CheckSuiteEdge'] = ResolversParentTypes['Github_CheckSuiteEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CheckSuite']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ClaimableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Claimable'] = ResolversParentTypes['Github_Claimable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Mannequin' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_ClearLabelsFromLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ClearLabelsFromLabelablePayload'] = ResolversParentTypes['Github_ClearLabelsFromLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['Github_Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ClearProjectV2ItemFieldValuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ClearProjectV2ItemFieldValuePayload'] = ResolversParentTypes['Github_ClearProjectV2ItemFieldValuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Item?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CloneProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CloneProjectPayload'] = ResolversParentTypes['Github_CloneProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  jobStatusId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CloneTemplateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CloneTemplateRepositoryPayload'] = ResolversParentTypes['Github_CloneTemplateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ClosableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Closable'] = ResolversParentTypes['Github_Closable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Discussion' | 'Github_Issue' | 'Github_Milestone' | 'Github_Project' | 'Github_ProjectV2' | 'Github_PullRequest', ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
}>;

export type Github_CloseIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CloseIssuePayload'] = ResolversParentTypes['Github_CloseIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ClosePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ClosePullRequestPayload'] = ResolversParentTypes['Github_ClosePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ClosedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ClosedEvent'] = ResolversParentTypes['Github_ClosedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes['Github_Closable'], ParentType, ContextType>;
  closer?: Resolver<Maybe<ResolversTypes['Github_Closer']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['Github_IssueStateReason']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CloserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Closer'] = ResolversParentTypes['Github_Closer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Commit' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_CodeOfConductResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CodeOfConduct'] = ResolversParentTypes['Github_CodeOfConduct']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Comment'] = ResolversParentTypes['Github_Comment']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_Discussion' | 'Github_DiscussionComment' | 'Github_GistComment' | 'Github_Issue' | 'Github_IssueComment' | 'Github_PullRequest' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment', ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_CommentuserContentEditsArgs>>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_CommentDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommentDeletedEvent'] = ResolversParentTypes['Github_CommentDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletedCommentAuthor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Commit'] = ResolversParentTypes['Github_Commit']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  associatedPullRequests?: Resolver<Maybe<ResolversTypes['Github_PullRequestConnection']>, ParentType, ContextType, RequireFields<Github_CommitassociatedPullRequestsArgs, 'orderBy'>>;
  author?: Resolver<Maybe<ResolversTypes['Github_GitActor']>, ParentType, ContextType>;
  authoredByCommitter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  authoredDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  authors?: Resolver<ResolversTypes['Github_GitActorConnection'], ParentType, ContextType, Partial<Github_CommitauthorsArgs>>;
  blame?: Resolver<ResolversTypes['Github_Blame'], ParentType, ContextType, RequireFields<Github_CommitblameArgs, 'path'>>;
  changedFiles?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  changedFilesIfAvailable?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  checkSuites?: Resolver<Maybe<ResolversTypes['Github_CheckSuiteConnection']>, ParentType, ContextType, Partial<Github_CommitcheckSuitesArgs>>;
  comments?: Resolver<ResolversTypes['Github_CommitCommentConnection'], ParentType, ContextType, Partial<Github_CommitcommentsArgs>>;
  commitResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  committedDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  committedViaWeb?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  committer?: Resolver<Maybe<ResolversTypes['Github_GitActor']>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deployments?: Resolver<Maybe<ResolversTypes['Github_DeploymentConnection']>, ParentType, ContextType, RequireFields<Github_CommitdeploymentsArgs, 'orderBy'>>;
  file?: Resolver<Maybe<ResolversTypes['Github_TreeEntry']>, ParentType, ContextType, RequireFields<Github_CommitfileArgs, 'path'>>;
  history?: Resolver<ResolversTypes['Github_CommitHistoryConnection'], ParentType, ContextType, Partial<Github_CommithistoryArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageBody?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageBodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  messageHeadline?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageHeadlineHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  onBehalfOf?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  parents?: Resolver<ResolversTypes['Github_CommitConnection'], ParentType, ContextType, Partial<Github_CommitparentsArgs>>;
  pushedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['Github_GitSignature']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Github_Status']>, ParentType, ContextType>;
  statusCheckRollup?: Resolver<Maybe<ResolversTypes['Github_StatusCheckRollup']>, ParentType, ContextType>;
  submodules?: Resolver<ResolversTypes['Github_SubmoduleConnection'], ParentType, ContextType, Partial<Github_CommitsubmodulesArgs>>;
  tarballUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  tree?: Resolver<ResolversTypes['Github_Tree'], ParentType, ContextType>;
  treeResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  treeUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  zipballUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitComment'] = ResolversParentTypes['Github_CommitComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_CommitCommentreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_CommitCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitCommentConnection'] = ResolversParentTypes['Github_CommitCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CommitCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CommitComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitCommentEdge'] = ResolversParentTypes['Github_CommitCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CommitComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitCommentThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitCommentThread'] = ResolversParentTypes['Github_CommitCommentThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['Github_CommitCommentConnection'], ParentType, ContextType, Partial<Github_CommitCommentThreadcommentsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitConnection'] = ResolversParentTypes['Github_CommitConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitContributionsByRepository'] = ResolversParentTypes['Github_CommitContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['Github_CreatedCommitContributionConnection'], ParentType, ContextType, RequireFields<Github_CommitContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitEdge'] = ResolversParentTypes['Github_CommitEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CommitHistoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CommitHistoryConnection'] = ResolversParentTypes['Github_CommitHistoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ComparisonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Comparison'] = ResolversParentTypes['Github_Comparison']> = ResolversObject<{
  aheadBy?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  baseTarget?: Resolver<ResolversTypes['Github_GitObject'], ParentType, ContextType>;
  behindBy?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  commits?: Resolver<ResolversTypes['Github_ComparisonCommitConnection'], ParentType, ContextType, Partial<Github_ComparisoncommitsArgs>>;
  headTarget?: Resolver<ResolversTypes['Github_GitObject'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['Github_ComparisonStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ComparisonCommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ComparisonCommitConnection'] = ResolversParentTypes['Github_ComparisonCommitConnection']> = ResolversObject<{
  authorCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ConnectedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ConnectedEvent'] = ResolversParentTypes['Github_ConnectedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Contribution'] = ResolversParentTypes['Github_Contribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CreatedCommitContribution' | 'Github_CreatedIssueContribution' | 'Github_CreatedPullRequestContribution' | 'Github_CreatedPullRequestReviewContribution' | 'Github_CreatedRepositoryContribution' | 'Github_JoinedGitHubContribution' | 'Github_RestrictedContribution', ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
}>;

export type Github_ContributionCalendarResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ContributionCalendar'] = ResolversParentTypes['Github_ContributionCalendar']> = ResolversObject<{
  colors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  isHalloween?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  months?: Resolver<Array<ResolversTypes['Github_ContributionCalendarMonth']>, ParentType, ContextType>;
  totalContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  weeks?: Resolver<Array<ResolversTypes['Github_ContributionCalendarWeek']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ContributionCalendarDayResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ContributionCalendarDay'] = ResolversParentTypes['Github_ContributionCalendarDay']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  contributionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  contributionLevel?: Resolver<ResolversTypes['Github_ContributionLevel'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  weekday?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ContributionCalendarMonthResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ContributionCalendarMonth'] = ResolversParentTypes['Github_ContributionCalendarMonth']> = ResolversObject<{
  firstDay?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalWeeks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  year?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ContributionCalendarWeekResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ContributionCalendarWeek'] = ResolversParentTypes['Github_ContributionCalendarWeek']> = ResolversObject<{
  contributionDays?: Resolver<Array<ResolversTypes['Github_ContributionCalendarDay']>, ParentType, ContextType>;
  firstDay?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ContributionsCollectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ContributionsCollection'] = ResolversParentTypes['Github_ContributionsCollection']> = ResolversObject<{
  commitContributionsByRepository?: Resolver<Array<ResolversTypes['Github_CommitContributionsByRepository']>, ParentType, ContextType, RequireFields<Github_ContributionsCollectioncommitContributionsByRepositoryArgs, 'maxRepositories'>>;
  contributionCalendar?: Resolver<ResolversTypes['Github_ContributionCalendar'], ParentType, ContextType>;
  contributionYears?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  doesEndInCurrentMonth?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  earliestRestrictedContributionDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  endedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  firstIssueContribution?: Resolver<Maybe<ResolversTypes['Github_CreatedIssueOrRestrictedContribution']>, ParentType, ContextType>;
  firstPullRequestContribution?: Resolver<Maybe<ResolversTypes['Github_CreatedPullRequestOrRestrictedContribution']>, ParentType, ContextType>;
  firstRepositoryContribution?: Resolver<Maybe<ResolversTypes['Github_CreatedRepositoryOrRestrictedContribution']>, ParentType, ContextType>;
  hasActivityInThePast?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyContributions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyRestrictedContributions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSingleDay?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueContributions?: Resolver<ResolversTypes['Github_CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<Github_ContributionsCollectionissueContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  issueContributionsByRepository?: Resolver<Array<ResolversTypes['Github_IssueContributionsByRepository']>, ParentType, ContextType, RequireFields<Github_ContributionsCollectionissueContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  joinedGitHubContribution?: Resolver<Maybe<ResolversTypes['Github_JoinedGitHubContribution']>, ParentType, ContextType>;
  latestRestrictedContributionDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  mostRecentCollectionWithActivity?: Resolver<Maybe<ResolversTypes['Github_ContributionsCollection']>, ParentType, ContextType>;
  mostRecentCollectionWithoutActivity?: Resolver<Maybe<ResolversTypes['Github_ContributionsCollection']>, ParentType, ContextType>;
  popularIssueContribution?: Resolver<Maybe<ResolversTypes['Github_CreatedIssueContribution']>, ParentType, ContextType>;
  popularPullRequestContribution?: Resolver<Maybe<ResolversTypes['Github_CreatedPullRequestContribution']>, ParentType, ContextType>;
  pullRequestContributions?: Resolver<ResolversTypes['Github_CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<Github_ContributionsCollectionpullRequestContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  pullRequestContributionsByRepository?: Resolver<Array<ResolversTypes['Github_PullRequestContributionsByRepository']>, ParentType, ContextType, RequireFields<Github_ContributionsCollectionpullRequestContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  pullRequestReviewContributions?: Resolver<ResolversTypes['Github_CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<Github_ContributionsCollectionpullRequestReviewContributionsArgs, 'orderBy'>>;
  pullRequestReviewContributionsByRepository?: Resolver<Array<ResolversTypes['Github_PullRequestReviewContributionsByRepository']>, ParentType, ContextType, RequireFields<Github_ContributionsCollectionpullRequestReviewContributionsByRepositoryArgs, 'maxRepositories'>>;
  repositoryContributions?: Resolver<ResolversTypes['Github_CreatedRepositoryContributionConnection'], ParentType, ContextType, RequireFields<Github_ContributionsCollectionrepositoryContributionsArgs, 'excludeFirst' | 'orderBy'>>;
  restrictedContributionsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  totalCommitContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalIssueContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<Github_ContributionsCollectiontotalIssueContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<Github_ContributionsCollectiontotalPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestReviewContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedCommits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedIssues?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<Github_ContributionsCollectiontotalRepositoriesWithContributedIssuesArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoriesWithContributedPullRequestReviews?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedPullRequests?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<Github_ContributionsCollectiontotalRepositoriesWithContributedPullRequestsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoryContributions?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<Github_ContributionsCollectiontotalRepositoryContributionsArgs, 'excludeFirst'>>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ConvertProjectCardNoteToIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ConvertProjectCardNoteToIssuePayload'] = ResolversParentTypes['Github_ConvertProjectCardNoteToIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['Github_ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ConvertPullRequestToDraftPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ConvertPullRequestToDraftPayload'] = ResolversParentTypes['Github_ConvertPullRequestToDraftPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ConvertToDraftEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ConvertToDraftEvent'] = ResolversParentTypes['Github_ConvertToDraftEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ConvertedNoteToIssueEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ConvertedNoteToIssueEvent'] = ResolversParentTypes['Github_ConvertedNoteToIssueEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['Github_ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ConvertedToDiscussionEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ConvertedToDiscussionEvent'] = ResolversParentTypes['Github_ConvertedToDiscussionEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CopyProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CopyProjectV2Payload'] = ResolversParentTypes['Github_CopyProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateAttributionInvitationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateAttributionInvitationPayload'] = ResolversParentTypes['Github_CreateAttributionInvitationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['Github_Claimable']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['Github_Claimable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateBranchProtectionRulePayload'] = ResolversParentTypes['Github_CreateBranchProtectionRulePayload']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateCheckRunPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateCheckRunPayload'] = ResolversParentTypes['Github_CreateCheckRunPayload']> = ResolversObject<{
  checkRun?: Resolver<Maybe<ResolversTypes['Github_CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateCheckSuitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateCheckSuitePayload'] = ResolversParentTypes['Github_CreateCheckSuitePayload']> = ResolversObject<{
  checkSuite?: Resolver<Maybe<ResolversTypes['Github_CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateCommitOnBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateCommitOnBranchPayload'] = ResolversParentTypes['Github_CreateCommitOnBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateDeploymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateDeploymentPayload'] = ResolversParentTypes['Github_CreateDeploymentPayload']> = ResolversObject<{
  autoMerged?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<ResolversTypes['Github_Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateDeploymentStatusPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateDeploymentStatusPayload'] = ResolversParentTypes['Github_CreateDeploymentStatusPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deploymentStatus?: Resolver<Maybe<ResolversTypes['Github_DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateDiscussionPayload'] = ResolversParentTypes['Github_CreateDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateEnterpriseOrganizationPayload'] = ResolversParentTypes['Github_CreateEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateEnvironmentPayload'] = ResolversParentTypes['Github_CreateEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['Github_Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateIpAllowListEntryPayload'] = ResolversParentTypes['Github_CreateIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['Github_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateIssuePayload'] = ResolversParentTypes['Github_CreateIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateLabelPayload'] = ResolversParentTypes['Github_CreateLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['Github_Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateLinkedBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateLinkedBranchPayload'] = ResolversParentTypes['Github_CreateLinkedBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  linkedBranch?: Resolver<Maybe<ResolversTypes['Github_LinkedBranch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateMigrationSourcePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateMigrationSourcePayload'] = ResolversParentTypes['Github_CreateMigrationSourcePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  migrationSource?: Resolver<Maybe<ResolversTypes['Github_MigrationSource']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateProjectPayload'] = ResolversParentTypes['Github_CreateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateProjectV2Payload'] = ResolversParentTypes['Github_CreateProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatePullRequestPayload'] = ResolversParentTypes['Github_CreatePullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateRefPayload'] = ResolversParentTypes['Github_CreateRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateRepositoryPayload'] = ResolversParentTypes['Github_CreateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateSponsorsListingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateSponsorsListingPayload'] = ResolversParentTypes['Github_CreateSponsorsListingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['Github_SponsorsListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateSponsorsTierPayload'] = ResolversParentTypes['Github_CreateSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateSponsorshipPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateSponsorshipPayload'] = ResolversParentTypes['Github_CreateSponsorshipPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateTeamDiscussionCommentPayload'] = ResolversParentTypes['Github_CreateTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreateTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreateTeamDiscussionPayload'] = ResolversParentTypes['Github_CreateTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedCommitContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedCommitContribution'] = ResolversParentTypes['Github_CreatedCommitContribution']> = ResolversObject<{
  commitCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedCommitContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedCommitContributionConnection'] = ResolversParentTypes['Github_CreatedCommitContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedCommitContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedCommitContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedCommitContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedCommitContributionEdge'] = ResolversParentTypes['Github_CreatedCommitContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CreatedCommitContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedIssueContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedIssueContribution'] = ResolversParentTypes['Github_CreatedIssueContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Github_Issue'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedIssueContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedIssueContributionConnection'] = ResolversParentTypes['Github_CreatedIssueContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedIssueContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedIssueContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedIssueContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedIssueContributionEdge'] = ResolversParentTypes['Github_CreatedIssueContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CreatedIssueContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedIssueOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedIssueOrRestrictedContribution'] = ResolversParentTypes['Github_CreatedIssueOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CreatedIssueContribution' | 'Github_RestrictedContribution', ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestContribution'] = ResolversParentTypes['Github_CreatedPullRequestContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestContributionConnection'] = ResolversParentTypes['Github_CreatedPullRequestContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedPullRequestContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedPullRequestContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestContributionEdge'] = ResolversParentTypes['Github_CreatedPullRequestContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CreatedPullRequestContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestOrRestrictedContribution'] = ResolversParentTypes['Github_CreatedPullRequestOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CreatedPullRequestContribution' | 'Github_RestrictedContribution', ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestReviewContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestReviewContribution'] = ResolversParentTypes['Github_CreatedPullRequestReviewContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<ResolversTypes['Github_PullRequestReview'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestReviewContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestReviewContributionConnection'] = ResolversParentTypes['Github_CreatedPullRequestReviewContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedPullRequestReviewContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedPullRequestReviewContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedPullRequestReviewContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedPullRequestReviewContributionEdge'] = ResolversParentTypes['Github_CreatedPullRequestReviewContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CreatedPullRequestReviewContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedRepositoryContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedRepositoryContribution'] = ResolversParentTypes['Github_CreatedRepositoryContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedRepositoryContributionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedRepositoryContributionConnection'] = ResolversParentTypes['Github_CreatedRepositoryContributionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedRepositoryContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CreatedRepositoryContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedRepositoryContributionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedRepositoryContributionEdge'] = ResolversParentTypes['Github_CreatedRepositoryContributionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_CreatedRepositoryContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_CreatedRepositoryOrRestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CreatedRepositoryOrRestrictedContribution'] = ResolversParentTypes['Github_CreatedRepositoryOrRestrictedContribution']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CreatedRepositoryContribution' | 'Github_RestrictedContribution', ParentType, ContextType>;
}>;

export type Github_CrossReferencedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_CrossReferencedEvent'] = ResolversParentTypes['Github_CrossReferencedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  referencedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  target?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  willCloseTarget?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type Github_DeclineTopicSuggestionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeclineTopicSuggestionPayload'] = ResolversParentTypes['Github_DeclineTopicSuggestionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Github_Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeletableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Deletable'] = ResolversParentTypes['Github_Deletable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_Discussion' | 'Github_DiscussionComment' | 'Github_GistComment' | 'Github_IssueComment' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment', ParentType, ContextType>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_DeleteBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteBranchProtectionRulePayload'] = ResolversParentTypes['Github_DeleteBranchProtectionRulePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteDeploymentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteDeploymentPayload'] = ResolversParentTypes['Github_DeleteDeploymentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteDiscussionCommentPayload'] = ResolversParentTypes['Github_DeleteDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Github_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteDiscussionPayload'] = ResolversParentTypes['Github_DeleteDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteEnvironmentPayload'] = ResolversParentTypes['Github_DeleteEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteIpAllowListEntryPayload'] = ResolversParentTypes['Github_DeleteIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['Github_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteIssueCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteIssueCommentPayload'] = ResolversParentTypes['Github_DeleteIssueCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteIssuePayload'] = ResolversParentTypes['Github_DeleteIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteLabelPayload'] = ResolversParentTypes['Github_DeleteLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteLinkedBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteLinkedBranchPayload'] = ResolversParentTypes['Github_DeleteLinkedBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeletePackageVersionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeletePackageVersionPayload'] = ResolversParentTypes['Github_DeletePackageVersionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteProjectCardPayload'] = ResolversParentTypes['Github_DeleteProjectCardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  column?: Resolver<Maybe<ResolversTypes['Github_ProjectColumn']>, ParentType, ContextType>;
  deletedCardId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteProjectColumnPayload'] = ResolversParentTypes['Github_DeleteProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedColumnId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteProjectPayload'] = ResolversParentTypes['Github_DeleteProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_ProjectOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteProjectV2ItemPayload'] = ResolversParentTypes['Github_DeleteProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedItemId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteProjectV2Payload'] = ResolversParentTypes['Github_DeleteProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeletePullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeletePullRequestReviewCommentPayload'] = ResolversParentTypes['Github_DeletePullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeletePullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeletePullRequestReviewPayload'] = ResolversParentTypes['Github_DeletePullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteRefPayload'] = ResolversParentTypes['Github_DeleteRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteTeamDiscussionCommentPayload'] = ResolversParentTypes['Github_DeleteTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteTeamDiscussionPayload'] = ResolversParentTypes['Github_DeleteTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeleteVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeleteVerifiableDomainPayload'] = ResolversParentTypes['Github_DeleteVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomainOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DemilestonedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DemilestonedEvent'] = ResolversParentTypes['Github_DemilestonedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Github_MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependabotUpdateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependabotUpdate'] = ResolversParentTypes['Github_DependabotUpdate']> = ResolversObject<{
  error?: Resolver<Maybe<ResolversTypes['Github_DependabotUpdateError']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependabotUpdateErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependabotUpdateError'] = ResolversParentTypes['Github_DependabotUpdateError']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  errorType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependencyGraphDependencyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependencyGraphDependency'] = ResolversParentTypes['Github_DependencyGraphDependency']> = ResolversObject<{
  hasDependencies?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  packageLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageManager?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packageName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  requirements?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependencyGraphDependencyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependencyGraphDependencyConnection'] = ResolversParentTypes['Github_DependencyGraphDependencyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DependencyGraphDependencyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DependencyGraphDependency']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependencyGraphDependencyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependencyGraphDependencyEdge'] = ResolversParentTypes['Github_DependencyGraphDependencyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DependencyGraphDependency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependencyGraphManifestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependencyGraphManifest'] = ResolversParentTypes['Github_DependencyGraphManifest']> = ResolversObject<{
  blobPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dependencies?: Resolver<Maybe<ResolversTypes['Github_DependencyGraphDependencyConnection']>, ParentType, ContextType, Partial<Github_DependencyGraphManifestdependenciesArgs>>;
  dependenciesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  exceedsMaxSize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  filename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parseable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependencyGraphManifestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependencyGraphManifestConnection'] = ResolversParentTypes['Github_DependencyGraphManifestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DependencyGraphManifestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DependencyGraphManifest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DependencyGraphManifestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DependencyGraphManifestEdge'] = ResolversParentTypes['Github_DependencyGraphManifestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DependencyGraphManifest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeployKeyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeployKey'] = ResolversParentTypes['Github_DeployKey']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  readOnly?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  verified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeployKeyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeployKeyConnection'] = ResolversParentTypes['Github_DeployKeyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeployKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeployKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeployKeyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeployKeyEdge'] = ResolversParentTypes['Github_DeployKeyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DeployKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeployedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeployedEvent'] = ResolversParentTypes['Github_DeployedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes['Github_Deployment'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Deployment'] = ResolversParentTypes['Github_Deployment']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  commitOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['Github_Actor'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  latestEnvironment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  latestStatus?: Resolver<Maybe<ResolversTypes['Github_DeploymentStatus']>, ParentType, ContextType>;
  originalEnvironment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['Github_DeploymentState']>, ParentType, ContextType>;
  statuses?: Resolver<Maybe<ResolversTypes['Github_DeploymentStatusConnection']>, ParentType, ContextType, Partial<Github_DeploymentstatusesArgs>>;
  task?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentConnection'] = ResolversParentTypes['Github_DeploymentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Deployment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentEdge'] = ResolversParentTypes['Github_DeploymentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentEnvironmentChangedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentEnvironmentChangedEvent'] = ResolversParentTypes['Github_DeploymentEnvironmentChangedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deploymentStatus?: Resolver<ResolversTypes['Github_DeploymentStatus'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentProtectionRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentProtectionRule'] = ResolversParentTypes['Github_DeploymentProtectionRule']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewers?: Resolver<ResolversTypes['Github_DeploymentReviewerConnection'], ParentType, ContextType, Partial<Github_DeploymentProtectionRulereviewersArgs>>;
  timeout?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['Github_DeploymentProtectionRuleType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentProtectionRuleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentProtectionRuleConnection'] = ResolversParentTypes['Github_DeploymentProtectionRuleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentProtectionRuleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentProtectionRuleEdge'] = ResolversParentTypes['Github_DeploymentProtectionRuleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DeploymentProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentRequest'] = ResolversParentTypes['Github_DeploymentRequest']> = ResolversObject<{
  currentUserCanApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  environment?: Resolver<ResolversTypes['Github_Environment'], ParentType, ContextType>;
  reviewers?: Resolver<ResolversTypes['Github_DeploymentReviewerConnection'], ParentType, ContextType, Partial<Github_DeploymentRequestreviewersArgs>>;
  waitTimer?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  waitTimerStartedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentRequestConnection'] = ResolversParentTypes['Github_DeploymentRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentRequestEdge'] = ResolversParentTypes['Github_DeploymentRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DeploymentRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentReview'] = ResolversParentTypes['Github_DeploymentReview']> = ResolversObject<{
  comment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  environments?: Resolver<ResolversTypes['Github_EnvironmentConnection'], ParentType, ContextType, Partial<Github_DeploymentReviewenvironmentsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_DeploymentReviewState'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentReviewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentReviewConnection'] = ResolversParentTypes['Github_DeploymentReviewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentReviewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentReviewEdge'] = ResolversParentTypes['Github_DeploymentReviewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DeploymentReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentReviewer'] = ResolversParentTypes['Github_DeploymentReviewer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Team' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_DeploymentReviewerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentReviewerConnection'] = ResolversParentTypes['Github_DeploymentReviewerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentReviewerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentReviewer']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentReviewerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentReviewerEdge'] = ResolversParentTypes['Github_DeploymentReviewerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DeploymentReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentStatus'] = ResolversParentTypes['Github_DeploymentStatus']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<ResolversTypes['Github_Actor'], ParentType, ContextType>;
  deployment?: Resolver<ResolversTypes['Github_Deployment'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environmentUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  logUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_DeploymentStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentStatusConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentStatusConnection'] = ResolversParentTypes['Github_DeploymentStatusConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DeploymentStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DeploymentStatusEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DeploymentStatusEdge'] = ResolversParentTypes['Github_DeploymentStatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DisablePullRequestAutoMergePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DisablePullRequestAutoMergePayload'] = ResolversParentTypes['Github_DisablePullRequestAutoMergePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DisconnectedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DisconnectedEvent'] = ResolversParentTypes['Github_DisconnectedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Discussion'] = ResolversParentTypes['Github_Discussion']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['Github_LockReason']>, ParentType, ContextType>;
  answer?: Resolver<Maybe<ResolversTypes['Github_DiscussionComment']>, ParentType, ContextType>;
  answerChosenAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  answerChosenBy?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  category?: Resolver<ResolversTypes['Github_DiscussionCategory'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Github_DiscussionCommentConnection'], ParentType, ContextType, Partial<Github_DiscussioncommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['Github_LabelConnection']>, ParentType, ContextType, RequireFields<Github_DiscussionlabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['Github_DiscussionPoll']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_DiscussionreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_DiscussionuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionCategory'] = ResolversParentTypes['Github_DiscussionCategory']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emoji?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  emojiHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAnswerable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionCategoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionCategoryConnection'] = ResolversParentTypes['Github_DiscussionCategoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionCategoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionCategory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionCategoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionCategoryEdge'] = ResolversParentTypes['Github_DiscussionCategoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DiscussionCategory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionComment'] = ResolversParentTypes['Github_DiscussionComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_DiscussionCommentreactionsArgs>>;
  replies?: Resolver<ResolversTypes['Github_DiscussionCommentConnection'], ParentType, ContextType, Partial<Github_DiscussionCommentrepliesArgs>>;
  replyTo?: Resolver<Maybe<ResolversTypes['Github_DiscussionComment']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_DiscussionCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMarkAsAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnmarkAsAnswer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionCommentConnection'] = ResolversParentTypes['Github_DiscussionCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionCommentEdge'] = ResolversParentTypes['Github_DiscussionCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionConnection'] = ResolversParentTypes['Github_DiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Discussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionEdge'] = ResolversParentTypes['Github_DiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionPollResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionPoll'] = ResolversParentTypes['Github_DiscussionPoll']> = ResolversObject<{
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  options?: Resolver<Maybe<ResolversTypes['Github_DiscussionPollOptionConnection']>, ParentType, ContextType, RequireFields<Github_DiscussionPolloptionsArgs, 'orderBy'>>;
  question?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanVote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionPollOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionPollOption'] = ResolversParentTypes['Github_DiscussionPollOption']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  option?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  poll?: Resolver<Maybe<ResolversTypes['Github_DiscussionPoll']>, ParentType, ContextType>;
  totalVoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerHasVoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionPollOptionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionPollOptionConnection'] = ResolversParentTypes['Github_DiscussionPollOptionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionPollOptionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_DiscussionPollOption']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DiscussionPollOptionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DiscussionPollOptionEdge'] = ResolversParentTypes['Github_DiscussionPollOptionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_DiscussionPollOption']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DismissPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DismissPullRequestReviewPayload'] = ResolversParentTypes['Github_DismissPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DismissRepositoryVulnerabilityAlertPayload'] = ResolversParentTypes['Github_DismissRepositoryVulnerabilityAlertPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryVulnerabilityAlert?: Resolver<Maybe<ResolversTypes['Github_RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_DraftIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_DraftIssue'] = ResolversParentTypes['Github_DraftIssue']> = ResolversObject<{
  assignees?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_DraftIssueassigneesArgs>>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  projectV2Items?: Resolver<ResolversTypes['Github_ProjectV2ItemConnection'], ParentType, ContextType, Partial<Github_DraftIssueprojectV2ItemsArgs>>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, Partial<Github_DraftIssueprojectsV2Args>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnablePullRequestAutoMergePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnablePullRequestAutoMergePayload'] = ResolversParentTypes['Github_EnablePullRequestAutoMergePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Enterprise'] = ResolversParentTypes['Github_Enterprise']> = ResolversObject<{
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_EnterpriseavatarUrlArgs>>;
  billingInfo?: Resolver<Maybe<ResolversTypes['Github_EnterpriseBillingInfo']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  members?: Resolver<ResolversTypes['Github_EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<Github_EnterprisemembersArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseorganizationsArgs, 'orderBy'>>;
  ownerInfo?: Resolver<Maybe<ResolversTypes['Github_EnterpriseOwnerInfo']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerIsAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseAdministratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseAdministratorConnection'] = ResolversParentTypes['Github_EnterpriseAdministratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseAdministratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseAdministratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseAdministratorEdge'] = ResolversParentTypes['Github_EnterpriseAdministratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Github_EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseAdministratorInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseAdministratorInvitation'] = ResolversParentTypes['Github_EnterpriseAdministratorInvitation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['Github_Enterprise'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  inviter?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Github_EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseAdministratorInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseAdministratorInvitationConnection'] = ResolversParentTypes['Github_EnterpriseAdministratorInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseAdministratorInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseAdministratorInvitationEdge'] = ResolversParentTypes['Github_EnterpriseAdministratorInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseAuditEntryData'] = ResolversParentTypes['Github_EnterpriseAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_MembersCanDeleteReposClearAuditEntry' | 'Github_MembersCanDeleteReposDisableAuditEntry' | 'Github_MembersCanDeleteReposEnableAuditEntry' | 'Github_OrgInviteToBusinessAuditEntry' | 'Github_PrivateRepositoryForkingDisableAuditEntry' | 'Github_PrivateRepositoryForkingEnableAuditEntry' | 'Github_RepositoryVisibilityChangeDisableAuditEntry' | 'Github_RepositoryVisibilityChangeEnableAuditEntry', ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_EnterpriseBillingInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseBillingInfo'] = ResolversParentTypes['Github_EnterpriseBillingInfo']> = ResolversObject<{
  allLicensableUsersCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assetPacks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  bandwidthQuota?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsagePercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  storageQuota?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  storageUsage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  storageUsagePercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalAvailableLicenses?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalLicenses?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseFailedInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseFailedInvitationConnection'] = ResolversParentTypes['Github_EnterpriseFailedInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseFailedInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseFailedInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseFailedInvitationEdge'] = ResolversParentTypes['Github_EnterpriseFailedInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseIdentityProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseIdentityProvider'] = ResolversParentTypes['Github_EnterpriseIdentityProvider']> = ResolversObject<{
  digestMethod?: Resolver<Maybe<ResolversTypes['Github_SamlDigestAlgorithm']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['Github_ExternalIdentityConnection'], ParentType, ContextType, Partial<Github_EnterpriseIdentityProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<ResolversTypes['Github_X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recoveryCodes?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<ResolversTypes['Github_SamlSignatureAlgorithm']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseMemberResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseMember'] = ResolversParentTypes['Github_EnterpriseMember']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_EnterpriseUserAccount' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_EnterpriseMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseMemberConnection'] = ResolversParentTypes['Github_EnterpriseMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseMember']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseMemberEdge'] = ResolversParentTypes['Github_EnterpriseMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseMember']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseOrganizationMembershipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseOrganizationMembershipConnection'] = ResolversParentTypes['Github_EnterpriseOrganizationMembershipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseOrganizationMembershipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseOrganizationMembershipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseOrganizationMembershipEdge'] = ResolversParentTypes['Github_EnterpriseOrganizationMembershipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Github_EnterpriseUserAccountMembershipRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseOutsideCollaboratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseOutsideCollaboratorConnection'] = ResolversParentTypes['Github_EnterpriseOutsideCollaboratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseOutsideCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseOutsideCollaboratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseOutsideCollaboratorEdge'] = ResolversParentTypes['Github_EnterpriseOutsideCollaboratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['Github_EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOutsideCollaboratorEdgerepositoriesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseOwnerInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseOwnerInfo'] = ResolversParentTypes['Github_EnterpriseOwnerInfo']> = ResolversObject<{
  admins?: Resolver<ResolversTypes['Github_EnterpriseAdministratorConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfoadminsArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  affiliatedUsersWithTwoFactorDisabled?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_EnterpriseOwnerInfoaffiliatedUsersWithTwoFactorDisabledArgs>>;
  affiliatedUsersWithTwoFactorDisabledExist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfoallowPrivateRepositoryForkingSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  allowPrivateRepositoryForkingSettingPolicyValue?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAllowPrivateRepositoryForkingPolicyValue']>, ParentType, ContextType>;
  defaultRepositoryPermissionSetting?: Resolver<ResolversTypes['Github_EnterpriseDefaultRepositoryPermissionSettingValue'], ParentType, ContextType>;
  defaultRepositoryPermissionSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfodefaultRepositoryPermissionSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  domains?: Resolver<ResolversTypes['Github_VerifiableDomainConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfodomainsArgs, 'isApproved' | 'isVerified' | 'orderBy'>>;
  enterpriseServerInstallations?: Resolver<ResolversTypes['Github_EnterpriseServerInstallationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfoenterpriseServerInstallationsArgs, 'connectedOnly' | 'orderBy'>>;
  failedInvitations?: Resolver<ResolversTypes['Github_EnterpriseFailedInvitationConnection'], ParentType, ContextType, Partial<Github_EnterpriseOwnerInfofailedInvitationsArgs>>;
  ipAllowListEnabledSetting?: Resolver<ResolversTypes['Github_IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['Github_IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfoipAllowListEntriesArgs, 'orderBy'>>;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<ResolversTypes['Github_IpAllowListForInstalledAppsEnabledSettingValue'], ParentType, ContextType>;
  isUpdatingDefaultRepositoryPermission?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUpdatingTwoFactorRequirement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanChangeRepositoryVisibilitySettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanCreateInternalRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePrivateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePublicRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Github_EnterpriseMembersCanCreateRepositoriesSettingValue']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanCreateRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteIssuesSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteIssuesSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanDeleteIssuesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteRepositoriesSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteRepositoriesSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanDeleteRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanInviteCollaboratorsSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanInviteCollaboratorsSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanInviteCollaboratorsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanMakePurchasesSetting?: Resolver<ResolversTypes['Github_EnterpriseMembersCanMakePurchasesSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanUpdateProtectedBranchesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanViewDependencyInsightsSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanViewDependencyInsightsSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfomembersCanViewDependencyInsightsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<ResolversTypes['Github_NotificationRestrictionSettingValue'], ParentType, ContextType>;
  oidcProvider?: Resolver<Maybe<ResolversTypes['Github_OIDCProvider']>, ParentType, ContextType>;
  organizationProjectsSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  organizationProjectsSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfoorganizationProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  outsideCollaborators?: Resolver<ResolversTypes['Github_EnterpriseOutsideCollaboratorConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfooutsideCollaboratorsArgs, 'hasTwoFactorEnabled' | 'orderBy'>>;
  pendingAdminInvitations?: Resolver<ResolversTypes['Github_EnterpriseAdministratorInvitationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfopendingAdminInvitationsArgs, 'orderBy'>>;
  pendingCollaboratorInvitations?: Resolver<ResolversTypes['Github_RepositoryInvitationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfopendingCollaboratorInvitationsArgs, 'orderBy'>>;
  pendingMemberInvitations?: Resolver<ResolversTypes['Github_EnterprisePendingMemberInvitationConnection'], ParentType, ContextType, Partial<Github_EnterpriseOwnerInfopendingMemberInvitationsArgs>>;
  repositoryProjectsSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  repositoryProjectsSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInforepositoryProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  samlIdentityProvider?: Resolver<Maybe<ResolversTypes['Github_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  samlIdentityProviderSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfosamlIdentityProviderSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  supportEntitlements?: Resolver<ResolversTypes['Github_EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfosupportEntitlementsArgs, 'orderBy'>>;
  teamDiscussionsSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  teamDiscussionsSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfoteamDiscussionsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  twoFactorRequiredSetting?: Resolver<ResolversTypes['Github_EnterpriseEnabledSettingValue'], ParentType, ContextType>;
  twoFactorRequiredSettingOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseOwnerInfotwoFactorRequiredSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterprisePendingMemberInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterprisePendingMemberInvitationConnection'] = ResolversParentTypes['Github_EnterprisePendingMemberInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterprisePendingMemberInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterprisePendingMemberInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterprisePendingMemberInvitationEdge'] = ResolversParentTypes['Github_EnterprisePendingMemberInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseRepositoryInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseRepositoryInfo'] = ResolversParentTypes['Github_EnterpriseRepositoryInfo']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseRepositoryInfoConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseRepositoryInfoConnection'] = ResolversParentTypes['Github_EnterpriseRepositoryInfoConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseRepositoryInfoEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseRepositoryInfo']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseRepositoryInfoEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseRepositoryInfoEdge'] = ResolversParentTypes['Github_EnterpriseRepositoryInfoEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseRepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerInstallationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerInstallation'] = ResolversParentTypes['Github_EnterpriseServerInstallation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  customerName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hostName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isConnected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userAccounts?: Resolver<ResolversTypes['Github_EnterpriseServerUserAccountConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseServerInstallationuserAccountsArgs, 'orderBy'>>;
  userAccountsUploads?: Resolver<ResolversTypes['Github_EnterpriseServerUserAccountsUploadConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseServerInstallationuserAccountsUploadsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerInstallationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerInstallationConnection'] = ResolversParentTypes['Github_EnterpriseServerInstallationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerInstallationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerInstallation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerInstallationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerInstallationEdge'] = ResolversParentTypes['Github_EnterpriseServerInstallationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseServerInstallation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccount'] = ResolversParentTypes['Github_EnterpriseServerUserAccount']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  emails?: Resolver<ResolversTypes['Github_EnterpriseServerUserAccountEmailConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseServerUserAccountemailsArgs, 'orderBy'>>;
  enterpriseServerInstallation?: Resolver<ResolversTypes['Github_EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  profileName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  remoteCreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  remoteUserId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountConnection'] = ResolversParentTypes['Github_EnterpriseServerUserAccountConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerUserAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountEdge'] = ResolversParentTypes['Github_EnterpriseServerUserAccountEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseServerUserAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountEmailResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountEmail'] = ResolversParentTypes['Github_EnterpriseServerUserAccountEmail']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrimary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userAccount?: Resolver<ResolversTypes['Github_EnterpriseServerUserAccount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountEmailConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountEmailConnection'] = ResolversParentTypes['Github_EnterpriseServerUserAccountEmailConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountEmailEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountEmail']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountEmailEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountEmailEdge'] = ResolversParentTypes['Github_EnterpriseServerUserAccountEmailEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountEmail']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountsUploadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountsUpload'] = ResolversParentTypes['Github_EnterpriseServerUserAccountsUpload']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['Github_Enterprise'], ParentType, ContextType>;
  enterpriseServerInstallation?: Resolver<ResolversTypes['Github_EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  syncState?: Resolver<ResolversTypes['Github_EnterpriseServerUserAccountsUploadSyncState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountsUploadConnection'] = ResolversParentTypes['Github_EnterpriseServerUserAccountsUploadConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountsUploadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountsUpload']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseServerUserAccountsUploadEdge'] = ResolversParentTypes['Github_EnterpriseServerUserAccountsUploadEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_EnterpriseServerUserAccountsUpload']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnterpriseUserAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnterpriseUserAccount'] = ResolversParentTypes['Github_EnterpriseUserAccount']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_EnterpriseUserAccountavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<ResolversTypes['Github_Enterprise'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<ResolversTypes['Github_EnterpriseOrganizationMembershipConnection'], ParentType, ContextType, RequireFields<Github_EnterpriseUserAccountorganizationsArgs, 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnvironmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Environment'] = ResolversParentTypes['Github_Environment']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  protectionRules?: Resolver<ResolversTypes['Github_DeploymentProtectionRuleConnection'], ParentType, ContextType, Partial<Github_EnvironmentprotectionRulesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnvironmentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnvironmentConnection'] = ResolversParentTypes['Github_EnvironmentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_EnvironmentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Environment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_EnvironmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_EnvironmentEdge'] = ResolversParentTypes['Github_EnvironmentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ExternalIdentityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ExternalIdentity'] = ResolversParentTypes['Github_ExternalIdentity']> = ResolversObject<{
  guid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<ResolversTypes['Github_OrganizationInvitation']>, ParentType, ContextType>;
  samlIdentity?: Resolver<Maybe<ResolversTypes['Github_ExternalIdentitySamlAttributes']>, ParentType, ContextType>;
  scimIdentity?: Resolver<Maybe<ResolversTypes['Github_ExternalIdentityScimAttributes']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ExternalIdentityAttributeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ExternalIdentityAttribute'] = ResolversParentTypes['Github_ExternalIdentityAttribute']> = ResolversObject<{
  metadata?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ExternalIdentityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ExternalIdentityConnection'] = ResolversParentTypes['Github_ExternalIdentityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ExternalIdentityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ExternalIdentity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ExternalIdentityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ExternalIdentityEdge'] = ResolversParentTypes['Github_ExternalIdentityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ExternalIdentity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ExternalIdentitySamlAttributesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ExternalIdentitySamlAttributes'] = ResolversParentTypes['Github_ExternalIdentitySamlAttributes']> = ResolversObject<{
  attributes?: Resolver<Array<ResolversTypes['Github_ExternalIdentityAttribute']>, ParentType, ContextType>;
  emails?: Resolver<Maybe<Array<ResolversTypes['Github_UserEmailMetadata']>>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  nameId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ExternalIdentityScimAttributesResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ExternalIdentityScimAttributes'] = ResolversParentTypes['Github_ExternalIdentityScimAttributes']> = ResolversObject<{
  emails?: Resolver<Maybe<Array<ResolversTypes['Github_UserEmailMetadata']>>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_FollowOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_FollowOrganizationPayload'] = ResolversParentTypes['Github_FollowOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_FollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_FollowUserPayload'] = ResolversParentTypes['Github_FollowUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_FollowerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_FollowerConnection'] = ResolversParentTypes['Github_FollowerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_FollowingConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_FollowingConnection'] = ResolversParentTypes['Github_FollowingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_FundingLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_FundingLink'] = ResolversParentTypes['Github_FundingLink']> = ResolversObject<{
  platform?: Resolver<ResolversTypes['Github_FundingPlatform'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GenericHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GenericHovercardContext'] = ResolversParentTypes['Github_GenericHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Gist'] = ResolversParentTypes['Github_Gist']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['Github_GistCommentConnection'], ParentType, ContextType, Partial<Github_GistcommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  files?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_GistFile']>>>, ParentType, ContextType, RequireFields<Github_GistfilesArgs, 'limit'>>;
  forks?: Resolver<ResolversTypes['Github_GistConnection'], ParentType, ContextType, Partial<Github_GistforksArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_RepositoryOwner']>, ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['Github_StargazerConnection'], ParentType, ContextType, Partial<Github_GiststargazersArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GistComment'] = ResolversParentTypes['Github_GistComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  gist?: Resolver<ResolversTypes['Github_Gist'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_GistCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GistCommentConnection'] = ResolversParentTypes['Github_GistCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_GistCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_GistComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GistCommentEdge'] = ResolversParentTypes['Github_GistCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_GistComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GistConnection'] = ResolversParentTypes['Github_GistConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_GistEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Gist']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GistEdge'] = ResolversParentTypes['Github_GistEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Gist']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GistFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GistFile'] = ResolversParentTypes['Github_GistFile']> = ResolversObject<{
  encodedName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  encoding?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTruncated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['Github_Language']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<Github_GistFiletextArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GitActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GitActor'] = ResolversParentTypes['Github_GitActor']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_GitActoravatarUrlArgs>>;
  date?: Resolver<Maybe<ResolversTypes['Github_GitTimestamp']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GitActorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GitActorConnection'] = ResolversParentTypes['Github_GitActorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_GitActorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_GitActor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GitActorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GitActorEdge'] = ResolversParentTypes['Github_GitActorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_GitActor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GitHubMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GitHubMetadata'] = ResolversParentTypes['Github_GitHubMetadata']> = ResolversObject<{
  gitHubServicesSha?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  gitIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  hookIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  importerIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  isPasswordAuthenticationVerifiable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  pagesIpAddresses?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GitObjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GitObject'] = ResolversParentTypes['Github_GitObject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Blob' | 'Github_Commit' | 'Github_Tag' | 'Github_Tree', ParentType, ContextType>;
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
}>;

export interface Github_GitObjectIDScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_GitObjectID'], any> {
  name: 'Github_GitObjectID';
}

export interface Github_GitRefnameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_GitRefname'], any> {
  name: 'Github_GitRefname';
}

export interface Github_GitSSHRemoteScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_GitSSHRemote'], any> {
  name: 'Github_GitSSHRemote';
}

export type Github_GitSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GitSignature'] = ResolversParentTypes['Github_GitSignature']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_GpgSignature' | 'Github_SmimeSignature' | 'Github_SshSignature' | 'Github_UnknownSignature', ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export interface Github_GitTimestampScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_GitTimestamp'], any> {
  name: 'Github_GitTimestamp';
}

export type Github_GpgSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GpgSignature'] = ResolversParentTypes['Github_GpgSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  keyId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GrantEnterpriseOrganizationsMigratorRolePayload'] = ResolversParentTypes['Github_GrantEnterpriseOrganizationsMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<Maybe<ResolversTypes['Github_OrganizationConnection']>, ParentType, ContextType, Partial<Github_GrantEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_GrantMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_GrantMigratorRolePayload'] = ResolversParentTypes['Github_GrantMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Github_HTMLScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_HTML'], any> {
  name: 'Github_HTML';
}

export type Github_HeadRefDeletedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_HeadRefDeletedEvent'] = ResolversParentTypes['Github_HeadRefDeletedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  headRef?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_HeadRefForcePushedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_HeadRefForcePushedEvent'] = ResolversParentTypes['Github_HeadRefForcePushedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_HeadRefRestoredEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_HeadRefRestoredEvent'] = ResolversParentTypes['Github_HeadRefRestoredEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_HovercardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Hovercard'] = ResolversParentTypes['Github_Hovercard']> = ResolversObject<{
  contexts?: Resolver<Array<ResolversTypes['Github_HovercardContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_HovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_HovercardContext'] = ResolversParentTypes['Github_HovercardContext']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_GenericHovercardContext' | 'Github_OrganizationTeamsHovercardContext' | 'Github_OrganizationsHovercardContext' | 'Github_ReviewStatusHovercardContext' | 'Github_ViewerHovercardContext', ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type Github_ImportProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ImportProjectPayload'] = ResolversParentTypes['Github_ImportProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_InviteEnterpriseAdminPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_InviteEnterpriseAdminPayload'] = ResolversParentTypes['Github_InviteEnterpriseAdminPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IpAllowListEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IpAllowListEntry'] = ResolversParentTypes['Github_IpAllowListEntry']> = ResolversObject<{
  allowListValue?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Github_IpAllowListOwner'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IpAllowListEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IpAllowListEntryConnection'] = ResolversParentTypes['Github_IpAllowListEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IpAllowListEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IpAllowListEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IpAllowListEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IpAllowListEntryEdge'] = ResolversParentTypes['Github_IpAllowListEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IpAllowListOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IpAllowListOwner'] = ResolversParentTypes['Github_IpAllowListOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_App' | 'Github_Enterprise' | 'Github_Organization', ParentType, ContextType>;
}>;

export type Github_IssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Issue'] = ResolversParentTypes['Github_Issue']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['Github_LockReason']>, ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_IssueassigneesArgs>>;
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Github_IssueCommentConnection'], ParentType, ContextType, Partial<Github_IssuecommentsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['Github_Hovercard'], ParentType, ContextType, RequireFields<Github_IssuehovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isReadByViewer?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['Github_LabelConnection']>, ParentType, ContextType, RequireFields<Github_IssuelabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  linkedBranches?: Resolver<ResolversTypes['Github_LinkedBranchConnection'], ParentType, ContextType, Partial<Github_IssuelinkedBranchesArgs>>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Github_Milestone']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_IssueparticipantsArgs>>;
  projectCards?: Resolver<ResolversTypes['Github_ProjectCardConnection'], ParentType, ContextType, RequireFields<Github_IssueprojectCardsArgs, 'archivedStates'>>;
  projectItems?: Resolver<ResolversTypes['Github_ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<Github_IssueprojectItemsArgs, 'includeArchived'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_IssueprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_IssueprojectsV2Args, 'orderBy'>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_IssuereactionsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_IssueState'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['Github_IssueStateReason']>, ParentType, ContextType>;
  timeline?: Resolver<ResolversTypes['Github_IssueTimelineConnection'], ParentType, ContextType, Partial<Github_IssuetimelineArgs>>;
  timelineItems?: Resolver<ResolversTypes['Github_IssueTimelineItemsConnection'], ParentType, ContextType, Partial<Github_IssuetimelineItemsArgs>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  trackedInIssues?: Resolver<ResolversTypes['Github_IssueConnection'], ParentType, ContextType, Partial<Github_IssuetrackedInIssuesArgs>>;
  trackedIssues?: Resolver<ResolversTypes['Github_IssueConnection'], ParentType, ContextType, Partial<Github_IssuetrackedIssuesArgs>>;
  trackedIssuesCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType, Partial<Github_IssuetrackedIssuesCountArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_IssueuserContentEditsArgs>>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueComment'] = ResolversParentTypes['Github_IssueComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Github_Issue'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_IssueCommentreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_IssueCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueCommentConnection'] = ResolversParentTypes['Github_IssueCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueCommentEdge'] = ResolversParentTypes['Github_IssueCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueConnection'] = ResolversParentTypes['Github_IssueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Issue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueContributionsByRepository'] = ResolversParentTypes['Github_IssueContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['Github_CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<Github_IssueContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueEdge'] = ResolversParentTypes['Github_IssueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueOrPullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueOrPullRequest'] = ResolversParentTypes['Github_IssueOrPullRequest']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_IssueTemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTemplate'] = ResolversParentTypes['Github_IssueTemplate']> = ResolversObject<{
  about?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueTimelineConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTimelineConnection'] = ResolversParentTypes['Github_IssueTimelineConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueTimelineItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTimelineItem'] = ResolversParentTypes['Github_IssueTimelineItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_AssignedEvent' | 'Github_ClosedEvent' | 'Github_Commit' | 'Github_CrossReferencedEvent' | 'Github_DemilestonedEvent' | 'Github_IssueComment' | 'Github_LabeledEvent' | 'Github_LockedEvent' | 'Github_MilestonedEvent' | 'Github_ReferencedEvent' | 'Github_RenamedTitleEvent' | 'Github_ReopenedEvent' | 'Github_SubscribedEvent' | 'Github_TransferredEvent' | 'Github_UnassignedEvent' | 'Github_UnlabeledEvent' | 'Github_UnlockedEvent' | 'Github_UnsubscribedEvent' | 'Github_UserBlockedEvent', ParentType, ContextType>;
}>;

export type Github_IssueTimelineItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTimelineItemEdge'] = ResolversParentTypes['Github_IssueTimelineItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_IssueTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueTimelineItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTimelineItems'] = ResolversParentTypes['Github_IssueTimelineItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_AddedToProjectEvent' | 'Github_AssignedEvent' | 'Github_ClosedEvent' | 'Github_CommentDeletedEvent' | 'Github_ConnectedEvent' | 'Github_ConvertedNoteToIssueEvent' | 'Github_ConvertedToDiscussionEvent' | 'Github_CrossReferencedEvent' | 'Github_DemilestonedEvent' | 'Github_DisconnectedEvent' | 'Github_IssueComment' | 'Github_LabeledEvent' | 'Github_LockedEvent' | 'Github_MarkedAsDuplicateEvent' | 'Github_MentionedEvent' | 'Github_MilestonedEvent' | 'Github_MovedColumnsInProjectEvent' | 'Github_PinnedEvent' | 'Github_ReferencedEvent' | 'Github_RemovedFromProjectEvent' | 'Github_RenamedTitleEvent' | 'Github_ReopenedEvent' | 'Github_SubscribedEvent' | 'Github_TransferredEvent' | 'Github_UnassignedEvent' | 'Github_UnlabeledEvent' | 'Github_UnlockedEvent' | 'Github_UnmarkedAsDuplicateEvent' | 'Github_UnpinnedEvent' | 'Github_UnsubscribedEvent' | 'Github_UserBlockedEvent', ParentType, ContextType>;
}>;

export type Github_IssueTimelineItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTimelineItemsConnection'] = ResolversParentTypes['Github_IssueTimelineItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_IssueTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_IssueTimelineItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_IssueTimelineItemsEdge'] = ResolversParentTypes['Github_IssueTimelineItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_IssueTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_JoinedGitHubContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_JoinedGitHubContribution'] = ResolversParentTypes['Github_JoinedGitHubContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LabelResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Label'] = ResolversParentTypes['Github_Label']> = ResolversObject<{
  color?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['Github_IssueConnection'], ParentType, ContextType, Partial<Github_LabelissuesArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['Github_PullRequestConnection'], ParentType, ContextType, Partial<Github_LabelpullRequestsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LabelConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LabelConnection'] = ResolversParentTypes['Github_LabelConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_LabelEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Label']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LabelEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LabelEdge'] = ResolversParentTypes['Github_LabelEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LabelableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Labelable'] = ResolversParentTypes['Github_Labelable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Discussion' | 'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['Github_LabelConnection']>, ParentType, ContextType, RequireFields<Github_LabelablelabelsArgs, 'orderBy'>>;
}>;

export type Github_LabeledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LabeledEvent'] = ResolversParentTypes['Github_LabeledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['Github_Label'], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes['Github_Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LanguageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Language'] = ResolversParentTypes['Github_Language']> = ResolversObject<{
  color?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LanguageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LanguageConnection'] = ResolversParentTypes['Github_LanguageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_LanguageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Language']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LanguageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LanguageEdge'] = ResolversParentTypes['Github_LanguageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_Language'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LicenseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_License'] = ResolversParentTypes['Github_License']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  conditions?: Resolver<Array<Maybe<ResolversTypes['Github_LicenseRule']>>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  featured?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  implementation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  limitations?: Resolver<Array<Maybe<ResolversTypes['Github_LicenseRule']>>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nickname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<ResolversTypes['Github_LicenseRule']>>, ParentType, ContextType>;
  pseudoLicense?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  spdxId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LicenseRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LicenseRule'] = ResolversParentTypes['Github_LicenseRule']> = ResolversObject<{
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LinkProjectV2ToRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LinkProjectV2ToRepositoryPayload'] = ResolversParentTypes['Github_LinkProjectV2ToRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LinkProjectV2ToTeamPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LinkProjectV2ToTeamPayload'] = ResolversParentTypes['Github_LinkProjectV2ToTeamPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LinkRepositoryToProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LinkRepositoryToProjectPayload'] = ResolversParentTypes['Github_LinkRepositoryToProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LinkedBranchResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LinkedBranch'] = ResolversParentTypes['Github_LinkedBranch']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LinkedBranchConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LinkedBranchConnection'] = ResolversParentTypes['Github_LinkedBranchConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_LinkedBranchEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_LinkedBranch']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LinkedBranchEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LinkedBranchEdge'] = ResolversParentTypes['Github_LinkedBranchEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_LinkedBranch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LockLockablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LockLockablePayload'] = ResolversParentTypes['Github_LockLockablePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lockedRecord?: Resolver<Maybe<ResolversTypes['Github_Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_LockableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Lockable'] = ResolversParentTypes['Github_Lockable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Discussion' | 'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
  activeLockReason?: Resolver<Maybe<ResolversTypes['Github_LockReason']>, ParentType, ContextType>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_LockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_LockedEvent'] = ResolversParentTypes['Github_LockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['Github_LockReason']>, ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes['Github_Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MannequinResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Mannequin'] = ResolversParentTypes['Github_Mannequin']> = ResolversObject<{
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_MannequinavatarUrlArgs>>;
  claimant?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MannequinConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MannequinConnection'] = ResolversParentTypes['Github_MannequinConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_MannequinEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Mannequin']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MannequinEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MannequinEdge'] = ResolversParentTypes['Github_MannequinEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Mannequin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarkDiscussionCommentAsAnswerPayload'] = ResolversParentTypes['Github_MarkDiscussionCommentAsAnswerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarkFileAsViewedPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarkFileAsViewedPayload'] = ResolversParentTypes['Github_MarkFileAsViewedPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarkPullRequestReadyForReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarkPullRequestReadyForReviewPayload'] = ResolversParentTypes['Github_MarkPullRequestReadyForReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarkedAsDuplicateEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarkedAsDuplicateEvent'] = ResolversParentTypes['Github_MarkedAsDuplicateEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  canonical?: Resolver<Maybe<ResolversTypes['Github_IssueOrPullRequest']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['Github_IssueOrPullRequest']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarketplaceCategoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarketplaceCategory'] = ResolversParentTypes['Github_MarketplaceCategory']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  primaryListingCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  secondaryListingCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarketplaceListingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarketplaceListing'] = ResolversParentTypes['Github_MarketplaceListing']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['Github_App']>, ParentType, ContextType>;
  companyUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  configurationResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  configurationUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  documentationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  extendedDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extendedDescriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  fullDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  hasPublishedFreeTrialPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasTermsOfService?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasVerifiedOwner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  howItWorksHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  installationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  installedForViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPaid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRejected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverifiedPending?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromUnverified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logoBackgroundColor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType, RequireFields<Github_MarketplaceListinglogoUrlArgs, 'size'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  normalizedShortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pricingUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  primaryCategory?: Resolver<ResolversTypes['Github_MarketplaceCategory'], ParentType, ContextType>;
  privacyPolicyUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  screenshotUrls?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  secondaryCategory?: Resolver<Maybe<ResolversTypes['Github_MarketplaceCategory']>, ParentType, ContextType>;
  shortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  statusUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  supportEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  supportUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  termsOfServiceUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanAddPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditCategories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditPlans?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRedraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReject?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRequestApproval?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchasedForAllOrganizations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsListingAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarketplaceListingConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarketplaceListingConnection'] = ResolversParentTypes['Github_MarketplaceListingConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_MarketplaceListingEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_MarketplaceListing']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MarketplaceListingEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MarketplaceListingEdge'] = ResolversParentTypes['Github_MarketplaceListingEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_MarketplaceListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MemberStatusableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MemberStatusable'] = ResolversParentTypes['Github_MemberStatusable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_Team', ParentType, ContextType>;
  memberStatuses?: Resolver<ResolversTypes['Github_UserStatusConnection'], ParentType, ContextType, RequireFields<Github_MemberStatusablememberStatusesArgs, 'orderBy'>>;
}>;

export type Github_MembersCanDeleteReposClearAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry'] = ResolversParentTypes['Github_MembersCanDeleteReposClearAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MembersCanDeleteReposDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry'] = ResolversParentTypes['Github_MembersCanDeleteReposDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MembersCanDeleteReposEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry'] = ResolversParentTypes['Github_MembersCanDeleteReposEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MentionedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MentionedEvent'] = ResolversParentTypes['Github_MentionedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MergeBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MergeBranchPayload'] = ResolversParentTypes['Github_MergeBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MergePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MergePullRequestPayload'] = ResolversParentTypes['Github_MergePullRequestPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MergedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MergedEvent'] = ResolversParentTypes['Github_MergedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  mergeRef?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  mergeRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Migration'] = ResolversParentTypes['Github_Migration']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_RepositoryMigration', ParentType, ContextType>;
  continueOnError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  migrationLogUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  migrationSource?: Resolver<ResolversTypes['Github_MigrationSource'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_MigrationState'], ParentType, ContextType>;
}>;

export type Github_MigrationSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MigrationSource'] = ResolversParentTypes['Github_MigrationSource']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['Github_MigrationSourceType'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MilestoneResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Milestone'] = ResolversParentTypes['Github_Milestone']> = ResolversObject<{
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dueOn?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['Github_IssueConnection'], ParentType, ContextType, Partial<Github_MilestoneissuesArgs>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  progressPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['Github_PullRequestConnection'], ParentType, ContextType, Partial<Github_MilestonepullRequestsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_MilestoneState'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MilestoneConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MilestoneConnection'] = ResolversParentTypes['Github_MilestoneConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_MilestoneEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Milestone']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MilestoneEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MilestoneEdge'] = ResolversParentTypes['Github_MilestoneEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MilestoneItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MilestoneItem'] = ResolversParentTypes['Github_MilestoneItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_MilestonedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MilestonedEvent'] = ResolversParentTypes['Github_MilestonedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Github_MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MinimizableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Minimizable'] = ResolversParentTypes['Github_Minimizable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_DiscussionComment' | 'Github_GistComment' | 'Github_IssueComment' | 'Github_PullRequestReviewComment', ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_MinimizeCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MinimizeCommentPayload'] = ResolversParentTypes['Github_MinimizeCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimizedComment?: Resolver<Maybe<ResolversTypes['Github_Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MoveProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MoveProjectCardPayload'] = ResolversParentTypes['Github_MoveProjectCardPayload']> = ResolversObject<{
  cardEdge?: Resolver<Maybe<ResolversTypes['Github_ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MoveProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MoveProjectColumnPayload'] = ResolversParentTypes['Github_MoveProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<ResolversTypes['Github_ProjectColumnEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_MovedColumnsInProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_MovedColumnsInProjectEvent'] = ResolversParentTypes['Github_MovedColumnsInProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousProjectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['Github_ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_NodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Node'] = ResolversParentTypes['Github_Node']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_AddedToProjectEvent' | 'Github_App' | 'Github_AssignedEvent' | 'Github_AutoMergeDisabledEvent' | 'Github_AutoMergeEnabledEvent' | 'Github_AutoRebaseEnabledEvent' | 'Github_AutoSquashEnabledEvent' | 'Github_AutomaticBaseChangeFailedEvent' | 'Github_AutomaticBaseChangeSucceededEvent' | 'Github_BaseRefChangedEvent' | 'Github_BaseRefDeletedEvent' | 'Github_BaseRefForcePushedEvent' | 'Github_Blob' | 'Github_Bot' | 'Github_BranchProtectionRule' | 'Github_BypassForcePushAllowance' | 'Github_BypassPullRequestAllowance' | 'Github_CWE' | 'Github_CheckRun' | 'Github_CheckSuite' | 'Github_ClosedEvent' | 'Github_CodeOfConduct' | 'Github_CommentDeletedEvent' | 'Github_Commit' | 'Github_CommitComment' | 'Github_CommitCommentThread' | 'Github_Comparison' | 'Github_ConnectedEvent' | 'Github_ConvertToDraftEvent' | 'Github_ConvertedNoteToIssueEvent' | 'Github_ConvertedToDiscussionEvent' | 'Github_CrossReferencedEvent' | 'Github_DemilestonedEvent' | 'Github_DependencyGraphManifest' | 'Github_DeployKey' | 'Github_DeployedEvent' | 'Github_Deployment' | 'Github_DeploymentEnvironmentChangedEvent' | 'Github_DeploymentReview' | 'Github_DeploymentStatus' | 'Github_DisconnectedEvent' | 'Github_Discussion' | 'Github_DiscussionCategory' | 'Github_DiscussionComment' | 'Github_DiscussionPoll' | 'Github_DiscussionPollOption' | 'Github_DraftIssue' | 'Github_Enterprise' | 'Github_EnterpriseAdministratorInvitation' | 'Github_EnterpriseIdentityProvider' | 'Github_EnterpriseRepositoryInfo' | 'Github_EnterpriseServerInstallation' | 'Github_EnterpriseServerUserAccount' | 'Github_EnterpriseServerUserAccountEmail' | 'Github_EnterpriseServerUserAccountsUpload' | 'Github_EnterpriseUserAccount' | 'Github_Environment' | 'Github_ExternalIdentity' | 'Github_Gist' | 'Github_GistComment' | 'Github_HeadRefDeletedEvent' | 'Github_HeadRefForcePushedEvent' | 'Github_HeadRefRestoredEvent' | 'Github_IpAllowListEntry' | 'Github_Issue' | 'Github_IssueComment' | 'Github_Label' | 'Github_LabeledEvent' | 'Github_Language' | 'Github_License' | 'Github_LinkedBranch' | 'Github_LockedEvent' | 'Github_Mannequin' | 'Github_MarkedAsDuplicateEvent' | 'Github_MarketplaceCategory' | 'Github_MarketplaceListing' | 'Github_MembersCanDeleteReposClearAuditEntry' | 'Github_MembersCanDeleteReposDisableAuditEntry' | 'Github_MembersCanDeleteReposEnableAuditEntry' | 'Github_MentionedEvent' | 'Github_MergedEvent' | 'Github_MigrationSource' | 'Github_Milestone' | 'Github_MilestonedEvent' | 'Github_MovedColumnsInProjectEvent' | 'Github_OIDCProvider' | 'Github_OauthApplicationCreateAuditEntry' | 'Github_OrgAddBillingManagerAuditEntry' | 'Github_OrgAddMemberAuditEntry' | 'Github_OrgBlockUserAuditEntry' | 'Github_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_OrgCreateAuditEntry' | 'Github_OrgDisableOauthAppRestrictionsAuditEntry' | 'Github_OrgDisableSamlAuditEntry' | 'Github_OrgDisableTwoFactorRequirementAuditEntry' | 'Github_OrgEnableOauthAppRestrictionsAuditEntry' | 'Github_OrgEnableSamlAuditEntry' | 'Github_OrgEnableTwoFactorRequirementAuditEntry' | 'Github_OrgInviteMemberAuditEntry' | 'Github_OrgInviteToBusinessAuditEntry' | 'Github_OrgOauthAppAccessApprovedAuditEntry' | 'Github_OrgOauthAppAccessDeniedAuditEntry' | 'Github_OrgOauthAppAccessRequestedAuditEntry' | 'Github_OrgRemoveBillingManagerAuditEntry' | 'Github_OrgRemoveMemberAuditEntry' | 'Github_OrgRemoveOutsideCollaboratorAuditEntry' | 'Github_OrgRestoreMemberAuditEntry' | 'Github_OrgUnblockUserAuditEntry' | 'Github_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'Github_OrgUpdateMemberAuditEntry' | 'Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'Github_Organization' | 'Github_OrganizationIdentityProvider' | 'Github_OrganizationInvitation' | 'Github_OrganizationMigration' | 'Github_Package' | 'Github_PackageFile' | 'Github_PackageTag' | 'Github_PackageVersion' | 'Github_PinnedDiscussion' | 'Github_PinnedEvent' | 'Github_PinnedIssue' | 'Github_PrivateRepositoryForkingDisableAuditEntry' | 'Github_PrivateRepositoryForkingEnableAuditEntry' | 'Github_Project' | 'Github_ProjectCard' | 'Github_ProjectColumn' | 'Github_ProjectV2' | 'Github_ProjectV2Field' | 'Github_ProjectV2Item' | 'Github_ProjectV2ItemFieldDateValue' | 'Github_ProjectV2ItemFieldIterationValue' | 'Github_ProjectV2ItemFieldNumberValue' | 'Github_ProjectV2ItemFieldSingleSelectValue' | 'Github_ProjectV2ItemFieldTextValue' | 'Github_ProjectV2IterationField' | 'Github_ProjectV2SingleSelectField' | 'Github_ProjectV2View' | 'Github_ProjectV2Workflow' | 'Github_PublicKey' | 'Github_PullRequest' | 'Github_PullRequestCommit' | 'Github_PullRequestCommitCommentThread' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_PullRequestReviewThread' | 'Github_PullRequestThread' | 'Github_Push' | 'Github_PushAllowance' | 'Github_Reaction' | 'Github_ReadyForReviewEvent' | 'Github_Ref' | 'Github_ReferencedEvent' | 'Github_Release' | 'Github_ReleaseAsset' | 'Github_RemovedFromProjectEvent' | 'Github_RenamedTitleEvent' | 'Github_ReopenedEvent' | 'Github_RepoAccessAuditEntry' | 'Github_RepoAddMemberAuditEntry' | 'Github_RepoAddTopicAuditEntry' | 'Github_RepoArchivedAuditEntry' | 'Github_RepoChangeMergeSettingAuditEntry' | 'Github_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigDisableContributorsOnlyAuditEntry' | 'Github_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigEnableContributorsOnlyAuditEntry' | 'Github_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigLockAnonymousGitAccessAuditEntry' | 'Github_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'Github_RepoCreateAuditEntry' | 'Github_RepoDestroyAuditEntry' | 'Github_RepoRemoveMemberAuditEntry' | 'Github_RepoRemoveTopicAuditEntry' | 'Github_Repository' | 'Github_RepositoryInvitation' | 'Github_RepositoryMigration' | 'Github_RepositoryTopic' | 'Github_RepositoryVisibilityChangeDisableAuditEntry' | 'Github_RepositoryVisibilityChangeEnableAuditEntry' | 'Github_RepositoryVulnerabilityAlert' | 'Github_ReviewDismissalAllowance' | 'Github_ReviewDismissedEvent' | 'Github_ReviewRequest' | 'Github_ReviewRequestRemovedEvent' | 'Github_ReviewRequestedEvent' | 'Github_SavedReply' | 'Github_SecurityAdvisory' | 'Github_SponsorsActivity' | 'Github_SponsorsListing' | 'Github_SponsorsListingFeaturedItem' | 'Github_SponsorsTier' | 'Github_Sponsorship' | 'Github_SponsorshipNewsletter' | 'Github_Status' | 'Github_StatusCheckRollup' | 'Github_StatusContext' | 'Github_SubscribedEvent' | 'Github_Tag' | 'Github_Team' | 'Github_TeamAddMemberAuditEntry' | 'Github_TeamAddRepositoryAuditEntry' | 'Github_TeamChangeParentTeamAuditEntry' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment' | 'Github_TeamRemoveMemberAuditEntry' | 'Github_TeamRemoveRepositoryAuditEntry' | 'Github_Topic' | 'Github_TransferredEvent' | 'Github_Tree' | 'Github_UnassignedEvent' | 'Github_UnlabeledEvent' | 'Github_UnlockedEvent' | 'Github_UnmarkedAsDuplicateEvent' | 'Github_UnpinnedEvent' | 'Github_UnsubscribedEvent' | 'Github_User' | 'Github_UserBlockedEvent' | 'Github_UserContentEdit' | 'Github_UserStatus' | 'Github_VerifiableDomain' | 'Github_Workflow' | 'Github_WorkflowRun', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
}>;

export type Github_OIDCProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OIDCProvider'] = ResolversParentTypes['Github_OIDCProvider']> = ResolversObject<{
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['Github_ExternalIdentityConnection'], ParentType, ContextType, Partial<Github_OIDCProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  providerType?: Resolver<ResolversTypes['Github_OIDCProviderType'], ParentType, ContextType>;
  tenantId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OauthApplicationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OauthApplicationAuditEntryData'] = ResolversParentTypes['Github_OauthApplicationAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_OauthApplicationCreateAuditEntry' | 'Github_OrgOauthAppAccessApprovedAuditEntry' | 'Github_OrgOauthAppAccessDeniedAuditEntry' | 'Github_OrgOauthAppAccessRequestedAuditEntry', ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_OauthApplicationCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OauthApplicationCreateAuditEntry'] = ResolversParentTypes['Github_OauthApplicationCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  applicationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  callbackUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  rateLimit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['Github_OauthApplicationCreateAuditEntryState']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgAddBillingManagerAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgAddBillingManagerAuditEntry'] = ResolversParentTypes['Github_OrgAddBillingManagerAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitationEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgAddMemberAuditEntry'] = ResolversParentTypes['Github_OrgAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['Github_OrgAddMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgBlockUserAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgBlockUserAuditEntry'] = ResolversParentTypes['Github_OrgBlockUserAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['Github_OrgConfigDisableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['Github_OrgConfigEnableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgCreateAuditEntry'] = ResolversParentTypes['Github_OrgCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  billingPlan?: Resolver<Maybe<ResolversTypes['Github_OrgCreateAuditEntryBillingPlan']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry'] = ResolversParentTypes['Github_OrgDisableOauthAppRestrictionsAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgDisableSamlAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgDisableSamlAuditEntry'] = ResolversParentTypes['Github_OrgDisableSamlAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgDisableTwoFactorRequirementAuditEntry'] = ResolversParentTypes['Github_OrgDisableTwoFactorRequirementAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry'] = ResolversParentTypes['Github_OrgEnableOauthAppRestrictionsAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgEnableSamlAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgEnableSamlAuditEntry'] = ResolversParentTypes['Github_OrgEnableSamlAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgEnableTwoFactorRequirementAuditEntry'] = ResolversParentTypes['Github_OrgEnableTwoFactorRequirementAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgInviteMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgInviteMemberAuditEntry'] = ResolversParentTypes['Github_OrgInviteMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<ResolversTypes['Github_OrganizationInvitation']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgInviteToBusinessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry'] = ResolversParentTypes['Github_OrgInviteToBusinessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry'] = ResolversParentTypes['Github_OrgOauthAppAccessApprovedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry'] = ResolversParentTypes['Github_OrgOauthAppAccessDeniedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry'] = ResolversParentTypes['Github_OrgOauthAppAccessRequestedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRemoveBillingManagerAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRemoveBillingManagerAuditEntry'] = ResolversParentTypes['Github_OrgRemoveBillingManagerAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['Github_OrgRemoveBillingManagerAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRemoveMemberAuditEntry'] = ResolversParentTypes['Github_OrgRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<ResolversTypes['Github_OrgRemoveMemberAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['Github_OrgRemoveMemberAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry'] = ResolversParentTypes['Github_OrgRemoveOutsideCollaboratorAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<ResolversTypes['Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['Github_OrgRemoveOutsideCollaboratorAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRestoreMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRestoreMemberAuditEntry'] = ResolversParentTypes['Github_OrgRestoreMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  restoredCustomEmailRoutingsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredIssueAssignmentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredMemberships?: Resolver<Maybe<Array<ResolversTypes['Github_OrgRestoreMemberAuditEntryMembership']>>, ParentType, ContextType>;
  restoredMembershipsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryStarsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryWatchesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRestoreMemberAuditEntryMembershipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRestoreMemberAuditEntryMembership'] = ResolversParentTypes['Github_OrgRestoreMemberAuditEntryMembership']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'Github_OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'Github_OrgRestoreMemberMembershipTeamAuditEntryData', ParentType, ContextType>;
}>;

export type Github_OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRestoreMemberMembershipOrganizationAuditEntryData'] = ResolversParentTypes['Github_OrgRestoreMemberMembershipOrganizationAuditEntryData']> = ResolversObject<{
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRestoreMemberMembershipRepositoryAuditEntryData'] = ResolversParentTypes['Github_OrgRestoreMemberMembershipRepositoryAuditEntryData']> = ResolversObject<{
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgRestoreMemberMembershipTeamAuditEntryData'] = ResolversParentTypes['Github_OrgRestoreMemberMembershipTeamAuditEntryData']> = ResolversObject<{
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgUnblockUserAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgUnblockUserAuditEntry'] = ResolversParentTypes['Github_OrgUnblockUserAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry'] = ResolversParentTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<ResolversTypes['Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgUpdateMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgUpdateMemberAuditEntry'] = ResolversParentTypes['Github_OrgUpdateMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<ResolversTypes['Github_OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<ResolversTypes['Github_OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] = ResolversParentTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  canCreateRepositories?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] = ResolversParentTypes['Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  canInviteOutsideCollaboratorsToRepositories?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Organization'] = ResolversParentTypes['Github_Organization']> = ResolversObject<{
  announcement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  announcementExpiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  announcementUserDismissible?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<Github_OrganizationanyPinnableItemsArgs>>;
  auditLog?: Resolver<ResolversTypes['Github_OrganizationAuditEntryConnection'], ParentType, ContextType, RequireFields<Github_OrganizationauditLogArgs, 'orderBy'>>;
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_OrganizationavatarUrlArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domains?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomainConnection']>, ParentType, ContextType, RequireFields<Github_OrganizationdomainsArgs, 'isApproved' | 'isVerified' | 'orderBy'>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseOwners?: Resolver<ResolversTypes['Github_OrganizationEnterpriseOwnerConnection'], ParentType, ContextType, RequireFields<Github_OrganizationenterpriseOwnersArgs, 'orderBy'>>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['Github_RepositoryInteractionAbility']>, ParentType, ContextType>;
  ipAllowListEnabledSetting?: Resolver<ResolversTypes['Github_IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<ResolversTypes['Github_IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<Github_OrganizationipAllowListEntriesArgs, 'orderBy'>>;
  ipAllowListForInstalledAppsEnabledSetting?: Resolver<ResolversTypes['Github_IpAllowListForInstalledAppsEnabledSettingValue'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<Github_OrganizationisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  itemShowcase?: Resolver<ResolversTypes['Github_ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mannequins?: Resolver<ResolversTypes['Github_MannequinConnection'], ParentType, ContextType, RequireFields<Github_OrganizationmannequinsArgs, 'orderBy'>>;
  memberStatuses?: Resolver<ResolversTypes['Github_UserStatusConnection'], ParentType, ContextType, RequireFields<Github_OrganizationmemberStatusesArgs, 'orderBy'>>;
  membersCanForkPrivateRepositories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  membersWithRole?: Resolver<ResolversTypes['Github_OrganizationMemberConnection'], ParentType, ContextType, Partial<Github_OrganizationmembersWithRoleArgs>>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newTeamResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  notificationDeliveryRestrictionEnabledSetting?: Resolver<ResolversTypes['Github_NotificationRestrictionSettingValue'], ParentType, ContextType>;
  organizationBillingEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['Github_PackageConnection'], ParentType, ContextType, RequireFields<Github_OrganizationpackagesArgs, 'orderBy'>>;
  pendingMembers?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_OrganizationpendingMembersArgs>>;
  pinnableItems?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_OrganizationpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_OrganizationpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType, RequireFields<Github_OrganizationprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_OrganizationprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['Github_ProjectConnection'], ParentType, ContextType, Partial<Github_OrganizationprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_OrganizationprojectsV2Args, 'orderBy'>>;
  recentProjects?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, Partial<Github_OrganizationrecentProjectsArgs>>;
  repositories?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_OrganizationrepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType, RequireFields<Github_OrganizationrepositoryArgs, 'followRenames' | 'name'>>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['Github_DiscussionCommentConnection'], ParentType, ContextType, RequireFields<Github_OrganizationrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
  repositoryDiscussions?: Resolver<ResolversTypes['Github_DiscussionConnection'], ParentType, ContextType, RequireFields<Github_OrganizationrepositoryDiscussionsArgs, 'answered' | 'orderBy'>>;
  repositoryMigrations?: Resolver<ResolversTypes['Github_RepositoryMigrationConnection'], ParentType, ContextType, RequireFields<Github_OrganizationrepositoryMigrationsArgs, 'orderBy'>>;
  requiresTwoFactorAuthentication?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  samlIdentityProvider?: Resolver<Maybe<ResolversTypes['Github_OrganizationIdentityProvider']>, ParentType, ContextType>;
  sponsoring?: Resolver<ResolversTypes['Github_SponsorConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['Github_SponsorConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['Github_SponsorsActivityConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['Github_SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType, RequireFields<Github_OrganizationsponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType, RequireFields<Github_OrganizationsponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['Github_SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsponsorshipsAsSponsorArgs, 'activeOnly'>>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType, RequireFields<Github_OrganizationteamArgs, 'slug'>>;
  teams?: Resolver<ResolversTypes['Github_TeamConnection'], ParentType, ContextType, RequireFields<Github_OrganizationteamsArgs, 'rootTeamsOnly'>>;
  teamsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Github_OrganizationtotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateRepositories?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateTeams?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsAMember?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  webCommitSignoffRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationAuditEntry'] = ResolversParentTypes['Github_OrganizationAuditEntry']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_MembersCanDeleteReposClearAuditEntry' | 'Github_MembersCanDeleteReposDisableAuditEntry' | 'Github_MembersCanDeleteReposEnableAuditEntry' | 'Github_OauthApplicationCreateAuditEntry' | 'Github_OrgAddBillingManagerAuditEntry' | 'Github_OrgAddMemberAuditEntry' | 'Github_OrgBlockUserAuditEntry' | 'Github_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_OrgCreateAuditEntry' | 'Github_OrgDisableOauthAppRestrictionsAuditEntry' | 'Github_OrgDisableSamlAuditEntry' | 'Github_OrgDisableTwoFactorRequirementAuditEntry' | 'Github_OrgEnableOauthAppRestrictionsAuditEntry' | 'Github_OrgEnableSamlAuditEntry' | 'Github_OrgEnableTwoFactorRequirementAuditEntry' | 'Github_OrgInviteMemberAuditEntry' | 'Github_OrgInviteToBusinessAuditEntry' | 'Github_OrgOauthAppAccessApprovedAuditEntry' | 'Github_OrgOauthAppAccessDeniedAuditEntry' | 'Github_OrgOauthAppAccessRequestedAuditEntry' | 'Github_OrgRemoveBillingManagerAuditEntry' | 'Github_OrgRemoveMemberAuditEntry' | 'Github_OrgRemoveOutsideCollaboratorAuditEntry' | 'Github_OrgRestoreMemberAuditEntry' | 'Github_OrgUnblockUserAuditEntry' | 'Github_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'Github_OrgUpdateMemberAuditEntry' | 'Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'Github_PrivateRepositoryForkingDisableAuditEntry' | 'Github_PrivateRepositoryForkingEnableAuditEntry' | 'Github_RepoAccessAuditEntry' | 'Github_RepoAddMemberAuditEntry' | 'Github_RepoAddTopicAuditEntry' | 'Github_RepoArchivedAuditEntry' | 'Github_RepoChangeMergeSettingAuditEntry' | 'Github_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigDisableContributorsOnlyAuditEntry' | 'Github_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigEnableContributorsOnlyAuditEntry' | 'Github_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigLockAnonymousGitAccessAuditEntry' | 'Github_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'Github_RepoCreateAuditEntry' | 'Github_RepoDestroyAuditEntry' | 'Github_RepoRemoveMemberAuditEntry' | 'Github_RepoRemoveTopicAuditEntry' | 'Github_RepositoryVisibilityChangeDisableAuditEntry' | 'Github_RepositoryVisibilityChangeEnableAuditEntry' | 'Github_TeamAddMemberAuditEntry' | 'Github_TeamAddRepositoryAuditEntry' | 'Github_TeamChangeParentTeamAuditEntry' | 'Github_TeamRemoveMemberAuditEntry' | 'Github_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
}>;

export type Github_OrganizationAuditEntryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationAuditEntryConnection'] = ResolversParentTypes['Github_OrganizationAuditEntryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationAuditEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationAuditEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationAuditEntryData'] = ResolversParentTypes['Github_OrganizationAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_MembersCanDeleteReposClearAuditEntry' | 'Github_MembersCanDeleteReposDisableAuditEntry' | 'Github_MembersCanDeleteReposEnableAuditEntry' | 'Github_OauthApplicationCreateAuditEntry' | 'Github_OrgAddBillingManagerAuditEntry' | 'Github_OrgAddMemberAuditEntry' | 'Github_OrgBlockUserAuditEntry' | 'Github_OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_OrgCreateAuditEntry' | 'Github_OrgDisableOauthAppRestrictionsAuditEntry' | 'Github_OrgDisableSamlAuditEntry' | 'Github_OrgDisableTwoFactorRequirementAuditEntry' | 'Github_OrgEnableOauthAppRestrictionsAuditEntry' | 'Github_OrgEnableSamlAuditEntry' | 'Github_OrgEnableTwoFactorRequirementAuditEntry' | 'Github_OrgInviteMemberAuditEntry' | 'Github_OrgInviteToBusinessAuditEntry' | 'Github_OrgOauthAppAccessApprovedAuditEntry' | 'Github_OrgOauthAppAccessDeniedAuditEntry' | 'Github_OrgOauthAppAccessRequestedAuditEntry' | 'Github_OrgRemoveBillingManagerAuditEntry' | 'Github_OrgRemoveMemberAuditEntry' | 'Github_OrgRemoveOutsideCollaboratorAuditEntry' | 'Github_OrgRestoreMemberAuditEntry' | 'Github_OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'Github_OrgUnblockUserAuditEntry' | 'Github_OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'Github_OrgUpdateMemberAuditEntry' | 'Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'Github_PrivateRepositoryForkingDisableAuditEntry' | 'Github_PrivateRepositoryForkingEnableAuditEntry' | 'Github_RepoAccessAuditEntry' | 'Github_RepoAddMemberAuditEntry' | 'Github_RepoAddTopicAuditEntry' | 'Github_RepoArchivedAuditEntry' | 'Github_RepoChangeMergeSettingAuditEntry' | 'Github_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigDisableContributorsOnlyAuditEntry' | 'Github_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigEnableContributorsOnlyAuditEntry' | 'Github_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigLockAnonymousGitAccessAuditEntry' | 'Github_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'Github_RepoCreateAuditEntry' | 'Github_RepoDestroyAuditEntry' | 'Github_RepoRemoveMemberAuditEntry' | 'Github_RepoRemoveTopicAuditEntry' | 'Github_RepositoryVisibilityChangeDisableAuditEntry' | 'Github_RepositoryVisibilityChangeEnableAuditEntry' | 'Github_TeamAddMemberAuditEntry' | 'Github_TeamAddRepositoryAuditEntry' | 'Github_TeamChangeParentTeamAuditEntry' | 'Github_TeamRemoveMemberAuditEntry' | 'Github_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_OrganizationAuditEntryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationAuditEntryEdge'] = ResolversParentTypes['Github_OrganizationAuditEntryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_OrganizationAuditEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationConnection'] = ResolversParentTypes['Github_OrganizationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationEdge'] = ResolversParentTypes['Github_OrganizationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationEnterpriseOwnerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationEnterpriseOwnerConnection'] = ResolversParentTypes['Github_OrganizationEnterpriseOwnerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationEnterpriseOwnerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationEnterpriseOwnerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationEnterpriseOwnerEdge'] = ResolversParentTypes['Github_OrganizationEnterpriseOwnerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  organizationRole?: Resolver<ResolversTypes['Github_RoleInOrganization'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationIdentityProviderResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationIdentityProvider'] = ResolversParentTypes['Github_OrganizationIdentityProvider']> = ResolversObject<{
  digestMethod?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  externalIdentities?: Resolver<ResolversTypes['Github_ExternalIdentityConnection'], ParentType, ContextType, Partial<Github_OrganizationIdentityProviderexternalIdentitiesArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<ResolversTypes['Github_X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationInvitation'] = ResolversParentTypes['Github_OrganizationInvitation']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitationSource?: Resolver<ResolversTypes['Github_OrganizationInvitationSource'], ParentType, ContextType>;
  invitationType?: Resolver<ResolversTypes['Github_OrganizationInvitationType'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  organization?: Resolver<ResolversTypes['Github_Organization'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Github_OrganizationInvitationRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationInvitationConnection'] = ResolversParentTypes['Github_OrganizationInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationInvitationEdge'] = ResolversParentTypes['Github_OrganizationInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationMemberConnection'] = ResolversParentTypes['Github_OrganizationMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_OrganizationMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationMemberEdge'] = ResolversParentTypes['Github_OrganizationMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hasTwoFactorEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Github_OrganizationMemberRole']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationMigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationMigration'] = ResolversParentTypes['Github_OrganizationMigration']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  remainingRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sourceOrgName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceOrgUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_OrganizationMigrationState'], ParentType, ContextType>;
  targetOrgName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalRepositoriesCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationOrUserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationOrUser'] = ResolversParentTypes['Github_OrganizationOrUser']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_OrganizationTeamsHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationTeamsHovercardContext'] = ResolversParentTypes['Github_OrganizationTeamsHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relevantTeams?: Resolver<ResolversTypes['Github_TeamConnection'], ParentType, ContextType, Partial<Github_OrganizationTeamsHovercardContextrelevantTeamsArgs>>;
  teamsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  totalTeamCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_OrganizationsHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_OrganizationsHovercardContext'] = ResolversParentTypes['Github_OrganizationsHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relevantOrganizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_OrganizationsHovercardContextrelevantOrganizationsArgs, 'orderBy'>>;
  totalOrganizationCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Package'] = ResolversParentTypes['Github_Package']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  latestVersion?: Resolver<Maybe<ResolversTypes['Github_PackageVersion']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageType?: Resolver<ResolversTypes['Github_PackageType'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['Github_PackageStatistics']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['Github_PackageVersion']>, ParentType, ContextType, RequireFields<Github_PackageversionArgs, 'version'>>;
  versions?: Resolver<ResolversTypes['Github_PackageVersionConnection'], ParentType, ContextType, RequireFields<Github_PackageversionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageConnection'] = ResolversParentTypes['Github_PackageConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PackageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Package']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageEdge'] = ResolversParentTypes['Github_PackageEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Package']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageFile'] = ResolversParentTypes['Github_PackageFile']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  md5?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  packageVersion?: Resolver<Maybe<ResolversTypes['Github_PackageVersion']>, ParentType, ContextType>;
  sha1?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageFileConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageFileConnection'] = ResolversParentTypes['Github_PackageFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PackageFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PackageFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageFileEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageFileEdge'] = ResolversParentTypes['Github_PackageFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PackageFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageOwner'] = ResolversParentTypes['Github_PackageOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_Repository' | 'Github_User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['Github_PackageConnection'], ParentType, ContextType, RequireFields<Github_PackageOwnerpackagesArgs, 'orderBy'>>;
}>;

export type Github_PackageStatisticsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageStatistics'] = ResolversParentTypes['Github_PackageStatistics']> = ResolversObject<{
  downloadsTotalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageTagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageTag'] = ResolversParentTypes['Github_PackageTag']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['Github_PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageVersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageVersion'] = ResolversParentTypes['Github_PackageVersion']> = ResolversObject<{
  files?: Resolver<ResolversTypes['Github_PackageFileConnection'], ParentType, ContextType, RequireFields<Github_PackageVersionfilesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  package?: Resolver<Maybe<ResolversTypes['Github_Package']>, ParentType, ContextType>;
  platform?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  preRelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes['Github_Release']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<ResolversTypes['Github_PackageVersionStatistics']>, ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageVersionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageVersionConnection'] = ResolversParentTypes['Github_PackageVersionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PackageVersionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PackageVersion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageVersionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageVersionEdge'] = ResolversParentTypes['Github_PackageVersionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PackageVersionStatisticsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PackageVersionStatistics'] = ResolversParentTypes['Github_PackageVersionStatistics']> = ResolversObject<{
  downloadsTotalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PageInfo'] = ResolversParentTypes['Github_PageInfo']> = ResolversObject<{
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PermissionGranterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PermissionGranter'] = ResolversParentTypes['Github_PermissionGranter']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_Repository' | 'Github_Team', ParentType, ContextType>;
}>;

export type Github_PermissionSourceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PermissionSource'] = ResolversParentTypes['Github_PermissionSource']> = ResolversObject<{
  organization?: Resolver<ResolversTypes['Github_Organization'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['Github_DefaultRepositoryPermissionField'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Github_PermissionGranter'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinIssuePayload'] = ResolversParentTypes['Github_PinIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnableItem'] = ResolversParentTypes['Github_PinnableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Gist' | 'Github_Repository', ParentType, ContextType>;
}>;

export type Github_PinnableItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnableItemConnection'] = ResolversParentTypes['Github_PinnableItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PinnableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PinnableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnableItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnableItemEdge'] = ResolversParentTypes['Github_PinnableItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PinnableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedDiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedDiscussion'] = ResolversParentTypes['Github_PinnedDiscussion']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes['Github_Discussion'], ParentType, ContextType>;
  gradientStopColors?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['Github_PinnedDiscussionPattern'], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes['Github_Actor'], ParentType, ContextType>;
  preconfiguredGradient?: Resolver<Maybe<ResolversTypes['Github_PinnedDiscussionGradient']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedDiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedDiscussionConnection'] = ResolversParentTypes['Github_PinnedDiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PinnedDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PinnedDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedDiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedDiscussionEdge'] = ResolversParentTypes['Github_PinnedDiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PinnedDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedEvent'] = ResolversParentTypes['Github_PinnedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Github_Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedIssueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedIssue'] = ResolversParentTypes['Github_PinnedIssue']> = ResolversObject<{
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Github_Issue'], ParentType, ContextType>;
  pinnedBy?: Resolver<ResolversTypes['Github_Actor'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedIssueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedIssueConnection'] = ResolversParentTypes['Github_PinnedIssueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PinnedIssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PinnedIssue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PinnedIssueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PinnedIssueEdge'] = ResolversParentTypes['Github_PinnedIssueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PinnedIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Github_PreciseDateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_PreciseDateTime'], any> {
  name: 'Github_PreciseDateTime';
}

export type Github_PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry'] = ResolversParentTypes['Github_PrivateRepositoryForkingDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry'] = ResolversParentTypes['Github_PrivateRepositoryForkingEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProfileItemShowcaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProfileItemShowcase'] = ResolversParentTypes['Github_ProfileItemShowcase']> = ResolversObject<{
  hasPinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_ProfileItemShowcaseitemsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProfileOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProfileOwner'] = ResolversParentTypes['Github_ProfileOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<Github_ProfileOwneranyPinnableItemsArgs>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  itemShowcase?: Resolver<ResolversTypes['Github_ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pinnableItems?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_ProfileOwnerpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_ProfileOwnerpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_ProjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Project'] = ResolversParentTypes['Github_Project']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  columns?: Resolver<ResolversTypes['Github_ProjectColumnConnection'], ParentType, ContextType, Partial<Github_ProjectcolumnsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Github_ProjectOwner'], ParentType, ContextType>;
  pendingCards?: Resolver<ResolversTypes['Github_ProjectCardConnection'], ParentType, ContextType, RequireFields<Github_ProjectpendingCardsArgs, 'archivedStates'>>;
  progress?: Resolver<ResolversTypes['Github_ProjectProgress'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_ProjectState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectCardResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectCard'] = ResolversParentTypes['Github_ProjectCard']> = ResolversObject<{
  column?: Resolver<Maybe<ResolversTypes['Github_ProjectColumn']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['Github_ProjectCardItem']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_Project'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['Github_ProjectCardState']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectCardConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectCardConnection'] = ResolversParentTypes['Github_ProjectCardConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectCardEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectCard']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectCardEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectCardEdge'] = ResolversParentTypes['Github_ProjectCardEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectCardItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectCardItem'] = ResolversParentTypes['Github_ProjectCardItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_ProjectColumnResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectColumn'] = ResolversParentTypes['Github_ProjectColumn']> = ResolversObject<{
  cards?: Resolver<ResolversTypes['Github_ProjectCardConnection'], ParentType, ContextType, RequireFields<Github_ProjectColumncardsArgs, 'archivedStates'>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_Project'], ParentType, ContextType>;
  purpose?: Resolver<Maybe<ResolversTypes['Github_ProjectColumnPurpose']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectColumnConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectColumnConnection'] = ResolversParentTypes['Github_ProjectColumnConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectColumnEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectColumn']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectColumnEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectColumnEdge'] = ResolversParentTypes['Github_ProjectColumnEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectConnection'] = ResolversParentTypes['Github_ProjectConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Project']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectEdge'] = ResolversParentTypes['Github_ProjectEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectOwner'] = ResolversParentTypes['Github_ProjectOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_Repository' | 'Github_User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType, RequireFields<Github_ProjectOwnerprojectArgs, 'number'>>;
  projects?: Resolver<ResolversTypes['Github_ProjectConnection'], ParentType, ContextType, Partial<Github_ProjectOwnerprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_ProjectProgressResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectProgress'] = ResolversParentTypes['Github_ProjectProgress']> = ResolversObject<{
  doneCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  donePercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  inProgressCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  inProgressPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  todoCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  todoPercentage?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2Resolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2'] = ResolversParentTypes['Github_ProjectV2']> = ResolversObject<{
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConfiguration']>, ParentType, ContextType, RequireFields<Github_ProjectV2fieldArgs, 'name'>>;
  fields?: Resolver<ResolversTypes['Github_ProjectV2FieldConfigurationConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2fieldsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['Github_ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2itemsArgs, 'orderBy'>>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Github_ProjectV2Owner'], ParentType, ContextType>;
  public?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2repositoriesArgs, 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teams?: Resolver<ResolversTypes['Github_TeamConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2teamsArgs, 'orderBy'>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  view?: Resolver<Maybe<ResolversTypes['Github_ProjectV2View']>, ParentType, ContextType, RequireFields<Github_ProjectV2viewArgs, 'number'>>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  views?: Resolver<ResolversTypes['Github_ProjectV2ViewConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2viewsArgs, 'orderBy'>>;
  workflow?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Workflow']>, ParentType, ContextType, RequireFields<Github_ProjectV2workflowArgs, 'number'>>;
  workflows?: Resolver<ResolversTypes['Github_ProjectV2WorkflowConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2workflowsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Connection'] = ResolversParentTypes['Github_ProjectV2Connection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2Edge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2EdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Edge'] = ResolversParentTypes['Github_ProjectV2Edge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Field'] = ResolversParentTypes['Github_ProjectV2Field']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['Github_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldCommonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2FieldCommon'] = ResolversParentTypes['Github_ProjectV2FieldCommon']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_ProjectV2Field' | 'Github_ProjectV2IterationField' | 'Github_ProjectV2SingleSelectField', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['Github_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2FieldConfiguration'] = ResolversParentTypes['Github_ProjectV2FieldConfiguration']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_ProjectV2Field' | 'Github_ProjectV2IterationField' | 'Github_ProjectV2SingleSelectField', ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldConfigurationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2FieldConfigurationConnection'] = ResolversParentTypes['Github_ProjectV2FieldConfigurationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2FieldConfigurationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2FieldConfiguration']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldConfigurationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2FieldConfigurationEdge'] = ResolversParentTypes['Github_ProjectV2FieldConfigurationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConfiguration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2FieldConnection'] = ResolversParentTypes['Github_ProjectV2FieldConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2FieldEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2Field']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2FieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2FieldEdge'] = ResolversParentTypes['Github_ProjectV2FieldEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Field']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Item'] = ResolversParentTypes['Github_ProjectV2Item']> = ResolversObject<{
  content?: Resolver<Maybe<ResolversTypes['Github_ProjectV2ItemContent']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fieldValueByName?: Resolver<Maybe<ResolversTypes['Github_ProjectV2ItemFieldValue']>, ParentType, ContextType, RequireFields<Github_ProjectV2ItemfieldValueByNameArgs, 'name'>>;
  fieldValues?: Resolver<ResolversTypes['Github_ProjectV2ItemFieldValueConnection'], ParentType, ContextType, RequireFields<Github_ProjectV2ItemfieldValuesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['Github_ProjectV2ItemType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemConnection'] = ResolversParentTypes['Github_ProjectV2ItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2ItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2Item']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemContentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemContent'] = ResolversParentTypes['Github_ProjectV2ItemContent']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_DraftIssue' | 'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemEdge'] = ResolversParentTypes['Github_ProjectV2ItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldDateValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldDateValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldDateValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Github_ProjectV2Item'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldIterationValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldIterationValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldIterationValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Github_ProjectV2Item'], ParentType, ContextType>;
  iterationId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldLabelValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldLabelValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldLabelValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['Github_LabelConnection']>, ParentType, ContextType, Partial<Github_ProjectV2ItemFieldLabelValuelabelsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldMilestoneValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldMilestoneValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldMilestoneValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Github_Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldNumberValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldNumberValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldNumberValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Github_ProjectV2Item'], ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldPullRequestValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldPullRequestValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldPullRequestValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  pullRequests?: Resolver<Maybe<ResolversTypes['Github_PullRequestConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ItemFieldPullRequestValuepullRequestsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldRepositoryValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldRepositoryValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldRepositoryValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldReviewerValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldReviewerValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldReviewerValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  reviewers?: Resolver<Maybe<ResolversTypes['Github_RequestedReviewerConnection']>, ParentType, ContextType, Partial<Github_ProjectV2ItemFieldReviewerValuereviewersArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldSingleSelectValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldSingleSelectValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldSingleSelectValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Github_ProjectV2Item'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  optionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldTextValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldTextValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldTextValue']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Github_ProjectV2Item'], ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldUserValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldUserValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldUserValue']> = ResolversObject<{
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  users?: Resolver<Maybe<ResolversTypes['Github_UserConnection']>, ParentType, ContextType, Partial<Github_ProjectV2ItemFieldUserValueusersArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldValueResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldValue'] = ResolversParentTypes['Github_ProjectV2ItemFieldValue']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_ProjectV2ItemFieldDateValue' | 'Github_ProjectV2ItemFieldIterationValue' | 'Github_ProjectV2ItemFieldLabelValue' | 'Github_ProjectV2ItemFieldMilestoneValue' | 'Github_ProjectV2ItemFieldNumberValue' | 'Github_ProjectV2ItemFieldPullRequestValue' | 'Github_ProjectV2ItemFieldRepositoryValue' | 'Github_ProjectV2ItemFieldReviewerValue' | 'Github_ProjectV2ItemFieldSingleSelectValue' | 'Github_ProjectV2ItemFieldTextValue' | 'Github_ProjectV2ItemFieldUserValue', ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldValueCommonResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldValueCommon'] = ResolversParentTypes['Github_ProjectV2ItemFieldValueCommon']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_ProjectV2ItemFieldDateValue' | 'Github_ProjectV2ItemFieldIterationValue' | 'Github_ProjectV2ItemFieldNumberValue' | 'Github_ProjectV2ItemFieldSingleSelectValue' | 'Github_ProjectV2ItemFieldTextValue', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Github_ProjectV2Item'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldValueConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldValueConnection'] = ResolversParentTypes['Github_ProjectV2ItemFieldValueConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2ItemFieldValueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2ItemFieldValue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ItemFieldValueEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ItemFieldValueEdge'] = ResolversParentTypes['Github_ProjectV2ItemFieldValueEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2ItemFieldValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2IterationFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2IterationField'] = ResolversParentTypes['Github_ProjectV2IterationField']> = ResolversObject<{
  configuration?: Resolver<ResolversTypes['Github_ProjectV2IterationFieldConfiguration'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['Github_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2IterationFieldConfigurationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2IterationFieldConfiguration'] = ResolversParentTypes['Github_ProjectV2IterationFieldConfiguration']> = ResolversObject<{
  completedIterations?: Resolver<Array<ResolversTypes['Github_ProjectV2IterationFieldIteration']>, ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  iterations?: Resolver<Array<ResolversTypes['Github_ProjectV2IterationFieldIteration']>, ParentType, ContextType>;
  startDay?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2IterationFieldIterationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2IterationFieldIteration'] = ResolversParentTypes['Github_ProjectV2IterationFieldIteration']> = ResolversObject<{
  duration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2OwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Owner'] = ResolversParentTypes['Github_ProjectV2Owner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_Organization' | 'Github_PullRequest' | 'Github_User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_ProjectV2OwnerprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_ProjectV2OwnerprojectsV2Args, 'orderBy'>>;
}>;

export type Github_ProjectV2RecentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Recent'] = ResolversParentTypes['Github_ProjectV2Recent']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_Repository' | 'Github_User', ParentType, ContextType>;
  recentProjects?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, Partial<Github_ProjectV2RecentrecentProjectsArgs>>;
}>;

export type Github_ProjectV2SingleSelectFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SingleSelectField'] = ResolversParentTypes['Github_ProjectV2SingleSelectField']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['Github_ProjectV2FieldType'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['Github_ProjectV2SingleSelectFieldOption']>, ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SingleSelectFieldOptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SingleSelectFieldOption'] = ResolversParentTypes['Github_ProjectV2SingleSelectFieldOption']> = ResolversObject<{
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameHTML?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SortByResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SortBy'] = ResolversParentTypes['Github_ProjectV2SortBy']> = ResolversObject<{
  direction?: Resolver<ResolversTypes['Github_OrderDirection'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2Field'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SortByConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SortByConnection'] = ResolversParentTypes['Github_ProjectV2SortByConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2SortByEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2SortBy']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SortByEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SortByEdge'] = ResolversParentTypes['Github_ProjectV2SortByEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2SortBy']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SortByFieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SortByField'] = ResolversParentTypes['Github_ProjectV2SortByField']> = ResolversObject<{
  direction?: Resolver<ResolversTypes['Github_OrderDirection'], ParentType, ContextType>;
  field?: Resolver<ResolversTypes['Github_ProjectV2FieldConfiguration'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SortByFieldConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SortByFieldConnection'] = ResolversParentTypes['Github_ProjectV2SortByFieldConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2SortByFieldEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2SortByField']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2SortByFieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2SortByFieldEdge'] = ResolversParentTypes['Github_ProjectV2SortByFieldEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2SortByField']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ViewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2View'] = ResolversParentTypes['Github_ProjectV2View']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fields?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ViewfieldsArgs, 'orderBy'>>;
  filter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groupBy?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ViewgroupByArgs, 'orderBy'>>;
  groupByFields?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ViewgroupByFieldsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  layout?: Resolver<ResolversTypes['Github_ProjectV2ViewLayout'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  sortBy?: Resolver<Maybe<ResolversTypes['Github_ProjectV2SortByConnection']>, ParentType, ContextType, Partial<Github_ProjectV2ViewsortByArgs>>;
  sortByFields?: Resolver<Maybe<ResolversTypes['Github_ProjectV2SortByFieldConnection']>, ParentType, ContextType, Partial<Github_ProjectV2ViewsortByFieldsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verticalGroupBy?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ViewverticalGroupByArgs, 'orderBy'>>;
  verticalGroupByFields?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConfigurationConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ViewverticalGroupByFieldsArgs, 'orderBy'>>;
  visibleFields?: Resolver<Maybe<ResolversTypes['Github_ProjectV2FieldConnection']>, ParentType, ContextType, RequireFields<Github_ProjectV2ViewvisibleFieldsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ViewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ViewConnection'] = ResolversParentTypes['Github_ProjectV2ViewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2ViewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2View']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2ViewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2ViewEdge'] = ResolversParentTypes['Github_ProjectV2ViewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2View']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2WorkflowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2Workflow'] = ResolversParentTypes['Github_ProjectV2Workflow']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<ResolversTypes['Github_ProjectV2'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2WorkflowConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2WorkflowConnection'] = ResolversParentTypes['Github_ProjectV2WorkflowConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2WorkflowEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ProjectV2Workflow']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ProjectV2WorkflowEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ProjectV2WorkflowEdge'] = ResolversParentTypes['Github_ProjectV2WorkflowEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Workflow']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PublicKeyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PublicKey'] = ResolversParentTypes['Github_PublicKey']> = ResolversObject<{
  accessedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  fingerprint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isReadOnly?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PublicKeyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PublicKeyConnection'] = ResolversParentTypes['Github_PublicKeyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PublicKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PublicKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PublicKeyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PublicKeyEdge'] = ResolversParentTypes['Github_PublicKeyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PublicKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PublishSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PublishSponsorsTierPayload'] = ResolversParentTypes['Github_PublishSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequest'] = ResolversParentTypes['Github_PullRequest']> = ResolversObject<{
  activeLockReason?: Resolver<Maybe<ResolversTypes['Github_LockReason']>, ParentType, ContextType>;
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assignees?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_PullRequestassigneesArgs>>;
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  autoMergeRequest?: Resolver<Maybe<ResolversTypes['Github_AutoMergeRequest']>, ParentType, ContextType>;
  baseRef?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  baseRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  baseRefOid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  baseRepository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  canBeRebased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  changedFiles?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checksResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  checksUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  closed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  closingIssuesReferences?: Resolver<Maybe<ResolversTypes['Github_IssueConnection']>, ParentType, ContextType, RequireFields<Github_PullRequestclosingIssuesReferencesArgs, 'userLinkedOnly'>>;
  comments?: Resolver<ResolversTypes['Github_IssueCommentConnection'], ParentType, ContextType, Partial<Github_PullRequestcommentsArgs>>;
  commits?: Resolver<ResolversTypes['Github_PullRequestCommitConnection'], ParentType, ContextType, Partial<Github_PullRequestcommitsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  files?: Resolver<Maybe<ResolversTypes['Github_PullRequestChangedFileConnection']>, ParentType, ContextType, Partial<Github_PullRequestfilesArgs>>;
  headRef?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headRefOid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  headRepository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  headRepositoryOwner?: Resolver<Maybe<ResolversTypes['Github_RepositoryOwner']>, ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['Github_Hovercard'], ParentType, ContextType, RequireFields<Github_PullRequesthovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isReadByViewer?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<ResolversTypes['Github_LabelConnection']>, ParentType, ContextType, RequireFields<Github_PullRequestlabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  latestOpinionatedReviews?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewConnection']>, ParentType, ContextType, RequireFields<Github_PullRequestlatestOpinionatedReviewsArgs, 'writersOnly'>>;
  latestReviews?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewConnection']>, ParentType, ContextType, Partial<Github_PullRequestlatestReviewsArgs>>;
  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  maintainerCanModify?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  mergeStateStatus?: Resolver<ResolversTypes['Github_MergeStateStatus'], ParentType, ContextType>;
  mergeable?: Resolver<ResolversTypes['Github_MergeableState'], ParentType, ContextType>;
  merged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  mergedBy?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Github_Milestone']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_PullRequestparticipantsArgs>>;
  permalink?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  potentialMergeCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  projectCards?: Resolver<ResolversTypes['Github_ProjectCardConnection'], ParentType, ContextType, RequireFields<Github_PullRequestprojectCardsArgs, 'archivedStates'>>;
  projectItems?: Resolver<ResolversTypes['Github_ProjectV2ItemConnection'], ParentType, ContextType, RequireFields<Github_PullRequestprojectItemsArgs, 'includeArchived'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_PullRequestprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_PullRequestprojectsV2Args, 'orderBy'>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_PullRequestreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  revertResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  revertUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewDecision']>, ParentType, ContextType>;
  reviewRequests?: Resolver<Maybe<ResolversTypes['Github_ReviewRequestConnection']>, ParentType, ContextType, Partial<Github_PullRequestreviewRequestsArgs>>;
  reviewThreads?: Resolver<ResolversTypes['Github_PullRequestReviewThreadConnection'], ParentType, ContextType, Partial<Github_PullRequestreviewThreadsArgs>>;
  reviews?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewConnection']>, ParentType, ContextType, Partial<Github_PullRequestreviewsArgs>>;
  state?: Resolver<ResolversTypes['Github_PullRequestState'], ParentType, ContextType>;
  suggestedReviewers?: Resolver<Array<Maybe<ResolversTypes['Github_SuggestedReviewer']>>, ParentType, ContextType>;
  timeline?: Resolver<ResolversTypes['Github_PullRequestTimelineConnection'], ParentType, ContextType, Partial<Github_PullRequesttimelineArgs>>;
  timelineItems?: Resolver<ResolversTypes['Github_PullRequestTimelineItemsConnection'], ParentType, ContextType, Partial<Github_PullRequesttimelineItemsArgs>>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  titleHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  totalCommentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_PullRequestuserContentEditsArgs>>;
  viewerCanApplySuggestion?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDeleteHeadRef?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDisableAutoMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditFiles?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEnableAutoMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMergeAsAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerLatestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  viewerLatestReviewRequest?: Resolver<Maybe<ResolversTypes['Github_ReviewRequest']>, ParentType, ContextType>;
  viewerMergeBodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<Github_PullRequestviewerMergeBodyTextArgs>>;
  viewerMergeHeadlineText?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<Github_PullRequestviewerMergeHeadlineTextArgs>>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestChangedFileResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestChangedFile'] = ResolversParentTypes['Github_PullRequestChangedFile']> = ResolversObject<{
  additions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  changeType?: Resolver<ResolversTypes['Github_PatchStatus'], ParentType, ContextType>;
  deletions?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewerViewedState?: Resolver<ResolversTypes['Github_FileViewedState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestChangedFileConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestChangedFileConnection'] = ResolversParentTypes['Github_PullRequestChangedFileConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestChangedFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestChangedFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestChangedFileEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestChangedFileEdge'] = ResolversParentTypes['Github_PullRequestChangedFileEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestChangedFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestCommitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestCommit'] = ResolversParentTypes['Github_PullRequestCommit']> = ResolversObject<{
  commit?: Resolver<ResolversTypes['Github_Commit'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestCommitCommentThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestCommitCommentThread'] = ResolversParentTypes['Github_PullRequestCommitCommentThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['Github_CommitCommentConnection'], ParentType, ContextType, Partial<Github_PullRequestCommitCommentThreadcommentsArgs>>;
  commit?: Resolver<ResolversTypes['Github_Commit'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestCommitConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestCommitConnection'] = ResolversParentTypes['Github_PullRequestCommitConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestCommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestCommit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestCommitEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestCommitEdge'] = ResolversParentTypes['Github_PullRequestCommitEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestCommit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestConnection'] = ResolversParentTypes['Github_PullRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestContributionsByRepository'] = ResolversParentTypes['Github_PullRequestContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['Github_CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<Github_PullRequestContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestEdge'] = ResolversParentTypes['Github_PullRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReview'] = ResolversParentTypes['Github_PullRequestReview']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  authorCanPushToRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Github_PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<Github_PullRequestReviewcommentsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  onBehalfOf?: Resolver<ResolversTypes['Github_TeamConnection'], ParentType, ContextType, Partial<Github_PullRequestReviewonBehalfOfArgs>>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_PullRequestReviewreactionsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_PullRequestReviewState'], ParentType, ContextType>;
  submittedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_PullRequestReviewuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewComment'] = ResolversParentTypes['Github_PullRequestReviewComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  diffHunk?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  draftedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  originalCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  originalPosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  outdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_PullRequestReviewCommentreactionsArgs>>;
  replyTo?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewComment']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_PullRequestReviewCommentState'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_PullRequestReviewCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewCommentConnection'] = ResolversParentTypes['Github_PullRequestReviewCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestReviewCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestReviewComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewCommentEdge'] = ResolversParentTypes['Github_PullRequestReviewCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewConnection'] = ResolversParentTypes['Github_PullRequestReviewConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewContributionsByRepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewContributionsByRepository'] = ResolversParentTypes['Github_PullRequestReviewContributionsByRepository']> = ResolversObject<{
  contributions?: Resolver<ResolversTypes['Github_CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<Github_PullRequestReviewContributionsByRepositorycontributionsArgs, 'orderBy'>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewEdge'] = ResolversParentTypes['Github_PullRequestReviewEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewThread'] = ResolversParentTypes['Github_PullRequestReviewThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['Github_PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<Github_PullRequestReviewThreadcommentsArgs>>;
  diffSide?: Resolver<ResolversTypes['Github_DiffSide'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalStartLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<ResolversTypes['Github_DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  viewerCanReply?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanResolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewThreadConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewThreadConnection'] = ResolversParentTypes['Github_PullRequestReviewThreadConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestReviewThreadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestReviewThread']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestReviewThreadEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestReviewThreadEdge'] = ResolversParentTypes['Github_PullRequestReviewThreadEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestRevisionMarkerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestRevisionMarker'] = ResolversParentTypes['Github_PullRequestRevisionMarker']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastSeenCommit?: Resolver<ResolversTypes['Github_Commit'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestTemplateResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTemplate'] = ResolversParentTypes['Github_PullRequestTemplate']> = ResolversObject<{
  body?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filename?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestThreadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestThread'] = ResolversParentTypes['Github_PullRequestThread']> = ResolversObject<{
  comments?: Resolver<ResolversTypes['Github_PullRequestReviewCommentConnection'], ParentType, ContextType, Partial<Github_PullRequestThreadcommentsArgs>>;
  diffSide?: Resolver<ResolversTypes['Github_DiffSide'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCollapsed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutdated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isResolved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<ResolversTypes['Github_DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  viewerCanReply?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanResolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestTimelineConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTimelineConnection'] = ResolversParentTypes['Github_PullRequestTimelineConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestTimelineItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTimelineItem'] = ResolversParentTypes['Github_PullRequestTimelineItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_AssignedEvent' | 'Github_BaseRefDeletedEvent' | 'Github_BaseRefForcePushedEvent' | 'Github_ClosedEvent' | 'Github_Commit' | 'Github_CommitCommentThread' | 'Github_CrossReferencedEvent' | 'Github_DemilestonedEvent' | 'Github_DeployedEvent' | 'Github_DeploymentEnvironmentChangedEvent' | 'Github_HeadRefDeletedEvent' | 'Github_HeadRefForcePushedEvent' | 'Github_HeadRefRestoredEvent' | 'Github_IssueComment' | 'Github_LabeledEvent' | 'Github_LockedEvent' | 'Github_MergedEvent' | 'Github_MilestonedEvent' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_PullRequestReviewThread' | 'Github_ReferencedEvent' | 'Github_RenamedTitleEvent' | 'Github_ReopenedEvent' | 'Github_ReviewDismissedEvent' | 'Github_ReviewRequestRemovedEvent' | 'Github_ReviewRequestedEvent' | 'Github_SubscribedEvent' | 'Github_UnassignedEvent' | 'Github_UnlabeledEvent' | 'Github_UnlockedEvent' | 'Github_UnsubscribedEvent' | 'Github_UserBlockedEvent', ParentType, ContextType>;
}>;

export type Github_PullRequestTimelineItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTimelineItemEdge'] = ResolversParentTypes['Github_PullRequestTimelineItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestTimelineItemsResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTimelineItems'] = ResolversParentTypes['Github_PullRequestTimelineItems']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_AddedToProjectEvent' | 'Github_AssignedEvent' | 'Github_AutoMergeDisabledEvent' | 'Github_AutoMergeEnabledEvent' | 'Github_AutoRebaseEnabledEvent' | 'Github_AutoSquashEnabledEvent' | 'Github_AutomaticBaseChangeFailedEvent' | 'Github_AutomaticBaseChangeSucceededEvent' | 'Github_BaseRefChangedEvent' | 'Github_BaseRefDeletedEvent' | 'Github_BaseRefForcePushedEvent' | 'Github_ClosedEvent' | 'Github_CommentDeletedEvent' | 'Github_ConnectedEvent' | 'Github_ConvertToDraftEvent' | 'Github_ConvertedNoteToIssueEvent' | 'Github_ConvertedToDiscussionEvent' | 'Github_CrossReferencedEvent' | 'Github_DemilestonedEvent' | 'Github_DeployedEvent' | 'Github_DeploymentEnvironmentChangedEvent' | 'Github_DisconnectedEvent' | 'Github_HeadRefDeletedEvent' | 'Github_HeadRefForcePushedEvent' | 'Github_HeadRefRestoredEvent' | 'Github_IssueComment' | 'Github_LabeledEvent' | 'Github_LockedEvent' | 'Github_MarkedAsDuplicateEvent' | 'Github_MentionedEvent' | 'Github_MergedEvent' | 'Github_MilestonedEvent' | 'Github_MovedColumnsInProjectEvent' | 'Github_PinnedEvent' | 'Github_PullRequestCommit' | 'Github_PullRequestCommitCommentThread' | 'Github_PullRequestReview' | 'Github_PullRequestReviewThread' | 'Github_PullRequestRevisionMarker' | 'Github_ReadyForReviewEvent' | 'Github_ReferencedEvent' | 'Github_RemovedFromProjectEvent' | 'Github_RenamedTitleEvent' | 'Github_ReopenedEvent' | 'Github_ReviewDismissedEvent' | 'Github_ReviewRequestRemovedEvent' | 'Github_ReviewRequestedEvent' | 'Github_SubscribedEvent' | 'Github_TransferredEvent' | 'Github_UnassignedEvent' | 'Github_UnlabeledEvent' | 'Github_UnlockedEvent' | 'Github_UnmarkedAsDuplicateEvent' | 'Github_UnpinnedEvent' | 'Github_UnsubscribedEvent' | 'Github_UserBlockedEvent', ParentType, ContextType>;
}>;

export type Github_PullRequestTimelineItemsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTimelineItemsConnection'] = ResolversParentTypes['Github_PullRequestTimelineItemsConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PullRequestTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PullRequestTimelineItemsEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PullRequestTimelineItemsEdge'] = ResolversParentTypes['Github_PullRequestTimelineItemsEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PullRequestTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PushResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Push'] = ResolversParentTypes['Github_Push']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  nextSha?: Resolver<Maybe<ResolversTypes['Github_GitObjectID']>, ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  previousSha?: Resolver<Maybe<ResolversTypes['Github_GitObjectID']>, ParentType, ContextType>;
  pusher?: Resolver<ResolversTypes['Github_Actor'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PushAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PushAllowance'] = ResolversParentTypes['Github_PushAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_PushAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PushAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PushAllowanceActor'] = ResolversParentTypes['Github_PushAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_App' | 'Github_Team' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_PushAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PushAllowanceConnection'] = ResolversParentTypes['Github_PushAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_PushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_PushAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_PushAllowanceEdge'] = ResolversParentTypes['Github_PushAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_PushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RateLimitResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RateLimit'] = ResolversParentTypes['Github_RateLimit']> = ResolversObject<{
  cost?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  limit?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  remaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  resetAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  used?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Reactable'] = ResolversParentTypes['Github_Reactable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_Discussion' | 'Github_DiscussionComment' | 'Github_Issue' | 'Github_IssueComment' | 'Github_PullRequest' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_Release' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment', ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_ReactablereactionsArgs>>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_ReactingUserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactingUserConnection'] = ResolversParentTypes['Github_ReactingUserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReactingUserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactingUserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactingUserEdge'] = ResolversParentTypes['Github_ReactingUserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Reaction'] = ResolversParentTypes['Github_Reaction']> = ResolversObject<{
  content?: Resolver<ResolversTypes['Github_ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reactable?: Resolver<ResolversTypes['Github_Reactable'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactionConnection'] = ResolversParentTypes['Github_ReactionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReactionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Reaction']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerHasReacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactionEdge'] = ResolversParentTypes['Github_ReactionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Reaction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactionGroupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactionGroup'] = ResolversParentTypes['Github_ReactionGroup']> = ResolversObject<{
  content?: Resolver<ResolversTypes['Github_ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactors?: Resolver<ResolversTypes['Github_ReactorConnection'], ParentType, ContextType, Partial<Github_ReactionGroupreactorsArgs>>;
  subject?: Resolver<ResolversTypes['Github_Reactable'], ParentType, ContextType>;
  users?: Resolver<ResolversTypes['Github_ReactingUserConnection'], ParentType, ContextType, Partial<Github_ReactionGroupusersArgs>>;
  viewerHasReacted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Reactor'] = ResolversParentTypes['Github_Reactor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Bot' | 'Github_Mannequin' | 'Github_Organization' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_ReactorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactorConnection'] = ResolversParentTypes['Github_ReactorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReactorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Reactor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReactorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReactorEdge'] = ResolversParentTypes['Github_ReactorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_Reactor'], ParentType, ContextType>;
  reactedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReadyForReviewEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReadyForReviewEvent'] = ResolversParentTypes['Github_ReadyForReviewEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RefResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Ref'] = ResolversParentTypes['Github_Ref']> = ResolversObject<{
  associatedPullRequests?: Resolver<ResolversTypes['Github_PullRequestConnection'], ParentType, ContextType, Partial<Github_RefassociatedPullRequestsArgs>>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  compare?: Resolver<Maybe<ResolversTypes['Github_Comparison']>, ParentType, ContextType, RequireFields<Github_RefcompareArgs, 'headRef'>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  prefix?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refUpdateRule?: Resolver<Maybe<ResolversTypes['Github_RefUpdateRule']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['Github_GitObject']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RefConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RefConnection'] = ResolversParentTypes['Github_RefConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RefEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Ref']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RefEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RefEdge'] = ResolversParentTypes['Github_RefEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RefUpdateRuleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RefUpdateRule'] = ResolversParentTypes['Github_RefUpdateRule']> = ResolversObject<{
  allowsDeletions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  allowsForcePushes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  blocksCreations?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresConversationResolution?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresLinearHistory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  requiresSignatures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerAllowedToDismissReviews?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPush?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReferencedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReferencedEvent'] = ResolversParentTypes['Github_ReferencedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  commitRepository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDirectReference?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Github_ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReferencedSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReferencedSubject'] = ResolversParentTypes['Github_ReferencedSubject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload'] = ResolversParentTypes['Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['Github_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RegenerateVerifiableDomainTokenPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RegenerateVerifiableDomainTokenPayload'] = ResolversParentTypes['Github_RegenerateVerifiableDomainTokenPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RejectDeploymentsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RejectDeploymentsPayload'] = ResolversParentTypes['Github_RejectDeploymentsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deployments?: Resolver<Maybe<Array<ResolversTypes['Github_Deployment']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReleaseResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Release'] = ResolversParentTypes['Github_Release']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<ResolversTypes['Github_HTML']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLatest?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrerelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mentions?: Resolver<Maybe<ResolversTypes['Github_UserConnection']>, ParentType, ContextType, Partial<Github_ReleasementionsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_ReleasereactionsArgs>>;
  releaseAssets?: Resolver<ResolversTypes['Github_ReleaseAssetConnection'], ParentType, ContextType, Partial<Github_ReleasereleaseAssetsArgs>>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<Maybe<ResolversTypes['Github_HTML']>, ParentType, ContextType, RequireFields<Github_ReleaseshortDescriptionHTMLArgs, 'limit'>>;
  tag?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  tagCommit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  tagName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReleaseAssetResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReleaseAsset'] = ResolversParentTypes['Github_ReleaseAsset']> = ResolversObject<{
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  downloadCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  downloadUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  release?: Resolver<Maybe<ResolversTypes['Github_Release']>, ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  uploadedBy?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReleaseAssetConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReleaseAssetConnection'] = ResolversParentTypes['Github_ReleaseAssetConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReleaseAssetEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReleaseAsset']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReleaseAssetEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReleaseAssetEdge'] = ResolversParentTypes['Github_ReleaseAssetEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ReleaseAsset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReleaseConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReleaseConnection'] = ResolversParentTypes['Github_ReleaseConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReleaseEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Release']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReleaseEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReleaseEdge'] = ResolversParentTypes['Github_ReleaseEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Release']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveAssigneesFromAssignablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveAssigneesFromAssignablePayload'] = ResolversParentTypes['Github_RemoveAssigneesFromAssignablePayload']> = ResolversObject<{
  assignable?: Resolver<Maybe<ResolversTypes['Github_Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveEnterpriseAdminPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveEnterpriseAdminPayload'] = ResolversParentTypes['Github_RemoveEnterpriseAdminPayload']> = ResolversObject<{
  admin?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveEnterpriseIdentityProviderPayload'] = ResolversParentTypes['Github_RemoveEnterpriseIdentityProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['Github_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveEnterpriseMemberPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveEnterpriseMemberPayload'] = ResolversParentTypes['Github_RemoveEnterpriseMemberPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveEnterpriseOrganizationPayload'] = ResolversParentTypes['Github_RemoveEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveEnterpriseSupportEntitlementPayload'] = ResolversParentTypes['Github_RemoveEnterpriseSupportEntitlementPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveLabelsFromLabelablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveLabelsFromLabelablePayload'] = ResolversParentTypes['Github_RemoveLabelsFromLabelablePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<ResolversTypes['Github_Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveOutsideCollaboratorPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveOutsideCollaboratorPayload'] = ResolversParentTypes['Github_RemoveOutsideCollaboratorPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  removedUser?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveReactionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveReactionPayload'] = ResolversParentTypes['Github_RemoveReactionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<ResolversTypes['Github_Reaction']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Github_Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveStarPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveStarPayload'] = ResolversParentTypes['Github_RemoveStarPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<ResolversTypes['Github_Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemoveUpvotePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemoveUpvotePayload'] = ResolversParentTypes['Github_RemoveUpvotePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Github_Votable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RemovedFromProjectEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RemovedFromProjectEvent'] = ResolversParentTypes['Github_RemovedFromProjectEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  projectColumnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RenamedTitleEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RenamedTitleEvent'] = ResolversParentTypes['Github_RenamedTitleEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currentTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Github_RenamedTitleSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RenamedTitleSubjectResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RenamedTitleSubject'] = ResolversParentTypes['Github_RenamedTitleSubject']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Issue' | 'Github_PullRequest', ParentType, ContextType>;
}>;

export type Github_ReopenIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReopenIssuePayload'] = ResolversParentTypes['Github_ReopenIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReopenPullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReopenPullRequestPayload'] = ResolversParentTypes['Github_ReopenPullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReopenedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReopenedEvent'] = ResolversParentTypes['Github_ReopenedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  closable?: Resolver<ResolversTypes['Github_Closable'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stateReason?: Resolver<Maybe<ResolversTypes['Github_IssueStateReason']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoAccessAuditEntry'] = ResolversParentTypes['Github_RepoAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_RepoAccessAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoAddMemberAuditEntry'] = ResolversParentTypes['Github_RepoAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_RepoAddMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoAddTopicAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoAddTopicAuditEntry'] = ResolversParentTypes['Github_RepoAddTopicAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Github_Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoArchivedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoArchivedAuditEntry'] = ResolversParentTypes['Github_RepoArchivedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_RepoArchivedAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoChangeMergeSettingAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry'] = ResolversParentTypes['Github_RepoChangeMergeSettingAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  mergeType?: Resolver<Maybe<ResolversTypes['Github_RepoChangeMergeSettingAuditEntryMergeType']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry'] = ResolversParentTypes['Github_RepoConfigDisableAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['Github_RepoConfigDisableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry'] = ResolversParentTypes['Github_RepoConfigDisableContributorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry'] = ResolversParentTypes['Github_RepoConfigDisableSockpuppetDisallowedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry'] = ResolversParentTypes['Github_RepoConfigEnableAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry'] = ResolversParentTypes['Github_RepoConfigEnableCollaboratorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry'] = ResolversParentTypes['Github_RepoConfigEnableContributorsOnlyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry'] = ResolversParentTypes['Github_RepoConfigEnableSockpuppetDisallowedAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry'] = ResolversParentTypes['Github_RepoConfigLockAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry'] = ResolversParentTypes['Github_RepoConfigUnlockAnonymousGitAccessAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoCreateAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoCreateAuditEntry'] = ResolversParentTypes['Github_RepoCreateAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  forkParentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  forkSourceName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_RepoCreateAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoDestroyAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoDestroyAuditEntry'] = ResolversParentTypes['Github_RepoDestroyAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_RepoDestroyAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoRemoveMemberAuditEntry'] = ResolversParentTypes['Github_RepoRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<ResolversTypes['Github_RepoRemoveMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepoRemoveTopicAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepoRemoveTopicAuditEntry'] = ResolversParentTypes['Github_RepoRemoveTopicAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Github_Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Repository'] = ResolversParentTypes['Github_Repository']> = ResolversObject<{
  allowUpdateBranch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  assignableUsers?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_RepositoryassignableUsersArgs>>;
  autoMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  branchProtectionRules?: Resolver<ResolversTypes['Github_BranchProtectionRuleConnection'], ParentType, ContextType, Partial<Github_RepositorybranchProtectionRulesArgs>>;
  codeOfConduct?: Resolver<Maybe<ResolversTypes['Github_CodeOfConduct']>, ParentType, ContextType>;
  codeowners?: Resolver<Maybe<ResolversTypes['Github_RepositoryCodeowners']>, ParentType, ContextType, Partial<Github_RepositorycodeownersArgs>>;
  collaborators?: Resolver<Maybe<ResolversTypes['Github_RepositoryCollaboratorConnection']>, ParentType, ContextType, Partial<Github_RepositorycollaboratorsArgs>>;
  commitComments?: Resolver<ResolversTypes['Github_CommitCommentConnection'], ParentType, ContextType, Partial<Github_RepositorycommitCommentsArgs>>;
  contactLinks?: Resolver<Maybe<Array<ResolversTypes['Github_RepositoryContactLink']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  defaultBranchRef?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  deleteBranchOnMerge?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  dependencyGraphManifests?: Resolver<Maybe<ResolversTypes['Github_DependencyGraphManifestConnection']>, ParentType, ContextType, Partial<Github_RepositorydependencyGraphManifestsArgs>>;
  deployKeys?: Resolver<ResolversTypes['Github_DeployKeyConnection'], ParentType, ContextType, Partial<Github_RepositorydeployKeysArgs>>;
  deployments?: Resolver<ResolversTypes['Github_DeploymentConnection'], ParentType, ContextType, RequireFields<Github_RepositorydeploymentsArgs, 'orderBy'>>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType, RequireFields<Github_RepositorydiscussionArgs, 'number'>>;
  discussionCategories?: Resolver<ResolversTypes['Github_DiscussionCategoryConnection'], ParentType, ContextType, RequireFields<Github_RepositorydiscussionCategoriesArgs, 'filterByAssignable'>>;
  discussionCategory?: Resolver<Maybe<ResolversTypes['Github_DiscussionCategory']>, ParentType, ContextType, RequireFields<Github_RepositorydiscussionCategoryArgs, 'slug'>>;
  discussions?: Resolver<ResolversTypes['Github_DiscussionConnection'], ParentType, ContextType, RequireFields<Github_RepositorydiscussionsArgs, 'categoryId' | 'orderBy'>>;
  diskUsage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['Github_Environment']>, ParentType, ContextType, RequireFields<Github_RepositoryenvironmentArgs, 'name'>>;
  environments?: Resolver<ResolversTypes['Github_EnvironmentConnection'], ParentType, ContextType, Partial<Github_RepositoryenvironmentsArgs>>;
  forkCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  forkingAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  forks?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_RepositoryforksArgs, 'ownerAffiliations'>>;
  fundingLinks?: Resolver<Array<ResolversTypes['Github_FundingLink']>, ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasVulnerabilityAlertsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['Github_RepositoryInteractionAbility']>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isBlankIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDisabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isEmpty?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInOrganization?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSecurityPolicyEnabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isUserConfigurationRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType, RequireFields<Github_RepositoryissueArgs, 'number'>>;
  issueOrPullRequest?: Resolver<Maybe<ResolversTypes['Github_IssueOrPullRequest']>, ParentType, ContextType, RequireFields<Github_RepositoryissueOrPullRequestArgs, 'number'>>;
  issueTemplates?: Resolver<Maybe<Array<ResolversTypes['Github_IssueTemplate']>>, ParentType, ContextType>;
  issues?: Resolver<ResolversTypes['Github_IssueConnection'], ParentType, ContextType, Partial<Github_RepositoryissuesArgs>>;
  label?: Resolver<Maybe<ResolversTypes['Github_Label']>, ParentType, ContextType, RequireFields<Github_RepositorylabelArgs, 'name'>>;
  labels?: Resolver<Maybe<ResolversTypes['Github_LabelConnection']>, ParentType, ContextType, RequireFields<Github_RepositorylabelsArgs, 'orderBy'>>;
  languages?: Resolver<Maybe<ResolversTypes['Github_LanguageConnection']>, ParentType, ContextType, Partial<Github_RepositorylanguagesArgs>>;
  latestRelease?: Resolver<Maybe<ResolversTypes['Github_Release']>, ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<ResolversTypes['Github_License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['Github_RepositoryLockReason']>, ParentType, ContextType>;
  mentionableUsers?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_RepositorymentionableUsersArgs>>;
  mergeCommitAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommitMessage?: Resolver<ResolversTypes['Github_MergeCommitMessage'], ParentType, ContextType>;
  mergeCommitTitle?: Resolver<ResolversTypes['Github_MergeCommitTitle'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<ResolversTypes['Github_Milestone']>, ParentType, ContextType, RequireFields<Github_RepositorymilestoneArgs, 'number'>>;
  milestones?: Resolver<Maybe<ResolversTypes['Github_MilestoneConnection']>, ParentType, ContextType, Partial<Github_RepositorymilestonesArgs>>;
  mirrorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  object?: Resolver<Maybe<ResolversTypes['Github_GitObject']>, ParentType, ContextType, Partial<Github_RepositoryobjectArgs>>;
  openGraphImageUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Github_RepositoryOwner'], ParentType, ContextType>;
  packages?: Resolver<ResolversTypes['Github_PackageConnection'], ParentType, ContextType, RequireFields<Github_RepositorypackagesArgs, 'orderBy'>>;
  parent?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  pinnedDiscussions?: Resolver<ResolversTypes['Github_PinnedDiscussionConnection'], ParentType, ContextType, Partial<Github_RepositorypinnedDiscussionsArgs>>;
  pinnedIssues?: Resolver<Maybe<ResolversTypes['Github_PinnedIssueConnection']>, ParentType, ContextType, Partial<Github_RepositorypinnedIssuesArgs>>;
  primaryLanguage?: Resolver<Maybe<ResolversTypes['Github_Language']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType, RequireFields<Github_RepositoryprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_RepositoryprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['Github_ProjectConnection'], ParentType, ContextType, Partial<Github_RepositoryprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_RepositoryprojectsV2Args, 'orderBy'>>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType, RequireFields<Github_RepositorypullRequestArgs, 'number'>>;
  pullRequestTemplates?: Resolver<Maybe<Array<ResolversTypes['Github_PullRequestTemplate']>>, ParentType, ContextType>;
  pullRequests?: Resolver<ResolversTypes['Github_PullRequestConnection'], ParentType, ContextType, Partial<Github_RepositorypullRequestsArgs>>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  rebaseMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  recentProjects?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, Partial<Github_RepositoryrecentProjectsArgs>>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType, RequireFields<Github_RepositoryrefArgs, 'qualifiedName'>>;
  refs?: Resolver<Maybe<ResolversTypes['Github_RefConnection']>, ParentType, ContextType, RequireFields<Github_RepositoryrefsArgs, 'refPrefix'>>;
  release?: Resolver<Maybe<ResolversTypes['Github_Release']>, ParentType, ContextType, RequireFields<Github_RepositoryreleaseArgs, 'tagName'>>;
  releases?: Resolver<ResolversTypes['Github_ReleaseConnection'], ParentType, ContextType, Partial<Github_RepositoryreleasesArgs>>;
  repositoryTopics?: Resolver<ResolversTypes['Github_RepositoryTopicConnection'], ParentType, ContextType, Partial<Github_RepositoryrepositoryTopicsArgs>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  securityPolicyUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType, RequireFields<Github_RepositoryshortDescriptionHTMLArgs, 'limit'>>;
  squashMergeAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  squashMergeCommitMessage?: Resolver<ResolversTypes['Github_SquashMergeCommitMessage'], ParentType, ContextType>;
  squashMergeCommitTitle?: Resolver<ResolversTypes['Github_SquashMergeCommitTitle'], ParentType, ContextType>;
  squashPrTitleUsedAsDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sshUrl?: Resolver<ResolversTypes['Github_GitSSHRemote'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['Github_StargazerConnection'], ParentType, ContextType, Partial<Github_RepositorystargazersArgs>>;
  submodules?: Resolver<ResolversTypes['Github_SubmoduleConnection'], ParentType, ContextType, Partial<Github_RepositorysubmodulesArgs>>;
  tempCloneToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateRepository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdateTopics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerDefaultCommitEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  viewerDefaultMergeMethod?: Resolver<ResolversTypes['Github_PullRequestMergeMethod'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerPermission?: Resolver<Maybe<ResolversTypes['Github_RepositoryPermission']>, ParentType, ContextType>;
  viewerPossibleCommitEmails?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['Github_RepositoryVisibility'], ParentType, ContextType>;
  vulnerabilityAlerts?: Resolver<Maybe<ResolversTypes['Github_RepositoryVulnerabilityAlertConnection']>, ParentType, ContextType, Partial<Github_RepositoryvulnerabilityAlertsArgs>>;
  watchers?: Resolver<ResolversTypes['Github_UserConnection'], ParentType, ContextType, Partial<Github_RepositorywatchersArgs>>;
  webCommitSignoffRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryAuditEntryData'] = ResolversParentTypes['Github_RepositoryAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'Github_PrivateRepositoryForkingDisableAuditEntry' | 'Github_PrivateRepositoryForkingEnableAuditEntry' | 'Github_RepoAccessAuditEntry' | 'Github_RepoAddMemberAuditEntry' | 'Github_RepoAddTopicAuditEntry' | 'Github_RepoArchivedAuditEntry' | 'Github_RepoChangeMergeSettingAuditEntry' | 'Github_RepoConfigDisableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigDisableContributorsOnlyAuditEntry' | 'Github_RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigEnableAnonymousGitAccessAuditEntry' | 'Github_RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'Github_RepoConfigEnableContributorsOnlyAuditEntry' | 'Github_RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'Github_RepoConfigLockAnonymousGitAccessAuditEntry' | 'Github_RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'Github_RepoCreateAuditEntry' | 'Github_RepoDestroyAuditEntry' | 'Github_RepoRemoveMemberAuditEntry' | 'Github_RepoRemoveTopicAuditEntry' | 'Github_TeamAddRepositoryAuditEntry' | 'Github_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_RepositoryCodeownersResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryCodeowners'] = ResolversParentTypes['Github_RepositoryCodeowners']> = ResolversObject<{
  errors?: Resolver<Array<ResolversTypes['Github_RepositoryCodeownersError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryCodeownersErrorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryCodeownersError'] = ResolversParentTypes['Github_RepositoryCodeownersError']> = ResolversObject<{
  column?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  line?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  suggestion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryCollaboratorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryCollaboratorConnection'] = ResolversParentTypes['Github_RepositoryCollaboratorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryCollaboratorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryCollaboratorEdge'] = ResolversParentTypes['Github_RepositoryCollaboratorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['Github_RepositoryPermission'], ParentType, ContextType>;
  permissionSources?: Resolver<Maybe<Array<ResolversTypes['Github_PermissionSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryConnection'] = ResolversParentTypes['Github_RepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalDiskUsage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryContactLinkResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryContactLink'] = ResolversParentTypes['Github_RepositoryContactLink']> = ResolversObject<{
  about?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryDiscussionAuthorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryDiscussionAuthor'] = ResolversParentTypes['Github_RepositoryDiscussionAuthor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
  repositoryDiscussions?: Resolver<ResolversTypes['Github_DiscussionConnection'], ParentType, ContextType, RequireFields<Github_RepositoryDiscussionAuthorrepositoryDiscussionsArgs, 'answered' | 'orderBy'>>;
}>;

export type Github_RepositoryDiscussionCommentAuthorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryDiscussionCommentAuthor'] = ResolversParentTypes['Github_RepositoryDiscussionCommentAuthor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['Github_DiscussionCommentConnection'], ParentType, ContextType, RequireFields<Github_RepositoryDiscussionCommentAuthorrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
}>;

export type Github_RepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryEdge'] = ResolversParentTypes['Github_RepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryInfo'] = ResolversParentTypes['Github_RepositoryInfo']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Repository', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  forkCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasDiscussionsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  isArchived?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInOrganization?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isTemplate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<ResolversTypes['Github_License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<ResolversTypes['Github_RepositoryLockReason']>, ParentType, ContextType>;
  mirrorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  openGraphImageUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Github_RepositoryOwner'], ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType, RequireFields<Github_RepositoryInfoshortDescriptionHTMLArgs, 'limit'>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['Github_RepositoryVisibility'], ParentType, ContextType>;
}>;

export type Github_RepositoryInteractionAbilityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryInteractionAbility'] = ResolversParentTypes['Github_RepositoryInteractionAbility']> = ResolversObject<{
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  limit?: Resolver<ResolversTypes['Github_RepositoryInteractionLimit'], ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['Github_RepositoryInteractionLimitOrigin'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryInvitationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryInvitation'] = ResolversParentTypes['Github_RepositoryInvitation']> = ResolversObject<{
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  inviter?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  permalink?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['Github_RepositoryPermission'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_RepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryInvitationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryInvitationConnection'] = ResolversParentTypes['Github_RepositoryInvitationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryInvitationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryInvitationEdge'] = ResolversParentTypes['Github_RepositoryInvitationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_RepositoryInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryMigrationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryMigration'] = ResolversParentTypes['Github_RepositoryMigration']> = ResolversObject<{
  continueOnError?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  failureReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  migrationLogUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  migrationSource?: Resolver<ResolversTypes['Github_MigrationSource'], ParentType, ContextType>;
  repositoryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourceUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_MigrationState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryMigrationConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryMigrationConnection'] = ResolversParentTypes['Github_RepositoryMigrationConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryMigrationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryMigration']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryMigrationEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryMigrationEdge'] = ResolversParentTypes['Github_RepositoryMigrationEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_RepositoryMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryNodeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryNode'] = ResolversParentTypes['Github_RepositoryNode']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_CommitCommentThread' | 'Github_DependabotUpdate' | 'Github_Discussion' | 'Github_DiscussionCategory' | 'Github_Issue' | 'Github_IssueComment' | 'Github_PinnedDiscussion' | 'Github_PullRequest' | 'Github_PullRequestCommitCommentThread' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_RepositoryVulnerabilityAlert', ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
}>;

export type Github_RepositoryOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryOwner'] = ResolversParentTypes['Github_RepositoryOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_RepositoryOwneravatarUrlArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  repositories?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_RepositoryOwnerrepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType, RequireFields<Github_RepositoryOwnerrepositoryArgs, 'followRenames' | 'name'>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
}>;

export type Github_RepositoryTopicResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryTopic'] = ResolversParentTypes['Github_RepositoryTopic']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  topic?: Resolver<ResolversTypes['Github_Topic'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryTopicConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryTopicConnection'] = ResolversParentTypes['Github_RepositoryTopicConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryTopicEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryTopic']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryTopicEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryTopicEdge'] = ResolversParentTypes['Github_RepositoryTopicEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_RepositoryTopic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry'] = ResolversParentTypes['Github_RepositoryVisibilityChangeDisableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry'] = ResolversParentTypes['Github_RepositoryVisibilityChangeEnableAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryVulnerabilityAlertResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryVulnerabilityAlert'] = ResolversParentTypes['Github_RepositoryVulnerabilityAlert']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dependabotUpdate?: Resolver<Maybe<ResolversTypes['Github_DependabotUpdate']>, ParentType, ContextType>;
  dependencyScope?: Resolver<Maybe<ResolversTypes['Github_RepositoryVulnerabilityAlertDependencyScope']>, ParentType, ContextType>;
  dismissComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  dismisser?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  fixReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fixedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  securityAdvisory?: Resolver<Maybe<ResolversTypes['Github_SecurityAdvisory']>, ParentType, ContextType>;
  securityVulnerability?: Resolver<Maybe<ResolversTypes['Github_SecurityVulnerability']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_RepositoryVulnerabilityAlertState'], ParentType, ContextType>;
  vulnerableManifestFilename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vulnerableManifestPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vulnerableRequirements?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryVulnerabilityAlertConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryVulnerabilityAlertConnection'] = ResolversParentTypes['Github_RepositoryVulnerabilityAlertConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryVulnerabilityAlertEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RepositoryVulnerabilityAlert']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RepositoryVulnerabilityAlertEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RepositoryVulnerabilityAlertEdge'] = ResolversParentTypes['Github_RepositoryVulnerabilityAlertEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RequestReviewsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RequestReviewsPayload'] = ResolversParentTypes['Github_RequestReviewsPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  requestedReviewersEdge?: Resolver<Maybe<ResolversTypes['Github_UserEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RequestedReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RequestedReviewer'] = ResolversParentTypes['Github_RequestedReviewer']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Mannequin' | 'Github_Team' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_RequestedReviewerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RequestedReviewerConnection'] = ResolversParentTypes['Github_RequestedReviewerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RequestedReviewerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_RequestedReviewer']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RequestedReviewerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RequestedReviewerEdge'] = ResolversParentTypes['Github_RequestedReviewerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RequirableByPullRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RequirableByPullRequest'] = ResolversParentTypes['Github_RequirableByPullRequest']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CheckRun' | 'Github_StatusContext', ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<Github_RequirableByPullRequestisRequiredArgs>>;
}>;

export type Github_RequiredStatusCheckDescriptionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RequiredStatusCheckDescription'] = ResolversParentTypes['Github_RequiredStatusCheckDescription']> = ResolversObject<{
  app?: Resolver<Maybe<ResolversTypes['Github_App']>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RerequestCheckSuitePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RerequestCheckSuitePayload'] = ResolversParentTypes['Github_RerequestCheckSuitePayload']> = ResolversObject<{
  checkSuite?: Resolver<Maybe<ResolversTypes['Github_CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ResolveReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ResolveReviewThreadPayload'] = ResolversParentTypes['Github_ResolveReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RestrictedContributionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RestrictedContribution'] = ResolversParentTypes['Github_RestrictedContribution']> = ResolversObject<{
  isRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RetireSponsorsTierPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RetireSponsorsTierPayload'] = ResolversParentTypes['Github_RetireSponsorsTierPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RevertPullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RevertPullRequestPayload'] = ResolversParentTypes['Github_RevertPullRequestPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  revertPullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewDismissalAllowanceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewDismissalAllowance'] = ResolversParentTypes['Github_ReviewDismissalAllowance']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_ReviewDismissalAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewDismissalAllowanceActorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewDismissalAllowanceActor'] = ResolversParentTypes['Github_ReviewDismissalAllowanceActor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_App' | 'Github_Team' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_ReviewDismissalAllowanceConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewDismissalAllowanceConnection'] = ResolversParentTypes['Github_ReviewDismissalAllowanceConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReviewDismissalAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReviewDismissalAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewDismissalAllowanceEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewDismissalAllowanceEdge'] = ResolversParentTypes['Github_ReviewDismissalAllowanceEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ReviewDismissalAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewDismissedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewDismissedEvent'] = ResolversParentTypes['Github_ReviewDismissedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dismissalMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dismissalMessageHTML?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousReviewState?: Resolver<ResolversTypes['Github_PullRequestReviewState'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  pullRequestCommit?: Resolver<Maybe<ResolversTypes['Github_PullRequestCommit']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewRequestResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewRequest'] = ResolversParentTypes['Github_ReviewRequest']> = ResolversObject<{
  asCodeOwner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['Github_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewRequestConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewRequestConnection'] = ResolversParentTypes['Github_ReviewRequestConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReviewRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_ReviewRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewRequestEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewRequestEdge'] = ResolversParentTypes['Github_ReviewRequestEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_ReviewRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewRequestRemovedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewRequestRemovedEvent'] = ResolversParentTypes['Github_ReviewRequestRemovedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['Github_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewRequestedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewRequestedEvent'] = ResolversParentTypes['Github_ReviewRequestedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<ResolversTypes['Github_PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<ResolversTypes['Github_RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ReviewStatusHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ReviewStatusHovercardContext'] = ResolversParentTypes['Github_ReviewStatusHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewDecision']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RevokeEnterpriseOrganizationsMigratorRolePayload'] = ResolversParentTypes['Github_RevokeEnterpriseOrganizationsMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<Maybe<ResolversTypes['Github_OrganizationConnection']>, ParentType, ContextType, Partial<Github_RevokeEnterpriseOrganizationsMigratorRolePayloadorganizationsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_RevokeMigratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_RevokeMigratorRolePayload'] = ResolversParentTypes['Github_RevokeMigratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SavedReplyResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SavedReply'] = ResolversParentTypes['Github_SavedReply']> = ResolversObject<{
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SavedReplyConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SavedReplyConnection'] = ResolversParentTypes['Github_SavedReplyConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SavedReplyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SavedReply']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SavedReplyEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SavedReplyEdge'] = ResolversParentTypes['Github_SavedReplyEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SavedReply']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SearchResultItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SearchResultItem'] = ResolversParentTypes['Github_SearchResultItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_App' | 'Github_Discussion' | 'Github_Issue' | 'Github_MarketplaceListing' | 'Github_Organization' | 'Github_PullRequest' | 'Github_Repository' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_SearchResultItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SearchResultItemConnection'] = ResolversParentTypes['Github_SearchResultItemConnection']> = ResolversObject<{
  codeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  discussionCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SearchResultItemEdge']>>>, ParentType, ContextType>;
  issueCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SearchResultItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  repositoryCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  wikiCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SearchResultItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SearchResultItemEdge'] = ResolversParentTypes['Github_SearchResultItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SearchResultItem']>, ParentType, ContextType>;
  textMatches?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TextMatch']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisory'] = ResolversParentTypes['Github_SecurityAdvisory']> = ResolversObject<{
  classification?: Resolver<ResolversTypes['Github_SecurityAdvisoryClassification'], ParentType, ContextType>;
  cvss?: Resolver<ResolversTypes['Github_CVSS'], ParentType, ContextType>;
  cwes?: Resolver<ResolversTypes['Github_CWEConnection'], ParentType, ContextType, Partial<Github_SecurityAdvisorycwesArgs>>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ghsaId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifiers?: Resolver<Array<ResolversTypes['Github_SecurityAdvisoryIdentifier']>, ParentType, ContextType>;
  notificationsPermalink?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permalink?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  publishedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  references?: Resolver<Array<ResolversTypes['Github_SecurityAdvisoryReference']>, ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['Github_SecurityAdvisorySeverity'], ParentType, ContextType>;
  summary?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerabilities?: Resolver<ResolversTypes['Github_SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<Github_SecurityAdvisoryvulnerabilitiesArgs, 'orderBy'>>;
  withdrawnAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisoryConnection'] = ResolversParentTypes['Github_SecurityAdvisoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SecurityAdvisoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SecurityAdvisory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisoryEdge'] = ResolversParentTypes['Github_SecurityAdvisoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SecurityAdvisory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryIdentifierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisoryIdentifier'] = ResolversParentTypes['Github_SecurityAdvisoryIdentifier']> = ResolversObject<{
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryPackageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisoryPackage'] = ResolversParentTypes['Github_SecurityAdvisoryPackage']> = ResolversObject<{
  ecosystem?: Resolver<ResolversTypes['Github_SecurityAdvisoryEcosystem'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryPackageVersionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisoryPackageVersion'] = ResolversParentTypes['Github_SecurityAdvisoryPackageVersion']> = ResolversObject<{
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityAdvisoryReferenceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityAdvisoryReference'] = ResolversParentTypes['Github_SecurityAdvisoryReference']> = ResolversObject<{
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityVulnerabilityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityVulnerability'] = ResolversParentTypes['Github_SecurityVulnerability']> = ResolversObject<{
  advisory?: Resolver<ResolversTypes['Github_SecurityAdvisory'], ParentType, ContextType>;
  firstPatchedVersion?: Resolver<Maybe<ResolversTypes['Github_SecurityAdvisoryPackageVersion']>, ParentType, ContextType>;
  package?: Resolver<ResolversTypes['Github_SecurityAdvisoryPackage'], ParentType, ContextType>;
  severity?: Resolver<ResolversTypes['Github_SecurityAdvisorySeverity'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerableVersionRange?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityVulnerabilityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityVulnerabilityConnection'] = ResolversParentTypes['Github_SecurityVulnerabilityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SecurityVulnerabilityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SecurityVulnerability']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SecurityVulnerabilityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SecurityVulnerabilityEdge'] = ResolversParentTypes['Github_SecurityVulnerabilityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SecurityVulnerability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SetEnterpriseIdentityProviderPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SetEnterpriseIdentityProviderPayload'] = ResolversParentTypes['Github_SetEnterpriseIdentityProviderPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<ResolversTypes['Github_EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SetOrganizationInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SetOrganizationInteractionLimitPayload'] = ResolversParentTypes['Github_SetOrganizationInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SetRepositoryInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SetRepositoryInteractionLimitPayload'] = ResolversParentTypes['Github_SetRepositoryInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SetUserInteractionLimitPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SetUserInteractionLimitPayload'] = ResolversParentTypes['Github_SetUserInteractionLimitPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SmimeSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SmimeSignature'] = ResolversParentTypes['Github_SmimeSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Sponsor'] = ResolversParentTypes['Github_Sponsor']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_SponsorConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorConnection'] = ResolversParentTypes['Github_SponsorConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Sponsor']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorEdge'] = ResolversParentTypes['Github_SponsorEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Sponsor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Sponsorable'] = ResolversParentTypes['Github_Sponsorable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<Github_SponsorableisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sponsoring?: Resolver<ResolversTypes['Github_SponsorConnection'], ParentType, ContextType, RequireFields<Github_SponsorablesponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['Github_SponsorConnection'], ParentType, ContextType, RequireFields<Github_SponsorablesponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['Github_SponsorsActivityConnection'], ParentType, ContextType, RequireFields<Github_SponsorablesponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['Github_SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType, RequireFields<Github_SponsorablesponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType, RequireFields<Github_SponsorablesponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['Github_SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<Github_SponsorablesponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_SponsorablesponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_SponsorablesponsorshipsAsSponsorArgs, 'activeOnly'>>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Github_SponsorabletotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_SponsorableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorableItem'] = ResolversParentTypes['Github_SponsorableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Organization' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_SponsorableItemConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorableItemConnection'] = ResolversParentTypes['Github_SponsorableItemConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorableItemEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorableItemEdge'] = ResolversParentTypes['Github_SponsorableItemEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SponsorableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsActivityResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsActivity'] = ResolversParentTypes['Github_SponsorsActivity']> = ResolversObject<{
  action?: Resolver<ResolversTypes['Github_SponsorsActivityAction'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  previousSponsorsTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  sponsor?: Resolver<Maybe<ResolversTypes['Github_Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Github_Sponsorable'], ParentType, ContextType>;
  sponsorsTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsActivityConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsActivityConnection'] = ResolversParentTypes['Github_SponsorsActivityConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorsActivityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorsActivity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsActivityEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsActivityEdge'] = ResolversParentTypes['Github_SponsorsActivityEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SponsorsActivity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsGoalResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsGoal'] = ResolversParentTypes['Github_SponsorsGoal']> = ResolversObject<{
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['Github_SponsorsGoalKind'], ParentType, ContextType>;
  percentComplete?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  targetValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsListingResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsListing'] = ResolversParentTypes['Github_SponsorsListing']> = ResolversObject<{
  activeGoal?: Resolver<Maybe<ResolversTypes['Github_SponsorsGoal']>, ParentType, ContextType>;
  activeStripeConnectAccount?: Resolver<Maybe<ResolversTypes['Github_StripeConnectAccount']>, ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contactEmailAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dashboardResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  dashboardUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  featuredItems?: Resolver<Array<ResolversTypes['Github_SponsorsListingFeaturedItem']>, ParentType, ContextType, RequireFields<Github_SponsorsListingfeaturedItemsArgs, 'featureableTypes'>>;
  fiscalHost?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  fullDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublic?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nextPayoutDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  residenceCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  shortDescription?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Github_Sponsorable'], ParentType, ContextType>;
  tiers?: Resolver<Maybe<ResolversTypes['Github_SponsorsTierConnection']>, ParentType, ContextType, RequireFields<Github_SponsorsListingtiersArgs, 'includeUnpublished' | 'orderBy'>>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsListingFeatureableItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsListingFeatureableItem'] = ResolversParentTypes['Github_SponsorsListingFeatureableItem']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Repository' | 'Github_User', ParentType, ContextType>;
}>;

export type Github_SponsorsListingFeaturedItemResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsListingFeaturedItem'] = ResolversParentTypes['Github_SponsorsListingFeaturedItem']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  featureable?: Resolver<ResolversTypes['Github_SponsorsListingFeatureableItem'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['Github_SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsTierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsTier'] = ResolversParentTypes['Github_SponsorsTier']> = ResolversObject<{
  adminInfo?: Resolver<Maybe<ResolversTypes['Github_SponsorsTierAdminInfo']>, ParentType, ContextType>;
  closestLesserValueTier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  descriptionHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCustomAmount?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOneTime?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  monthlyPriceInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  monthlyPriceInDollars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['Github_SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsTierAdminInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsTierAdminInfo'] = ResolversParentTypes['Github_SponsorsTierAdminInfo']> = ResolversObject<{
  isDraft?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRetired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorships?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_SponsorsTierAdminInfosponsorshipsArgs, 'includePrivate'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsTierConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsTierConnection'] = ResolversParentTypes['Github_SponsorsTierConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorsTierEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorsTier']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorsTierEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorsTierEdge'] = ResolversParentTypes['Github_SponsorsTierEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorshipResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Sponsorship'] = ResolversParentTypes['Github_Sponsorship']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOneTimePayment?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsorOptedIntoEmail?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  maintainer?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  privacyLevel?: Resolver<ResolversTypes['Github_SponsorshipPrivacy'], ParentType, ContextType>;
  sponsor?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  sponsorEntity?: Resolver<Maybe<ResolversTypes['Github_Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Github_Sponsorable'], ParentType, ContextType>;
  tier?: Resolver<Maybe<ResolversTypes['Github_SponsorsTier']>, ParentType, ContextType>;
  tierSelectedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorshipConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorshipConnection'] = ResolversParentTypes['Github_SponsorshipConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorshipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Sponsorship']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRecurringMonthlyPriceInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalRecurringMonthlyPriceInDollars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorshipEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorshipEdge'] = ResolversParentTypes['Github_SponsorshipEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorshipNewsletterResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorshipNewsletter'] = ResolversParentTypes['Github_SponsorshipNewsletter']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorable?: Resolver<ResolversTypes['Github_Sponsorable'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorshipNewsletterConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorshipNewsletterConnection'] = ResolversParentTypes['Github_SponsorshipNewsletterConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorshipNewsletterEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SponsorshipNewsletter']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SponsorshipNewsletterEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SponsorshipNewsletterEdge'] = ResolversParentTypes['Github_SponsorshipNewsletterEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_SponsorshipNewsletter']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SshSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SshSignature'] = ResolversParentTypes['Github_SshSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  keyFingerprint?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StargazerConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StargazerConnection'] = ResolversParentTypes['Github_StargazerConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_StargazerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StargazerEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StargazerEdge'] = ResolversParentTypes['Github_StargazerEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StarrableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Starrable'] = ResolversParentTypes['Github_Starrable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Gist' | 'Github_Repository' | 'Github_Topic', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['Github_StargazerConnection'], ParentType, ContextType, Partial<Github_StarrablestargazersArgs>>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_StarredRepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StarredRepositoryConnection'] = ResolversParentTypes['Github_StarredRepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_StarredRepositoryEdge']>>>, ParentType, ContextType>;
  isOverLimit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StarredRepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StarredRepositoryEdge'] = ResolversParentTypes['Github_StarredRepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  starredAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StartOrganizationMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StartOrganizationMigrationPayload'] = ResolversParentTypes['Github_StartOrganizationMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgMigration?: Resolver<Maybe<ResolversTypes['Github_OrganizationMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StartRepositoryMigrationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StartRepositoryMigrationPayload'] = ResolversParentTypes['Github_StartRepositoryMigrationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryMigration?: Resolver<Maybe<ResolversTypes['Github_RepositoryMigration']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Status'] = ResolversParentTypes['Github_Status']> = ResolversObject<{
  combinedContexts?: Resolver<ResolversTypes['Github_StatusCheckRollupContextConnection'], ParentType, ContextType, Partial<Github_StatuscombinedContextsArgs>>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  context?: Resolver<Maybe<ResolversTypes['Github_StatusContext']>, ParentType, ContextType, RequireFields<Github_StatuscontextArgs, 'name'>>;
  contexts?: Resolver<Array<ResolversTypes['Github_StatusContext']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StatusCheckRollupResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StatusCheckRollup'] = ResolversParentTypes['Github_StatusCheckRollup']> = ResolversObject<{
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  contexts?: Resolver<ResolversTypes['Github_StatusCheckRollupContextConnection'], ParentType, ContextType, Partial<Github_StatusCheckRollupcontextsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StatusCheckRollupContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StatusCheckRollupContext'] = ResolversParentTypes['Github_StatusCheckRollupContext']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CheckRun' | 'Github_StatusContext', ParentType, ContextType>;
}>;

export type Github_StatusCheckRollupContextConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StatusCheckRollupContextConnection'] = ResolversParentTypes['Github_StatusCheckRollupContextConnection']> = ResolversObject<{
  checkRunCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  checkRunCountsByState?: Resolver<Maybe<Array<ResolversTypes['Github_CheckRunStateCount']>>, ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_StatusCheckRollupContextEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_StatusCheckRollupContext']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  statusContextCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  statusContextCountsByState?: Resolver<Maybe<Array<ResolversTypes['Github_StatusContextStateCount']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StatusCheckRollupContextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StatusCheckRollupContextEdge'] = ResolversParentTypes['Github_StatusCheckRollupContextEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_StatusCheckRollupContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StatusContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StatusContext'] = ResolversParentTypes['Github_StatusContext']> = ResolversObject<{
  avatarUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType, RequireFields<Github_StatusContextavatarUrlArgs, 'size'>>;
  commit?: Resolver<Maybe<ResolversTypes['Github_Commit']>, ParentType, ContextType>;
  context?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<Github_StatusContextisRequiredArgs>>;
  state?: Resolver<ResolversTypes['Github_StatusState'], ParentType, ContextType>;
  targetUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StatusContextStateCountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StatusContextStateCount'] = ResolversParentTypes['Github_StatusContextStateCount']> = ResolversObject<{
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_StripeConnectAccountResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_StripeConnectAccount'] = ResolversParentTypes['Github_StripeConnectAccount']> = ResolversObject<{
  accountId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  billingCountryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryOrRegion?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sponsorsListing?: Resolver<ResolversTypes['Github_SponsorsListing'], ParentType, ContextType>;
  stripeDashboardUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SubmitPullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SubmitPullRequestReviewPayload'] = ResolversParentTypes['Github_SubmitPullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SubmoduleResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Submodule'] = ResolversParentTypes['Github_Submodule']> = ResolversObject<{
  branch?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gitUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes['Github_Base64String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pathRaw?: Resolver<ResolversTypes['Github_Base64String'], ParentType, ContextType>;
  subprojectCommitOid?: Resolver<Maybe<ResolversTypes['Github_GitObjectID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SubmoduleConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SubmoduleConnection'] = ResolversParentTypes['Github_SubmoduleConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_SubmoduleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Submodule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SubmoduleEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SubmoduleEdge'] = ResolversParentTypes['Github_SubmoduleEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Submodule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SubscribableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Subscribable'] = ResolversParentTypes['Github_Subscribable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Commit' | 'Github_Discussion' | 'Github_Issue' | 'Github_PullRequest' | 'Github_Repository' | 'Github_Team' | 'Github_TeamDiscussion', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
}>;

export type Github_SubscribedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SubscribedEvent'] = ResolversParentTypes['Github_SubscribedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<ResolversTypes['Github_Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_SuggestedReviewerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_SuggestedReviewer'] = ResolversParentTypes['Github_SuggestedReviewer']> = ResolversObject<{
  isAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCommenter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewer?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TagResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Tag'] = ResolversParentTypes['Github_Tag']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  tagger?: Resolver<Maybe<ResolversTypes['Github_GitActor']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['Github_GitObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Team'] = ResolversParentTypes['Github_Team']> = ResolversObject<{
  ancestors?: Resolver<ResolversTypes['Github_TeamConnection'], ParentType, ContextType, Partial<Github_TeamancestorsArgs>>;
  avatarUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType, RequireFields<Github_TeamavatarUrlArgs, 'size'>>;
  childTeams?: Resolver<ResolversTypes['Github_TeamConnection'], ParentType, ContextType, RequireFields<Github_TeamchildTeamsArgs, 'immediateOnly'>>;
  combinedSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussion']>, ParentType, ContextType, RequireFields<Github_TeamdiscussionArgs, 'number'>>;
  discussions?: Resolver<ResolversTypes['Github_TeamDiscussionConnection'], ParentType, ContextType, Partial<Github_TeamdiscussionsArgs>>;
  discussionsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  discussionsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  editTeamResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  editTeamUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invitations?: Resolver<Maybe<ResolversTypes['Github_OrganizationInvitationConnection']>, ParentType, ContextType, Partial<Github_TeaminvitationsArgs>>;
  memberStatuses?: Resolver<ResolversTypes['Github_UserStatusConnection'], ParentType, ContextType, RequireFields<Github_TeammemberStatusesArgs, 'orderBy'>>;
  members?: Resolver<ResolversTypes['Github_TeamMemberConnection'], ParentType, ContextType, RequireFields<Github_TeammembersArgs, 'membership'>>;
  membersResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  membersUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  newTeamResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  organization?: Resolver<ResolversTypes['Github_Organization'], ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  privacy?: Resolver<ResolversTypes['Github_TeamPrivacy'], ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_TeamprojectV2Args, 'number'>>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_TeamprojectsV2Args, 'filterBy' | 'orderBy' | 'query'>>;
  repositories?: Resolver<ResolversTypes['Github_TeamRepositoryConnection'], ParentType, ContextType, Partial<Github_TeamrepositoriesArgs>>;
  repositoriesResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  repositoriesUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  reviewRequestDelegationAlgorithm?: Resolver<Maybe<ResolversTypes['Github_TeamReviewAssignmentAlgorithm']>, ParentType, ContextType>;
  reviewRequestDelegationEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewRequestDelegationMemberCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewRequestDelegationNotifyTeam?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  teamsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamAddMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamAddMemberAuditEntry'] = ResolversParentTypes['Github_TeamAddMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamAddRepositoryAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamAddRepositoryAuditEntry'] = ResolversParentTypes['Github_TeamAddRepositoryAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamAuditEntryData'] = ResolversParentTypes['Github_TeamAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_OrgRestoreMemberMembershipTeamAuditEntryData' | 'Github_TeamAddMemberAuditEntry' | 'Github_TeamAddRepositoryAuditEntry' | 'Github_TeamChangeParentTeamAuditEntry' | 'Github_TeamRemoveMemberAuditEntry' | 'Github_TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
}>;

export type Github_TeamChangeParentTeamAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry'] = ResolversParentTypes['Github_TeamChangeParentTeamAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  parentTeamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTeamNameWas?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentTeamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  parentTeamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  parentTeamWas?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  parentTeamWasResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  parentTeamWasUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamConnection'] = ResolversParentTypes['Github_TeamConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Team']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamDiscussionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamDiscussion'] = ResolversParentTypes['Github_TeamDiscussion']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['Github_TeamDiscussionCommentConnection'], ParentType, ContextType, Partial<Github_TeamDiscussioncommentsArgs>>;
  commentsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  commentsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_TeamDiscussionreactionsArgs>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  team?: Resolver<ResolversTypes['Github_Team'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_TeamDiscussionuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<ResolversTypes['Github_SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamDiscussionCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamDiscussionComment'] = ResolversParentTypes['Github_TeamDiscussionComment']> = ResolversObject<{
  author?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<ResolversTypes['Github_CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  bodyText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<ResolversTypes['Github_TeamDiscussion'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<ResolversTypes['Github_ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<ResolversTypes['Github_ReactionConnection'], ParentType, ContextType, Partial<Github_TeamDiscussionCommentreactionsArgs>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<ResolversTypes['Github_UserContentEditConnection']>, ParentType, ContextType, Partial<Github_TeamDiscussionCommentuserContentEditsArgs>>;
  viewerCanDelete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamDiscussionCommentConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamDiscussionCommentConnection'] = ResolversParentTypes['Github_TeamDiscussionCommentConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamDiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamDiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamDiscussionCommentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamDiscussionCommentEdge'] = ResolversParentTypes['Github_TeamDiscussionCommentEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamDiscussionConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamDiscussionConnection'] = ResolversParentTypes['Github_TeamDiscussionConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamDiscussionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamDiscussionEdge'] = ResolversParentTypes['Github_TeamDiscussionEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamEdge'] = ResolversParentTypes['Github_TeamEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamMemberConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamMemberConnection'] = ResolversParentTypes['Github_TeamMemberConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamMemberEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamMemberEdge'] = ResolversParentTypes['Github_TeamMemberEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  memberAccessResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  memberAccessUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Github_TeamMemberRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamRemoveMemberAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamRemoveMemberAuditEntry'] = ResolversParentTypes['Github_TeamRemoveMemberAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamRemoveRepositoryAuditEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry'] = ResolversParentTypes['Github_TeamRemoveRepositoryAuditEntry']> = ResolversObject<{
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<ResolversTypes['Github_AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<ResolversTypes['Github_ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Github_PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<ResolversTypes['Github_OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamRepositoryConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamRepositoryConnection'] = ResolversParentTypes['Github_TeamRepositoryConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_TeamRepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TeamRepositoryEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TeamRepositoryEdge'] = ResolversParentTypes['Github_TeamRepositoryEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  permission?: Resolver<ResolversTypes['Github_RepositoryPermission'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TextMatchResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TextMatch'] = ResolversParentTypes['Github_TextMatch']> = ResolversObject<{
  fragment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  highlights?: Resolver<Array<ResolversTypes['Github_TextMatchHighlight']>, ParentType, ContextType>;
  property?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TextMatchHighlightResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TextMatchHighlight'] = ResolversParentTypes['Github_TextMatchHighlight']> = ResolversObject<{
  beginIndice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  endIndice?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TopicResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Topic'] = ResolversParentTypes['Github_Topic']> = ResolversObject<{
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  relatedTopics?: Resolver<Array<ResolversTypes['Github_Topic']>, ParentType, ContextType, RequireFields<Github_TopicrelatedTopicsArgs, 'first'>>;
  repositories?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_TopicrepositoriesArgs, 'ownerAffiliations' | 'sponsorableOnly'>>;
  stargazerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stargazers?: Resolver<ResolversTypes['Github_StargazerConnection'], ParentType, ContextType, Partial<Github_TopicstargazersArgs>>;
  viewerHasStarred?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TopicAuditEntryDataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TopicAuditEntryData'] = ResolversParentTypes['Github_TopicAuditEntryData']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_RepoAddTopicAuditEntry' | 'Github_RepoRemoveTopicAuditEntry', ParentType, ContextType>;
  topic?: Resolver<Maybe<ResolversTypes['Github_Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
}>;

export type Github_TransferEnterpriseOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TransferEnterpriseOrganizationPayload'] = ResolversParentTypes['Github_TransferEnterpriseOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TransferIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TransferIssuePayload'] = ResolversParentTypes['Github_TransferIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TransferredEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TransferredEvent'] = ResolversParentTypes['Github_TransferredEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fromRepository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Github_Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TreeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Tree'] = ResolversParentTypes['Github_Tree']> = ResolversObject<{
  abbreviatedOid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  commitUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<ResolversTypes['Github_TreeEntry']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_TreeEntryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_TreeEntry'] = ResolversParentTypes['Github_TreeEntry']> = ResolversObject<{
  extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isGenerated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['Github_Language']>, ParentType, ContextType>;
  lineCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  mode?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nameRaw?: Resolver<ResolversTypes['Github_Base64String'], ParentType, ContextType>;
  object?: Resolver<Maybe<ResolversTypes['Github_GitObject']>, ParentType, ContextType>;
  oid?: Resolver<ResolversTypes['Github_GitObjectID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pathRaw?: Resolver<Maybe<ResolversTypes['Github_Base64String']>, ParentType, ContextType>;
  repository?: Resolver<ResolversTypes['Github_Repository'], ParentType, ContextType>;
  size?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  submodule?: Resolver<Maybe<ResolversTypes['Github_Submodule']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Github_URIScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_URI'], any> {
  name: 'Github_URI';
}

export type Github_UnarchiveProjectV2ItemPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnarchiveProjectV2ItemPayload'] = ResolversParentTypes['Github_UnarchiveProjectV2ItemPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnarchiveRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnarchiveRepositoryPayload'] = ResolversParentTypes['Github_UnarchiveRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnassignedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnassignedEvent'] = ResolversParentTypes['Github_UnassignedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  assignable?: Resolver<ResolversTypes['Github_Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<ResolversTypes['Github_Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnfollowOrganizationPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnfollowOrganizationPayload'] = ResolversParentTypes['Github_UnfollowOrganizationPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnfollowUserPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnfollowUserPayload'] = ResolversParentTypes['Github_UnfollowUserPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UniformResourceLocatableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UniformResourceLocatable'] = ResolversParentTypes['Github_UniformResourceLocatable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Bot' | 'Github_CheckRun' | 'Github_ClosedEvent' | 'Github_Commit' | 'Github_ConvertToDraftEvent' | 'Github_CrossReferencedEvent' | 'Github_Gist' | 'Github_Issue' | 'Github_Mannequin' | 'Github_MergedEvent' | 'Github_Milestone' | 'Github_Organization' | 'Github_PullRequest' | 'Github_PullRequestCommit' | 'Github_ReadyForReviewEvent' | 'Github_Release' | 'Github_Repository' | 'Github_RepositoryTopic' | 'Github_ReviewDismissedEvent' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment' | 'Github_User' | 'Github_WorkflowRun', ParentType, ContextType>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
}>;

export type Github_UnknownSignatureResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnknownSignature'] = ResolversParentTypes['Github_UnknownSignature']> = ResolversObject<{
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Github_GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnlabeledEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnlabeledEvent'] = ResolversParentTypes['Github_UnlabeledEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['Github_Label'], ParentType, ContextType>;
  labelable?: Resolver<ResolversTypes['Github_Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnlinkProjectV2FromRepositoryPayload'] = ResolversParentTypes['Github_UnlinkProjectV2FromRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnlinkProjectV2FromTeamPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnlinkProjectV2FromTeamPayload'] = ResolversParentTypes['Github_UnlinkProjectV2FromTeamPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnlinkRepositoryFromProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnlinkRepositoryFromProjectPayload'] = ResolversParentTypes['Github_UnlinkRepositoryFromProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnlockLockablePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnlockLockablePayload'] = ResolversParentTypes['Github_UnlockLockablePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unlockedRecord?: Resolver<Maybe<ResolversTypes['Github_Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnlockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnlockedEvent'] = ResolversParentTypes['Github_UnlockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lockable?: Resolver<ResolversTypes['Github_Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnmarkDiscussionCommentAsAnswerPayload'] = ResolversParentTypes['Github_UnmarkDiscussionCommentAsAnswerPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnmarkFileAsViewedPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnmarkFileAsViewedPayload'] = ResolversParentTypes['Github_UnmarkFileAsViewedPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnmarkIssueAsDuplicatePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnmarkIssueAsDuplicatePayload'] = ResolversParentTypes['Github_UnmarkIssueAsDuplicatePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['Github_IssueOrPullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnmarkedAsDuplicateEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnmarkedAsDuplicateEvent'] = ResolversParentTypes['Github_UnmarkedAsDuplicateEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  canonical?: Resolver<Maybe<ResolversTypes['Github_IssueOrPullRequest']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duplicate?: Resolver<Maybe<ResolversTypes['Github_IssueOrPullRequest']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnminimizeCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnminimizeCommentPayload'] = ResolversParentTypes['Github_UnminimizeCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unminimizedComment?: Resolver<Maybe<ResolversTypes['Github_Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnpinIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnpinIssuePayload'] = ResolversParentTypes['Github_UnpinIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnpinnedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnpinnedEvent'] = ResolversParentTypes['Github_UnpinnedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<ResolversTypes['Github_Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnresolveReviewThreadPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnresolveReviewThreadPayload'] = ResolversParentTypes['Github_UnresolveReviewThreadPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UnsubscribedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UnsubscribedEvent'] = ResolversParentTypes['Github_UnsubscribedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<ResolversTypes['Github_Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdatableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Updatable'] = ResolversParentTypes['Github_Updatable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_Discussion' | 'Github_DiscussionComment' | 'Github_GistComment' | 'Github_Issue' | 'Github_IssueComment' | 'Github_Project' | 'Github_ProjectV2' | 'Github_PullRequest' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment', ParentType, ContextType>;
  viewerCanUpdate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_UpdatableCommentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdatableComment'] = ResolversParentTypes['Github_UpdatableComment']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_CommitComment' | 'Github_DiscussionComment' | 'Github_GistComment' | 'Github_Issue' | 'Github_IssueComment' | 'Github_PullRequest' | 'Github_PullRequestReview' | 'Github_PullRequestReviewComment' | 'Github_TeamDiscussion' | 'Github_TeamDiscussionComment', ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<ResolversTypes['Github_CommentCannotUpdateReason']>, ParentType, ContextType>;
}>;

export type Github_UpdateBranchProtectionRulePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateBranchProtectionRulePayload'] = ResolversParentTypes['Github_UpdateBranchProtectionRulePayload']> = ResolversObject<{
  branchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateCheckRunPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateCheckRunPayload'] = ResolversParentTypes['Github_UpdateCheckRunPayload']> = ResolversObject<{
  checkRun?: Resolver<Maybe<ResolversTypes['Github_CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateCheckSuitePreferencesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateCheckSuitePreferencesPayload'] = ResolversParentTypes['Github_UpdateCheckSuitePreferencesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateDiscussionCommentPayload'] = ResolversParentTypes['Github_UpdateDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['Github_DiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateDiscussionPayload'] = ResolversParentTypes['Github_UpdateDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<ResolversTypes['Github_Discussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseAdministratorRolePayload'] = ResolversParentTypes['Github_UpdateEnterpriseAdministratorRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseOrganizationProjectsSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseOrganizationProjectsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseOwnerOrganizationRolePayload'] = ResolversParentTypes['Github_UpdateEnterpriseOwnerOrganizationRolePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseProfilePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseProfilePayload'] = ResolversParentTypes['Github_UpdateEnterpriseProfilePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseRepositoryProjectsSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseRepositoryProjectsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseTeamDiscussionsSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseTeamDiscussionsSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload'] = ResolversParentTypes['Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateEnvironmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateEnvironmentPayload'] = ResolversParentTypes['Github_UpdateEnvironmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<ResolversTypes['Github_Environment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateIpAllowListEnabledSettingPayload'] = ResolversParentTypes['Github_UpdateIpAllowListEnabledSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateIpAllowListEntryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateIpAllowListEntryPayload'] = ResolversParentTypes['Github_UpdateIpAllowListEntryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<ResolversTypes['Github_IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload'] = ResolversParentTypes['Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateIssueCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateIssueCommentPayload'] = ResolversParentTypes['Github_UpdateIssueCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issueComment?: Resolver<Maybe<ResolversTypes['Github_IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateIssuePayload'] = ResolversParentTypes['Github_UpdateIssuePayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<ResolversTypes['Github_Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateLabelPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateLabelPayload'] = ResolversParentTypes['Github_UpdateLabelPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['Github_Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateNotificationRestrictionSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateNotificationRestrictionSettingPayload'] = ResolversParentTypes['Github_UpdateNotificationRestrictionSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomainOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload'] = ResolversParentTypes['Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateOrganizationWebCommitSignoffSettingPayload'] = ResolversParentTypes['Github_UpdateOrganizationWebCommitSignoffSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectCardPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectCardPayload'] = ResolversParentTypes['Github_UpdateProjectCardPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<ResolversTypes['Github_ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectColumnPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectColumnPayload'] = ResolversParentTypes['Github_UpdateProjectColumnPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<ResolversTypes['Github_ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectPayload'] = ResolversParentTypes['Github_UpdateProjectPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectV2DraftIssuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectV2DraftIssuePayload'] = ResolversParentTypes['Github_UpdateProjectV2DraftIssuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  draftIssue?: Resolver<Maybe<ResolversTypes['Github_DraftIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectV2ItemFieldValuePayload'] = ResolversParentTypes['Github_UpdateProjectV2ItemFieldValuePayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2Item?: Resolver<Maybe<ResolversTypes['Github_ProjectV2Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectV2ItemPositionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectV2ItemPositionPayload'] = ResolversParentTypes['Github_UpdateProjectV2ItemPositionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  items?: Resolver<Maybe<ResolversTypes['Github_ProjectV2ItemConnection']>, ParentType, ContextType, Partial<Github_UpdateProjectV2ItemPositionPayloaditemsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateProjectV2PayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateProjectV2Payload'] = ResolversParentTypes['Github_UpdateProjectV2Payload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdatePullRequestBranchPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdatePullRequestBranchPayload'] = ResolversParentTypes['Github_UpdatePullRequestBranchPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdatePullRequestPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdatePullRequestPayload'] = ResolversParentTypes['Github_UpdatePullRequestPayload']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<ResolversTypes['Github_PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdatePullRequestReviewCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdatePullRequestReviewCommentPayload'] = ResolversParentTypes['Github_UpdatePullRequestReviewCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<ResolversTypes['Github_PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdatePullRequestReviewPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdatePullRequestReviewPayload'] = ResolversParentTypes['Github_UpdatePullRequestReviewPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<ResolversTypes['Github_PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateRefPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateRefPayload'] = ResolversParentTypes['Github_UpdateRefPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<ResolversTypes['Github_Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateRefsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateRefsPayload'] = ResolversParentTypes['Github_UpdateRefsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateRepositoryPayload'] = ResolversParentTypes['Github_UpdateRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateRepositoryWebCommitSignoffSettingPayload'] = ResolversParentTypes['Github_UpdateRepositoryWebCommitSignoffSettingPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateSponsorshipPreferencesPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateSponsorshipPreferencesPayload'] = ResolversParentTypes['Github_UpdateSponsorshipPreferencesPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorship?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateSubscriptionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateSubscriptionPayload'] = ResolversParentTypes['Github_UpdateSubscriptionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subscribable?: Resolver<Maybe<ResolversTypes['Github_Subscribable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateTeamDiscussionCommentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateTeamDiscussionCommentPayload'] = ResolversParentTypes['Github_UpdateTeamDiscussionCommentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateTeamDiscussionPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateTeamDiscussionPayload'] = ResolversParentTypes['Github_UpdateTeamDiscussionPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<ResolversTypes['Github_TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateTeamReviewAssignmentPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateTeamReviewAssignmentPayload'] = ResolversParentTypes['Github_UpdateTeamReviewAssignmentPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<ResolversTypes['Github_Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateTeamsRepositoryPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateTeamsRepositoryPayload'] = ResolversParentTypes['Github_UpdateTeamsRepositoryPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  teams?: Resolver<Maybe<Array<ResolversTypes['Github_Team']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UpdateTopicsPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UpdateTopicsPayload'] = ResolversParentTypes['Github_UpdateTopicsPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invalidTopicNames?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_User'] = ResolversParentTypes['Github_User']> = ResolversObject<{
  anyPinnableItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, Partial<Github_UseranyPinnableItemsArgs>>;
  avatarUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType, Partial<Github_UseravatarUrlArgs>>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bioHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  canReceiveOrganizationEmailsWhenNotificationsRestricted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<Github_UsercanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs, 'login'>>;
  commitComments?: Resolver<ResolversTypes['Github_CommitCommentConnection'], ParentType, ContextType, Partial<Github_UsercommitCommentsArgs>>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyHTML?: Resolver<ResolversTypes['Github_HTML'], ParentType, ContextType>;
  contributionsCollection?: Resolver<ResolversTypes['Github_ContributionsCollection'], ParentType, ContextType, Partial<Github_UsercontributionsCollectionArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  estimatedNextSponsorsPayoutInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followers?: Resolver<ResolversTypes['Github_FollowerConnection'], ParentType, ContextType, Partial<Github_UserfollowersArgs>>;
  following?: Resolver<ResolversTypes['Github_FollowingConnection'], ParentType, ContextType, Partial<Github_UserfollowingArgs>>;
  gist?: Resolver<Maybe<ResolversTypes['Github_Gist']>, ParentType, ContextType, RequireFields<Github_UsergistArgs, 'name'>>;
  gistComments?: Resolver<ResolversTypes['Github_GistCommentConnection'], ParentType, ContextType, Partial<Github_UsergistCommentsArgs>>;
  gists?: Resolver<ResolversTypes['Github_GistConnection'], ParentType, ContextType, Partial<Github_UsergistsArgs>>;
  hasSponsorsListing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hovercard?: Resolver<ResolversTypes['Github_Hovercard'], ParentType, ContextType, Partial<Github_UserhovercardArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interactionAbility?: Resolver<Maybe<ResolversTypes['Github_RepositoryInteractionAbility']>, ParentType, ContextType>;
  isBountyHunter?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isCampusExpert?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isDeveloperProgramMember?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isEmployee?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isFollowingViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isGitHubStar?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isHireable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSponsoredBy?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType, RequireFields<Github_UserisSponsoredByArgs, 'accountLogin'>>;
  isSponsoringViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isViewer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueComments?: Resolver<ResolversTypes['Github_IssueCommentConnection'], ParentType, ContextType, Partial<Github_UserissueCommentsArgs>>;
  issues?: Resolver<ResolversTypes['Github_IssueConnection'], ParentType, ContextType, Partial<Github_UserissuesArgs>>;
  itemShowcase?: Resolver<ResolversTypes['Github_ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  monthlyEstimatedSponsorsIncomeInCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType, RequireFields<Github_UserorganizationArgs, 'login'>>;
  organizationVerifiedDomainEmails?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Github_UserorganizationVerifiedDomainEmailsArgs, 'login'>>;
  organizations?: Resolver<ResolversTypes['Github_OrganizationConnection'], ParentType, ContextType, RequireFields<Github_UserorganizationsArgs, 'orderBy'>>;
  packages?: Resolver<ResolversTypes['Github_PackageConnection'], ParentType, ContextType, RequireFields<Github_UserpackagesArgs, 'orderBy'>>;
  pinnableItems?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_UserpinnableItemsArgs>>;
  pinnedItems?: Resolver<ResolversTypes['Github_PinnableItemConnection'], ParentType, ContextType, Partial<Github_UserpinnedItemsArgs>>;
  pinnedItemsRemaining?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<ResolversTypes['Github_Project']>, ParentType, ContextType, RequireFields<Github_UserprojectArgs, 'number'>>;
  projectV2?: Resolver<Maybe<ResolversTypes['Github_ProjectV2']>, ParentType, ContextType, RequireFields<Github_UserprojectV2Args, 'number'>>;
  projects?: Resolver<ResolversTypes['Github_ProjectConnection'], ParentType, ContextType, Partial<Github_UserprojectsArgs>>;
  projectsResourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  projectsV2?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, RequireFields<Github_UserprojectsV2Args, 'orderBy'>>;
  publicKeys?: Resolver<ResolversTypes['Github_PublicKeyConnection'], ParentType, ContextType, Partial<Github_UserpublicKeysArgs>>;
  pullRequests?: Resolver<ResolversTypes['Github_PullRequestConnection'], ParentType, ContextType, Partial<Github_UserpullRequestsArgs>>;
  recentProjects?: Resolver<ResolversTypes['Github_ProjectV2Connection'], ParentType, ContextType, Partial<Github_UserrecentProjectsArgs>>;
  repositories?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_UserrepositoriesArgs, 'ownerAffiliations'>>;
  repositoriesContributedTo?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, Partial<Github_UserrepositoriesContributedToArgs>>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType, RequireFields<Github_UserrepositoryArgs, 'followRenames' | 'name'>>;
  repositoryDiscussionComments?: Resolver<ResolversTypes['Github_DiscussionCommentConnection'], ParentType, ContextType, RequireFields<Github_UserrepositoryDiscussionCommentsArgs, 'onlyAnswers'>>;
  repositoryDiscussions?: Resolver<ResolversTypes['Github_DiscussionConnection'], ParentType, ContextType, RequireFields<Github_UserrepositoryDiscussionsArgs, 'answered' | 'orderBy'>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  savedReplies?: Resolver<Maybe<ResolversTypes['Github_SavedReplyConnection']>, ParentType, ContextType, RequireFields<Github_UsersavedRepliesArgs, 'orderBy'>>;
  sponsoring?: Resolver<ResolversTypes['Github_SponsorConnection'], ParentType, ContextType, RequireFields<Github_UsersponsoringArgs, 'orderBy'>>;
  sponsors?: Resolver<ResolversTypes['Github_SponsorConnection'], ParentType, ContextType, RequireFields<Github_UsersponsorsArgs, 'orderBy'>>;
  sponsorsActivities?: Resolver<ResolversTypes['Github_SponsorsActivityConnection'], ParentType, ContextType, RequireFields<Github_UsersponsorsActivitiesArgs, 'actions' | 'includeAsSponsor' | 'orderBy' | 'period'>>;
  sponsorsListing?: Resolver<Maybe<ResolversTypes['Github_SponsorsListing']>, ParentType, ContextType>;
  sponsorshipForViewerAsSponsor?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType, RequireFields<Github_UsersponsorshipForViewerAsSponsorArgs, 'activeOnly'>>;
  sponsorshipForViewerAsSponsorable?: Resolver<Maybe<ResolversTypes['Github_Sponsorship']>, ParentType, ContextType, RequireFields<Github_UsersponsorshipForViewerAsSponsorableArgs, 'activeOnly'>>;
  sponsorshipNewsletters?: Resolver<ResolversTypes['Github_SponsorshipNewsletterConnection'], ParentType, ContextType, RequireFields<Github_UsersponsorshipNewslettersArgs, 'orderBy'>>;
  sponsorshipsAsMaintainer?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_UsersponsorshipsAsMaintainerArgs, 'activeOnly' | 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<ResolversTypes['Github_SponsorshipConnection'], ParentType, ContextType, RequireFields<Github_UsersponsorshipsAsSponsorArgs, 'activeOnly'>>;
  starredRepositories?: Resolver<ResolversTypes['Github_StarredRepositoryConnection'], ParentType, ContextType, Partial<Github_UserstarredRepositoriesArgs>>;
  status?: Resolver<Maybe<ResolversTypes['Github_UserStatus']>, ParentType, ContextType>;
  topRepositories?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_UsertopRepositoriesArgs, 'orderBy'>>;
  totalSponsorshipAmountAsSponsorInCents?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Github_UsertotalSponsorshipAmountAsSponsorInCentsArgs, 'sponsorableLogins'>>;
  twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanFollow?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSponsor?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsSponsoring?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  watching?: Resolver<ResolversTypes['Github_RepositoryConnection'], ParentType, ContextType, RequireFields<Github_UserwatchingArgs, 'ownerAffiliations'>>;
  websiteUrl?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserBlockedEventResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserBlockedEvent'] = ResolversParentTypes['Github_UserBlockedEvent']> = ResolversObject<{
  actor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  blockDuration?: Resolver<ResolversTypes['Github_UserBlockDuration'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserConnection'] = ResolversParentTypes['Github_UserConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserContentEditResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserContentEdit'] = ResolversParentTypes['Github_UserContentEdit']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deletedBy?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  diff?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  editedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<ResolversTypes['Github_Actor']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserContentEditConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserContentEditConnection'] = ResolversParentTypes['Github_UserContentEditConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserContentEditEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserContentEdit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserContentEditEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserContentEditEdge'] = ResolversParentTypes['Github_UserContentEditEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_UserContentEdit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserEdge'] = ResolversParentTypes['Github_UserEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserEmailMetadataResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserEmailMetadata'] = ResolversParentTypes['Github_UserEmailMetadata']> = ResolversObject<{
  primary?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserStatus'] = ResolversParentTypes['Github_UserStatus']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  emoji?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojiHTML?: Resolver<Maybe<ResolversTypes['Github_HTML']>, ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  indicatesLimitedAvailability?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserStatusConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserStatusConnection'] = ResolversParentTypes['Github_UserStatusConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_UserStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_UserStatusEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_UserStatusEdge'] = ResolversParentTypes['Github_UserStatusEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_VerifiableDomainResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_VerifiableDomain'] = ResolversParentTypes['Github_VerifiableDomain']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  dnsHostName?: Resolver<Maybe<ResolversTypes['Github_URI']>, ParentType, ContextType>;
  domain?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  hasFoundHostName?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasFoundVerificationToken?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isApproved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRequiredForPolicyEnforcement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Github_VerifiableDomainOwner'], ParentType, ContextType>;
  punycodeEncodedDomain?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  tokenExpirationTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_VerifiableDomainConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_VerifiableDomainConnection'] = ResolversParentTypes['Github_VerifiableDomainConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_VerifiableDomainEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_VerifiableDomain']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_VerifiableDomainEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_VerifiableDomainEdge'] = ResolversParentTypes['Github_VerifiableDomainEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_VerifiableDomainOwnerResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_VerifiableDomainOwner'] = ResolversParentTypes['Github_VerifiableDomainOwner']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Enterprise' | 'Github_Organization', ParentType, ContextType>;
}>;

export type Github_VerifyVerifiableDomainPayloadResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_VerifyVerifiableDomainPayload'] = ResolversParentTypes['Github_VerifyVerifiableDomainPayload']> = ResolversObject<{
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['Github_VerifiableDomain']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_ViewerHovercardContextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_ViewerHovercardContext'] = ResolversParentTypes['Github_ViewerHovercardContext']> = ResolversObject<{
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  viewer?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_VotableResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Votable'] = ResolversParentTypes['Github_Votable']> = ResolversObject<{
  __resolveType: TypeResolveFn<'Github_Discussion' | 'Github_DiscussionComment', ParentType, ContextType>;
  upvoteCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  viewerCanUpvote?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasUpvoted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
}>;

export type Github_WorkflowResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_Workflow'] = ResolversParentTypes['Github_Workflow']> = ResolversObject<{
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  runs?: Resolver<ResolversTypes['Github_WorkflowRunConnection'], ParentType, ContextType, RequireFields<Github_WorkflowrunsArgs, 'orderBy'>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_WorkflowRunResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_WorkflowRun'] = ResolversParentTypes['Github_WorkflowRun']> = ResolversObject<{
  checkSuite?: Resolver<ResolversTypes['Github_CheckSuite'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deploymentReviews?: Resolver<ResolversTypes['Github_DeploymentReviewConnection'], ParentType, ContextType, Partial<Github_WorkflowRundeploymentReviewsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pendingDeploymentRequests?: Resolver<ResolversTypes['Github_DeploymentRequestConnection'], ParentType, ContextType, Partial<Github_WorkflowRunpendingDeploymentRequestsArgs>>;
  resourcePath?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  runNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['Github_URI'], ParentType, ContextType>;
  workflow?: Resolver<ResolversTypes['Github_Workflow'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_WorkflowRunConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_WorkflowRunConnection'] = ResolversParentTypes['Github_WorkflowRunConnection']> = ResolversObject<{
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_WorkflowRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_WorkflowRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['Github_PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Github_WorkflowRunEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Github_WorkflowRunEdge'] = ResolversParentTypes['Github_WorkflowRunEdge']> = ResolversObject<{
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_WorkflowRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface Github_X509CertificateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Github_X509Certificate'], any> {
  name: 'Github_X509Certificate';
}

export type github_1QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['github_1Query'] = ResolversParentTypes['github_1Query']> = ResolversObject<{
  codeOfConduct?: Resolver<Maybe<ResolversTypes['Github_CodeOfConduct']>, ParentType, ContextType, RequireFields<github_1QuerycodeOfConductArgs, 'key'>>;
  codesOfConduct?: Resolver<Maybe<Array<Maybe<ResolversTypes['Github_CodeOfConduct']>>>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<ResolversTypes['Github_Enterprise']>, ParentType, ContextType, RequireFields<github_1QueryenterpriseArgs, 'slug'>>;
  enterpriseAdministratorInvitation?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<github_1QueryenterpriseAdministratorInvitationArgs, 'enterpriseSlug' | 'role' | 'userLogin'>>;
  enterpriseAdministratorInvitationByToken?: Resolver<Maybe<ResolversTypes['Github_EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<github_1QueryenterpriseAdministratorInvitationByTokenArgs, 'invitationToken'>>;
  license?: Resolver<Maybe<ResolversTypes['Github_License']>, ParentType, ContextType, RequireFields<github_1QuerylicenseArgs, 'key'>>;
  licenses?: Resolver<Array<Maybe<ResolversTypes['Github_License']>>, ParentType, ContextType>;
  marketplaceCategories?: Resolver<Array<ResolversTypes['Github_MarketplaceCategory']>, ParentType, ContextType, Partial<github_1QuerymarketplaceCategoriesArgs>>;
  marketplaceCategory?: Resolver<Maybe<ResolversTypes['Github_MarketplaceCategory']>, ParentType, ContextType, RequireFields<github_1QuerymarketplaceCategoryArgs, 'slug'>>;
  marketplaceListing?: Resolver<Maybe<ResolversTypes['Github_MarketplaceListing']>, ParentType, ContextType, RequireFields<github_1QuerymarketplaceListingArgs, 'slug'>>;
  marketplaceListings?: Resolver<ResolversTypes['Github_MarketplaceListingConnection'], ParentType, ContextType, RequireFields<github_1QuerymarketplaceListingsArgs, 'primaryCategoryOnly' | 'withFreeTrialsOnly'>>;
  meta?: Resolver<ResolversTypes['Github_GitHubMetadata'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Github_Node']>, ParentType, ContextType, RequireFields<github_1QuerynodeArgs, 'id'>>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Github_Node']>>, ParentType, ContextType, RequireFields<github_1QuerynodesArgs, 'ids'>>;
  organization?: Resolver<Maybe<ResolversTypes['Github_Organization']>, ParentType, ContextType, RequireFields<github_1QueryorganizationArgs, 'login'>>;
  rateLimit?: Resolver<Maybe<ResolversTypes['Github_RateLimit']>, ParentType, ContextType, RequireFields<github_1QueryrateLimitArgs, 'dryRun'>>;
  relay?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  repository?: Resolver<Maybe<ResolversTypes['Github_Repository']>, ParentType, ContextType, RequireFields<github_1QueryrepositoryArgs, 'followRenames' | 'name' | 'owner'>>;
  repositoryOwner?: Resolver<Maybe<ResolversTypes['Github_RepositoryOwner']>, ParentType, ContextType, RequireFields<github_1QueryrepositoryOwnerArgs, 'login'>>;
  resource?: Resolver<Maybe<ResolversTypes['Github_UniformResourceLocatable']>, ParentType, ContextType, RequireFields<github_1QueryresourceArgs, 'url'>>;
  search?: Resolver<ResolversTypes['Github_SearchResultItemConnection'], ParentType, ContextType, RequireFields<github_1QuerysearchArgs, 'query' | 'type'>>;
  securityAdvisories?: Resolver<ResolversTypes['Github_SecurityAdvisoryConnection'], ParentType, ContextType, RequireFields<github_1QuerysecurityAdvisoriesArgs, 'orderBy'>>;
  securityAdvisory?: Resolver<Maybe<ResolversTypes['Github_SecurityAdvisory']>, ParentType, ContextType, RequireFields<github_1QuerysecurityAdvisoryArgs, 'ghsaId'>>;
  securityVulnerabilities?: Resolver<ResolversTypes['Github_SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<github_1QuerysecurityVulnerabilitiesArgs, 'orderBy'>>;
  sponsorables?: Resolver<ResolversTypes['Github_SponsorableItemConnection'], ParentType, ContextType, RequireFields<github_1QuerysponsorablesArgs, 'onlyDependencies' | 'orderBy'>>;
  topic?: Resolver<Maybe<ResolversTypes['Github_Topic']>, ParentType, ContextType, RequireFields<github_1QuerytopicArgs, 'name'>>;
  user?: Resolver<Maybe<ResolversTypes['Github_User']>, ParentType, ContextType, RequireFields<github_1QueryuserArgs, 'login'>>;
  viewer?: Resolver<ResolversTypes['Github_User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type github_1MutationResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['github_1Mutation'] = ResolversParentTypes['github_1Mutation']> = ResolversObject<{
  abortQueuedMigrations?: Resolver<Maybe<ResolversTypes['Github_AbortQueuedMigrationsPayload']>, ParentType, ContextType, RequireFields<github_1MutationabortQueuedMigrationsArgs, 'input'>>;
  acceptEnterpriseAdministratorInvitation?: Resolver<Maybe<ResolversTypes['Github_AcceptEnterpriseAdministratorInvitationPayload']>, ParentType, ContextType, RequireFields<github_1MutationacceptEnterpriseAdministratorInvitationArgs, 'input'>>;
  acceptTopicSuggestion?: Resolver<Maybe<ResolversTypes['Github_AcceptTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<github_1MutationacceptTopicSuggestionArgs, 'input'>>;
  addAssigneesToAssignable?: Resolver<Maybe<ResolversTypes['Github_AddAssigneesToAssignablePayload']>, ParentType, ContextType, RequireFields<github_1MutationaddAssigneesToAssignableArgs, 'input'>>;
  addComment?: Resolver<Maybe<ResolversTypes['Github_AddCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddCommentArgs, 'input'>>;
  addDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_AddDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddDiscussionCommentArgs, 'input'>>;
  addDiscussionPollVote?: Resolver<Maybe<ResolversTypes['Github_AddDiscussionPollVotePayload']>, ParentType, ContextType, RequireFields<github_1MutationaddDiscussionPollVoteArgs, 'input'>>;
  addEnterpriseOrganizationMember?: Resolver<Maybe<ResolversTypes['Github_AddEnterpriseOrganizationMemberPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddEnterpriseOrganizationMemberArgs, 'input'>>;
  addEnterpriseSupportEntitlement?: Resolver<Maybe<ResolversTypes['Github_AddEnterpriseSupportEntitlementPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddEnterpriseSupportEntitlementArgs, 'input'>>;
  addLabelsToLabelable?: Resolver<Maybe<ResolversTypes['Github_AddLabelsToLabelablePayload']>, ParentType, ContextType, RequireFields<github_1MutationaddLabelsToLabelableArgs, 'input'>>;
  addProjectCard?: Resolver<Maybe<ResolversTypes['Github_AddProjectCardPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddProjectCardArgs, 'input'>>;
  addProjectColumn?: Resolver<Maybe<ResolversTypes['Github_AddProjectColumnPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddProjectColumnArgs, 'input'>>;
  addProjectV2DraftIssue?: Resolver<Maybe<ResolversTypes['Github_AddProjectV2DraftIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationaddProjectV2DraftIssueArgs, 'input'>>;
  addProjectV2ItemById?: Resolver<Maybe<ResolversTypes['Github_AddProjectV2ItemByIdPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddProjectV2ItemByIdArgs, 'input'>>;
  addPullRequestReview?: Resolver<Maybe<ResolversTypes['Github_AddPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddPullRequestReviewArgs, 'input'>>;
  addPullRequestReviewComment?: Resolver<Maybe<ResolversTypes['Github_AddPullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddPullRequestReviewCommentArgs, 'input'>>;
  addPullRequestReviewThread?: Resolver<Maybe<ResolversTypes['Github_AddPullRequestReviewThreadPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddPullRequestReviewThreadArgs, 'input'>>;
  addReaction?: Resolver<Maybe<ResolversTypes['Github_AddReactionPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddReactionArgs, 'input'>>;
  addStar?: Resolver<Maybe<ResolversTypes['Github_AddStarPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddStarArgs, 'input'>>;
  addUpvote?: Resolver<Maybe<ResolversTypes['Github_AddUpvotePayload']>, ParentType, ContextType, RequireFields<github_1MutationaddUpvoteArgs, 'input'>>;
  addVerifiableDomain?: Resolver<Maybe<ResolversTypes['Github_AddVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<github_1MutationaddVerifiableDomainArgs, 'input'>>;
  approveDeployments?: Resolver<Maybe<ResolversTypes['Github_ApproveDeploymentsPayload']>, ParentType, ContextType, RequireFields<github_1MutationapproveDeploymentsArgs, 'input'>>;
  approveVerifiableDomain?: Resolver<Maybe<ResolversTypes['Github_ApproveVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<github_1MutationapproveVerifiableDomainArgs, 'input'>>;
  archiveProjectV2Item?: Resolver<Maybe<ResolversTypes['Github_ArchiveProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<github_1MutationarchiveProjectV2ItemArgs, 'input'>>;
  archiveRepository?: Resolver<Maybe<ResolversTypes['Github_ArchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationarchiveRepositoryArgs, 'input'>>;
  cancelEnterpriseAdminInvitation?: Resolver<Maybe<ResolversTypes['Github_CancelEnterpriseAdminInvitationPayload']>, ParentType, ContextType, RequireFields<github_1MutationcancelEnterpriseAdminInvitationArgs, 'input'>>;
  cancelSponsorship?: Resolver<Maybe<ResolversTypes['Github_CancelSponsorshipPayload']>, ParentType, ContextType, RequireFields<github_1MutationcancelSponsorshipArgs, 'input'>>;
  changeUserStatus?: Resolver<Maybe<ResolversTypes['Github_ChangeUserStatusPayload']>, ParentType, ContextType, RequireFields<github_1MutationchangeUserStatusArgs, 'input'>>;
  clearLabelsFromLabelable?: Resolver<Maybe<ResolversTypes['Github_ClearLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<github_1MutationclearLabelsFromLabelableArgs, 'input'>>;
  clearProjectV2ItemFieldValue?: Resolver<Maybe<ResolversTypes['Github_ClearProjectV2ItemFieldValuePayload']>, ParentType, ContextType, RequireFields<github_1MutationclearProjectV2ItemFieldValueArgs, 'input'>>;
  cloneProject?: Resolver<Maybe<ResolversTypes['Github_CloneProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationcloneProjectArgs, 'input'>>;
  cloneTemplateRepository?: Resolver<Maybe<ResolversTypes['Github_CloneTemplateRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationcloneTemplateRepositoryArgs, 'input'>>;
  closeIssue?: Resolver<Maybe<ResolversTypes['Github_CloseIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationcloseIssueArgs, 'input'>>;
  closePullRequest?: Resolver<Maybe<ResolversTypes['Github_ClosePullRequestPayload']>, ParentType, ContextType, RequireFields<github_1MutationclosePullRequestArgs, 'input'>>;
  convertProjectCardNoteToIssue?: Resolver<Maybe<ResolversTypes['Github_ConvertProjectCardNoteToIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationconvertProjectCardNoteToIssueArgs, 'input'>>;
  convertPullRequestToDraft?: Resolver<Maybe<ResolversTypes['Github_ConvertPullRequestToDraftPayload']>, ParentType, ContextType, RequireFields<github_1MutationconvertPullRequestToDraftArgs, 'input'>>;
  copyProjectV2?: Resolver<Maybe<ResolversTypes['Github_CopyProjectV2Payload']>, ParentType, ContextType, RequireFields<github_1MutationcopyProjectV2Args, 'input'>>;
  createAttributionInvitation?: Resolver<Maybe<ResolversTypes['Github_CreateAttributionInvitationPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateAttributionInvitationArgs, 'input'>>;
  createBranchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_CreateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateBranchProtectionRuleArgs, 'input'>>;
  createCheckRun?: Resolver<Maybe<ResolversTypes['Github_CreateCheckRunPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateCheckRunArgs, 'input'>>;
  createCheckSuite?: Resolver<Maybe<ResolversTypes['Github_CreateCheckSuitePayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateCheckSuiteArgs, 'input'>>;
  createCommitOnBranch?: Resolver<Maybe<ResolversTypes['Github_CreateCommitOnBranchPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateCommitOnBranchArgs, 'input'>>;
  createDeployment?: Resolver<Maybe<ResolversTypes['Github_CreateDeploymentPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateDeploymentArgs, 'input'>>;
  createDeploymentStatus?: Resolver<Maybe<ResolversTypes['Github_CreateDeploymentStatusPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateDeploymentStatusArgs, 'input'>>;
  createDiscussion?: Resolver<Maybe<ResolversTypes['Github_CreateDiscussionPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateDiscussionArgs, 'input'>>;
  createEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['Github_CreateEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateEnterpriseOrganizationArgs, 'input'>>;
  createEnvironment?: Resolver<Maybe<ResolversTypes['Github_CreateEnvironmentPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateEnvironmentArgs, 'input'>>;
  createIpAllowListEntry?: Resolver<Maybe<ResolversTypes['Github_CreateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateIpAllowListEntryArgs, 'input'>>;
  createIssue?: Resolver<Maybe<ResolversTypes['Github_CreateIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateIssueArgs, 'input'>>;
  createLabel?: Resolver<Maybe<ResolversTypes['Github_CreateLabelPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateLabelArgs, 'input'>>;
  createLinkedBranch?: Resolver<Maybe<ResolversTypes['Github_CreateLinkedBranchPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateLinkedBranchArgs, 'input'>>;
  createMigrationSource?: Resolver<Maybe<ResolversTypes['Github_CreateMigrationSourcePayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateMigrationSourceArgs, 'input'>>;
  createProject?: Resolver<Maybe<ResolversTypes['Github_CreateProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateProjectArgs, 'input'>>;
  createProjectV2?: Resolver<Maybe<ResolversTypes['Github_CreateProjectV2Payload']>, ParentType, ContextType, RequireFields<github_1MutationcreateProjectV2Args, 'input'>>;
  createPullRequest?: Resolver<Maybe<ResolversTypes['Github_CreatePullRequestPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreatePullRequestArgs, 'input'>>;
  createRef?: Resolver<Maybe<ResolversTypes['Github_CreateRefPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateRefArgs, 'input'>>;
  createRepository?: Resolver<Maybe<ResolversTypes['Github_CreateRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateRepositoryArgs, 'input'>>;
  createSponsorsListing?: Resolver<Maybe<ResolversTypes['Github_CreateSponsorsListingPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateSponsorsListingArgs, 'input'>>;
  createSponsorsTier?: Resolver<Maybe<ResolversTypes['Github_CreateSponsorsTierPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateSponsorsTierArgs, 'input'>>;
  createSponsorship?: Resolver<Maybe<ResolversTypes['Github_CreateSponsorshipPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateSponsorshipArgs, 'input'>>;
  createTeamDiscussion?: Resolver<Maybe<ResolversTypes['Github_CreateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateTeamDiscussionArgs, 'input'>>;
  createTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_CreateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationcreateTeamDiscussionCommentArgs, 'input'>>;
  declineTopicSuggestion?: Resolver<Maybe<ResolversTypes['Github_DeclineTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeclineTopicSuggestionArgs, 'input'>>;
  deleteBranchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_DeleteBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteBranchProtectionRuleArgs, 'input'>>;
  deleteDeployment?: Resolver<Maybe<ResolversTypes['Github_DeleteDeploymentPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteDeploymentArgs, 'input'>>;
  deleteDiscussion?: Resolver<Maybe<ResolversTypes['Github_DeleteDiscussionPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteDiscussionArgs, 'input'>>;
  deleteDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_DeleteDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteDiscussionCommentArgs, 'input'>>;
  deleteEnvironment?: Resolver<Maybe<ResolversTypes['Github_DeleteEnvironmentPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteEnvironmentArgs, 'input'>>;
  deleteIpAllowListEntry?: Resolver<Maybe<ResolversTypes['Github_DeleteIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteIpAllowListEntryArgs, 'input'>>;
  deleteIssue?: Resolver<Maybe<ResolversTypes['Github_DeleteIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteIssueArgs, 'input'>>;
  deleteIssueComment?: Resolver<Maybe<ResolversTypes['Github_DeleteIssueCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteIssueCommentArgs, 'input'>>;
  deleteLabel?: Resolver<Maybe<ResolversTypes['Github_DeleteLabelPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteLabelArgs, 'input'>>;
  deleteLinkedBranch?: Resolver<Maybe<ResolversTypes['Github_DeleteLinkedBranchPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteLinkedBranchArgs, 'input'>>;
  deletePackageVersion?: Resolver<Maybe<ResolversTypes['Github_DeletePackageVersionPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeletePackageVersionArgs, 'input'>>;
  deleteProject?: Resolver<Maybe<ResolversTypes['Github_DeleteProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteProjectArgs, 'input'>>;
  deleteProjectCard?: Resolver<Maybe<ResolversTypes['Github_DeleteProjectCardPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteProjectCardArgs, 'input'>>;
  deleteProjectColumn?: Resolver<Maybe<ResolversTypes['Github_DeleteProjectColumnPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteProjectColumnArgs, 'input'>>;
  deleteProjectV2?: Resolver<Maybe<ResolversTypes['Github_DeleteProjectV2Payload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteProjectV2Args, 'input'>>;
  deleteProjectV2Item?: Resolver<Maybe<ResolversTypes['Github_DeleteProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteProjectV2ItemArgs, 'input'>>;
  deletePullRequestReview?: Resolver<Maybe<ResolversTypes['Github_DeletePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeletePullRequestReviewArgs, 'input'>>;
  deletePullRequestReviewComment?: Resolver<Maybe<ResolversTypes['Github_DeletePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeletePullRequestReviewCommentArgs, 'input'>>;
  deleteRef?: Resolver<Maybe<ResolversTypes['Github_DeleteRefPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteRefArgs, 'input'>>;
  deleteTeamDiscussion?: Resolver<Maybe<ResolversTypes['Github_DeleteTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteTeamDiscussionArgs, 'input'>>;
  deleteTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_DeleteTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteTeamDiscussionCommentArgs, 'input'>>;
  deleteVerifiableDomain?: Resolver<Maybe<ResolversTypes['Github_DeleteVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<github_1MutationdeleteVerifiableDomainArgs, 'input'>>;
  disablePullRequestAutoMerge?: Resolver<Maybe<ResolversTypes['Github_DisablePullRequestAutoMergePayload']>, ParentType, ContextType, RequireFields<github_1MutationdisablePullRequestAutoMergeArgs, 'input'>>;
  dismissPullRequestReview?: Resolver<Maybe<ResolversTypes['Github_DismissPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<github_1MutationdismissPullRequestReviewArgs, 'input'>>;
  dismissRepositoryVulnerabilityAlert?: Resolver<Maybe<ResolversTypes['Github_DismissRepositoryVulnerabilityAlertPayload']>, ParentType, ContextType, RequireFields<github_1MutationdismissRepositoryVulnerabilityAlertArgs, 'input'>>;
  enablePullRequestAutoMerge?: Resolver<Maybe<ResolversTypes['Github_EnablePullRequestAutoMergePayload']>, ParentType, ContextType, RequireFields<github_1MutationenablePullRequestAutoMergeArgs, 'input'>>;
  followOrganization?: Resolver<Maybe<ResolversTypes['Github_FollowOrganizationPayload']>, ParentType, ContextType, RequireFields<github_1MutationfollowOrganizationArgs, 'input'>>;
  followUser?: Resolver<Maybe<ResolversTypes['Github_FollowUserPayload']>, ParentType, ContextType, RequireFields<github_1MutationfollowUserArgs, 'input'>>;
  grantEnterpriseOrganizationsMigratorRole?: Resolver<Maybe<ResolversTypes['Github_GrantEnterpriseOrganizationsMigratorRolePayload']>, ParentType, ContextType, RequireFields<github_1MutationgrantEnterpriseOrganizationsMigratorRoleArgs, 'input'>>;
  grantMigratorRole?: Resolver<Maybe<ResolversTypes['Github_GrantMigratorRolePayload']>, ParentType, ContextType, RequireFields<github_1MutationgrantMigratorRoleArgs, 'input'>>;
  importProject?: Resolver<Maybe<ResolversTypes['Github_ImportProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationimportProjectArgs, 'input'>>;
  inviteEnterpriseAdmin?: Resolver<Maybe<ResolversTypes['Github_InviteEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<github_1MutationinviteEnterpriseAdminArgs, 'input'>>;
  linkProjectV2ToRepository?: Resolver<Maybe<ResolversTypes['Github_LinkProjectV2ToRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationlinkProjectV2ToRepositoryArgs, 'input'>>;
  linkProjectV2ToTeam?: Resolver<Maybe<ResolversTypes['Github_LinkProjectV2ToTeamPayload']>, ParentType, ContextType, RequireFields<github_1MutationlinkProjectV2ToTeamArgs, 'input'>>;
  linkRepositoryToProject?: Resolver<Maybe<ResolversTypes['Github_LinkRepositoryToProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationlinkRepositoryToProjectArgs, 'input'>>;
  lockLockable?: Resolver<Maybe<ResolversTypes['Github_LockLockablePayload']>, ParentType, ContextType, RequireFields<github_1MutationlockLockableArgs, 'input'>>;
  markDiscussionCommentAsAnswer?: Resolver<Maybe<ResolversTypes['Github_MarkDiscussionCommentAsAnswerPayload']>, ParentType, ContextType, RequireFields<github_1MutationmarkDiscussionCommentAsAnswerArgs, 'input'>>;
  markFileAsViewed?: Resolver<Maybe<ResolversTypes['Github_MarkFileAsViewedPayload']>, ParentType, ContextType, RequireFields<github_1MutationmarkFileAsViewedArgs, 'input'>>;
  markPullRequestReadyForReview?: Resolver<Maybe<ResolversTypes['Github_MarkPullRequestReadyForReviewPayload']>, ParentType, ContextType, RequireFields<github_1MutationmarkPullRequestReadyForReviewArgs, 'input'>>;
  mergeBranch?: Resolver<Maybe<ResolversTypes['Github_MergeBranchPayload']>, ParentType, ContextType, RequireFields<github_1MutationmergeBranchArgs, 'input'>>;
  mergePullRequest?: Resolver<Maybe<ResolversTypes['Github_MergePullRequestPayload']>, ParentType, ContextType, RequireFields<github_1MutationmergePullRequestArgs, 'input'>>;
  minimizeComment?: Resolver<Maybe<ResolversTypes['Github_MinimizeCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationminimizeCommentArgs, 'input'>>;
  moveProjectCard?: Resolver<Maybe<ResolversTypes['Github_MoveProjectCardPayload']>, ParentType, ContextType, RequireFields<github_1MutationmoveProjectCardArgs, 'input'>>;
  moveProjectColumn?: Resolver<Maybe<ResolversTypes['Github_MoveProjectColumnPayload']>, ParentType, ContextType, RequireFields<github_1MutationmoveProjectColumnArgs, 'input'>>;
  pinIssue?: Resolver<Maybe<ResolversTypes['Github_PinIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationpinIssueArgs, 'input'>>;
  publishSponsorsTier?: Resolver<Maybe<ResolversTypes['Github_PublishSponsorsTierPayload']>, ParentType, ContextType, RequireFields<github_1MutationpublishSponsorsTierArgs, 'input'>>;
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Resolver<Maybe<ResolversTypes['Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']>, ParentType, ContextType, RequireFields<github_1MutationregenerateEnterpriseIdentityProviderRecoveryCodesArgs, 'input'>>;
  regenerateVerifiableDomainToken?: Resolver<Maybe<ResolversTypes['Github_RegenerateVerifiableDomainTokenPayload']>, ParentType, ContextType, RequireFields<github_1MutationregenerateVerifiableDomainTokenArgs, 'input'>>;
  rejectDeployments?: Resolver<Maybe<ResolversTypes['Github_RejectDeploymentsPayload']>, ParentType, ContextType, RequireFields<github_1MutationrejectDeploymentsArgs, 'input'>>;
  removeAssigneesFromAssignable?: Resolver<Maybe<ResolversTypes['Github_RemoveAssigneesFromAssignablePayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveAssigneesFromAssignableArgs, 'input'>>;
  removeEnterpriseAdmin?: Resolver<Maybe<ResolversTypes['Github_RemoveEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveEnterpriseAdminArgs, 'input'>>;
  removeEnterpriseIdentityProvider?: Resolver<Maybe<ResolversTypes['Github_RemoveEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveEnterpriseIdentityProviderArgs, 'input'>>;
  removeEnterpriseMember?: Resolver<Maybe<ResolversTypes['Github_RemoveEnterpriseMemberPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveEnterpriseMemberArgs, 'input'>>;
  removeEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['Github_RemoveEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveEnterpriseOrganizationArgs, 'input'>>;
  removeEnterpriseSupportEntitlement?: Resolver<Maybe<ResolversTypes['Github_RemoveEnterpriseSupportEntitlementPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveEnterpriseSupportEntitlementArgs, 'input'>>;
  removeLabelsFromLabelable?: Resolver<Maybe<ResolversTypes['Github_RemoveLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveLabelsFromLabelableArgs, 'input'>>;
  removeOutsideCollaborator?: Resolver<Maybe<ResolversTypes['Github_RemoveOutsideCollaboratorPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveOutsideCollaboratorArgs, 'input'>>;
  removeReaction?: Resolver<Maybe<ResolversTypes['Github_RemoveReactionPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveReactionArgs, 'input'>>;
  removeStar?: Resolver<Maybe<ResolversTypes['Github_RemoveStarPayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveStarArgs, 'input'>>;
  removeUpvote?: Resolver<Maybe<ResolversTypes['Github_RemoveUpvotePayload']>, ParentType, ContextType, RequireFields<github_1MutationremoveUpvoteArgs, 'input'>>;
  reopenIssue?: Resolver<Maybe<ResolversTypes['Github_ReopenIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationreopenIssueArgs, 'input'>>;
  reopenPullRequest?: Resolver<Maybe<ResolversTypes['Github_ReopenPullRequestPayload']>, ParentType, ContextType, RequireFields<github_1MutationreopenPullRequestArgs, 'input'>>;
  requestReviews?: Resolver<Maybe<ResolversTypes['Github_RequestReviewsPayload']>, ParentType, ContextType, RequireFields<github_1MutationrequestReviewsArgs, 'input'>>;
  rerequestCheckSuite?: Resolver<Maybe<ResolversTypes['Github_RerequestCheckSuitePayload']>, ParentType, ContextType, RequireFields<github_1MutationrerequestCheckSuiteArgs, 'input'>>;
  resolveReviewThread?: Resolver<Maybe<ResolversTypes['Github_ResolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<github_1MutationresolveReviewThreadArgs, 'input'>>;
  retireSponsorsTier?: Resolver<Maybe<ResolversTypes['Github_RetireSponsorsTierPayload']>, ParentType, ContextType, RequireFields<github_1MutationretireSponsorsTierArgs, 'input'>>;
  revertPullRequest?: Resolver<Maybe<ResolversTypes['Github_RevertPullRequestPayload']>, ParentType, ContextType, RequireFields<github_1MutationrevertPullRequestArgs, 'input'>>;
  revokeEnterpriseOrganizationsMigratorRole?: Resolver<Maybe<ResolversTypes['Github_RevokeEnterpriseOrganizationsMigratorRolePayload']>, ParentType, ContextType, RequireFields<github_1MutationrevokeEnterpriseOrganizationsMigratorRoleArgs, 'input'>>;
  revokeMigratorRole?: Resolver<Maybe<ResolversTypes['Github_RevokeMigratorRolePayload']>, ParentType, ContextType, RequireFields<github_1MutationrevokeMigratorRoleArgs, 'input'>>;
  setEnterpriseIdentityProvider?: Resolver<Maybe<ResolversTypes['Github_SetEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<github_1MutationsetEnterpriseIdentityProviderArgs, 'input'>>;
  setOrganizationInteractionLimit?: Resolver<Maybe<ResolversTypes['Github_SetOrganizationInteractionLimitPayload']>, ParentType, ContextType, RequireFields<github_1MutationsetOrganizationInteractionLimitArgs, 'input'>>;
  setRepositoryInteractionLimit?: Resolver<Maybe<ResolversTypes['Github_SetRepositoryInteractionLimitPayload']>, ParentType, ContextType, RequireFields<github_1MutationsetRepositoryInteractionLimitArgs, 'input'>>;
  setUserInteractionLimit?: Resolver<Maybe<ResolversTypes['Github_SetUserInteractionLimitPayload']>, ParentType, ContextType, RequireFields<github_1MutationsetUserInteractionLimitArgs, 'input'>>;
  startOrganizationMigration?: Resolver<Maybe<ResolversTypes['Github_StartOrganizationMigrationPayload']>, ParentType, ContextType, RequireFields<github_1MutationstartOrganizationMigrationArgs, 'input'>>;
  startRepositoryMigration?: Resolver<Maybe<ResolversTypes['Github_StartRepositoryMigrationPayload']>, ParentType, ContextType, RequireFields<github_1MutationstartRepositoryMigrationArgs, 'input'>>;
  submitPullRequestReview?: Resolver<Maybe<ResolversTypes['Github_SubmitPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<github_1MutationsubmitPullRequestReviewArgs, 'input'>>;
  transferEnterpriseOrganization?: Resolver<Maybe<ResolversTypes['Github_TransferEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<github_1MutationtransferEnterpriseOrganizationArgs, 'input'>>;
  transferIssue?: Resolver<Maybe<ResolversTypes['Github_TransferIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationtransferIssueArgs, 'input'>>;
  unarchiveProjectV2Item?: Resolver<Maybe<ResolversTypes['Github_UnarchiveProjectV2ItemPayload']>, ParentType, ContextType, RequireFields<github_1MutationunarchiveProjectV2ItemArgs, 'input'>>;
  unarchiveRepository?: Resolver<Maybe<ResolversTypes['Github_UnarchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationunarchiveRepositoryArgs, 'input'>>;
  unfollowOrganization?: Resolver<Maybe<ResolversTypes['Github_UnfollowOrganizationPayload']>, ParentType, ContextType, RequireFields<github_1MutationunfollowOrganizationArgs, 'input'>>;
  unfollowUser?: Resolver<Maybe<ResolversTypes['Github_UnfollowUserPayload']>, ParentType, ContextType, RequireFields<github_1MutationunfollowUserArgs, 'input'>>;
  unlinkProjectV2FromRepository?: Resolver<Maybe<ResolversTypes['Github_UnlinkProjectV2FromRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationunlinkProjectV2FromRepositoryArgs, 'input'>>;
  unlinkProjectV2FromTeam?: Resolver<Maybe<ResolversTypes['Github_UnlinkProjectV2FromTeamPayload']>, ParentType, ContextType, RequireFields<github_1MutationunlinkProjectV2FromTeamArgs, 'input'>>;
  unlinkRepositoryFromProject?: Resolver<Maybe<ResolversTypes['Github_UnlinkRepositoryFromProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationunlinkRepositoryFromProjectArgs, 'input'>>;
  unlockLockable?: Resolver<Maybe<ResolversTypes['Github_UnlockLockablePayload']>, ParentType, ContextType, RequireFields<github_1MutationunlockLockableArgs, 'input'>>;
  unmarkDiscussionCommentAsAnswer?: Resolver<Maybe<ResolversTypes['Github_UnmarkDiscussionCommentAsAnswerPayload']>, ParentType, ContextType, RequireFields<github_1MutationunmarkDiscussionCommentAsAnswerArgs, 'input'>>;
  unmarkFileAsViewed?: Resolver<Maybe<ResolversTypes['Github_UnmarkFileAsViewedPayload']>, ParentType, ContextType, RequireFields<github_1MutationunmarkFileAsViewedArgs, 'input'>>;
  unmarkIssueAsDuplicate?: Resolver<Maybe<ResolversTypes['Github_UnmarkIssueAsDuplicatePayload']>, ParentType, ContextType, RequireFields<github_1MutationunmarkIssueAsDuplicateArgs, 'input'>>;
  unminimizeComment?: Resolver<Maybe<ResolversTypes['Github_UnminimizeCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationunminimizeCommentArgs, 'input'>>;
  unpinIssue?: Resolver<Maybe<ResolversTypes['Github_UnpinIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationunpinIssueArgs, 'input'>>;
  unresolveReviewThread?: Resolver<Maybe<ResolversTypes['Github_UnresolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<github_1MutationunresolveReviewThreadArgs, 'input'>>;
  updateBranchProtectionRule?: Resolver<Maybe<ResolversTypes['Github_UpdateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateBranchProtectionRuleArgs, 'input'>>;
  updateCheckRun?: Resolver<Maybe<ResolversTypes['Github_UpdateCheckRunPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateCheckRunArgs, 'input'>>;
  updateCheckSuitePreferences?: Resolver<Maybe<ResolversTypes['Github_UpdateCheckSuitePreferencesPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateCheckSuitePreferencesArgs, 'input'>>;
  updateDiscussion?: Resolver<Maybe<ResolversTypes['Github_UpdateDiscussionPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateDiscussionArgs, 'input'>>;
  updateDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_UpdateDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateDiscussionCommentArgs, 'input'>>;
  updateEnterpriseAdministratorRole?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseAdministratorRolePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseAdministratorRoleArgs, 'input'>>;
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  updateEnterpriseDefaultRepositoryPermissionSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseDefaultRepositoryPermissionSettingArgs, 'input'>>;
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs, 'input'>>;
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanCreateRepositoriesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanDeleteIssuesSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanDeleteIssuesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanDeleteRepositoriesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanInviteCollaboratorsSettingArgs, 'input'>>;
  updateEnterpriseMembersCanMakePurchasesSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanMakePurchasesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseMembersCanViewDependencyInsightsSettingArgs, 'input'>>;
  updateEnterpriseOrganizationProjectsSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseOrganizationProjectsSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseOrganizationProjectsSettingArgs, 'input'>>;
  updateEnterpriseOwnerOrganizationRole?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseOwnerOrganizationRolePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseOwnerOrganizationRoleArgs, 'input'>>;
  updateEnterpriseProfile?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseProfilePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseProfileArgs, 'input'>>;
  updateEnterpriseRepositoryProjectsSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseRepositoryProjectsSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseRepositoryProjectsSettingArgs, 'input'>>;
  updateEnterpriseTeamDiscussionsSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseTeamDiscussionsSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseTeamDiscussionsSettingArgs, 'input'>>;
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs, 'input'>>;
  updateEnvironment?: Resolver<Maybe<ResolversTypes['Github_UpdateEnvironmentPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateEnvironmentArgs, 'input'>>;
  updateIpAllowListEnabledSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateIpAllowListEnabledSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateIpAllowListEnabledSettingArgs, 'input'>>;
  updateIpAllowListEntry?: Resolver<Maybe<ResolversTypes['Github_UpdateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateIpAllowListEntryArgs, 'input'>>;
  updateIpAllowListForInstalledAppsEnabledSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateIpAllowListForInstalledAppsEnabledSettingArgs, 'input'>>;
  updateIssue?: Resolver<Maybe<ResolversTypes['Github_UpdateIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateIssueArgs, 'input'>>;
  updateIssueComment?: Resolver<Maybe<ResolversTypes['Github_UpdateIssueCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateIssueCommentArgs, 'input'>>;
  updateLabel?: Resolver<Maybe<ResolversTypes['Github_UpdateLabelPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateLabelArgs, 'input'>>;
  updateNotificationRestrictionSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateNotificationRestrictionSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateNotificationRestrictionSettingArgs, 'input'>>;
  updateOrganizationAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateOrganizationAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  updateOrganizationWebCommitSignoffSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateOrganizationWebCommitSignoffSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateOrganizationWebCommitSignoffSettingArgs, 'input'>>;
  updateProject?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectArgs, 'input'>>;
  updateProjectCard?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectCardPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectCardArgs, 'input'>>;
  updateProjectColumn?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectColumnPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectColumnArgs, 'input'>>;
  updateProjectV2?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectV2Payload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectV2Args, 'input'>>;
  updateProjectV2DraftIssue?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectV2DraftIssuePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectV2DraftIssueArgs, 'input'>>;
  updateProjectV2ItemFieldValue?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectV2ItemFieldValuePayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectV2ItemFieldValueArgs, 'input'>>;
  updateProjectV2ItemPosition?: Resolver<Maybe<ResolversTypes['Github_UpdateProjectV2ItemPositionPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateProjectV2ItemPositionArgs, 'input'>>;
  updatePullRequest?: Resolver<Maybe<ResolversTypes['Github_UpdatePullRequestPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdatePullRequestArgs, 'input'>>;
  updatePullRequestBranch?: Resolver<Maybe<ResolversTypes['Github_UpdatePullRequestBranchPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdatePullRequestBranchArgs, 'input'>>;
  updatePullRequestReview?: Resolver<Maybe<ResolversTypes['Github_UpdatePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdatePullRequestReviewArgs, 'input'>>;
  updatePullRequestReviewComment?: Resolver<Maybe<ResolversTypes['Github_UpdatePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdatePullRequestReviewCommentArgs, 'input'>>;
  updateRef?: Resolver<Maybe<ResolversTypes['Github_UpdateRefPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateRefArgs, 'input'>>;
  updateRefs?: Resolver<Maybe<ResolversTypes['Github_UpdateRefsPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateRefsArgs, 'input'>>;
  updateRepository?: Resolver<Maybe<ResolversTypes['Github_UpdateRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateRepositoryArgs, 'input'>>;
  updateRepositoryWebCommitSignoffSetting?: Resolver<Maybe<ResolversTypes['Github_UpdateRepositoryWebCommitSignoffSettingPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateRepositoryWebCommitSignoffSettingArgs, 'input'>>;
  updateSponsorshipPreferences?: Resolver<Maybe<ResolversTypes['Github_UpdateSponsorshipPreferencesPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateSponsorshipPreferencesArgs, 'input'>>;
  updateSubscription?: Resolver<Maybe<ResolversTypes['Github_UpdateSubscriptionPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateSubscriptionArgs, 'input'>>;
  updateTeamDiscussion?: Resolver<Maybe<ResolversTypes['Github_UpdateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateTeamDiscussionArgs, 'input'>>;
  updateTeamDiscussionComment?: Resolver<Maybe<ResolversTypes['Github_UpdateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateTeamDiscussionCommentArgs, 'input'>>;
  updateTeamReviewAssignment?: Resolver<Maybe<ResolversTypes['Github_UpdateTeamReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateTeamReviewAssignmentArgs, 'input'>>;
  updateTeamsRepository?: Resolver<Maybe<ResolversTypes['Github_UpdateTeamsRepositoryPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateTeamsRepositoryArgs, 'input'>>;
  updateTopics?: Resolver<Maybe<ResolversTypes['Github_UpdateTopicsPayload']>, ParentType, ContextType, RequireFields<github_1MutationupdateTopicsArgs, 'input'>>;
  verifyVerifiableDomain?: Resolver<Maybe<ResolversTypes['Github_VerifyVerifiableDomainPayload']>, ParentType, ContextType, RequireFields<github_1MutationverifyVerifiableDomainArgs, 'input'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = MeshContext> = ResolversObject<{
  Query?: QueryResolvers<ContextType>;
  AWSLambda_ListFunctionsResponse?: AWSLambda_ListFunctionsResponseResolvers<ContextType>;
  AWSLambda_FunctionsListItem?: AWSLambda_FunctionsListItemResolvers<ContextType>;
  AWSLambda_DeadLetterConfig?: AWSLambda_DeadLetterConfigResolvers<ContextType>;
  AWSLambda_Environment?: AWSLambda_EnvironmentResolvers<ContextType>;
  AWSLambda_Error?: AWSLambda_ErrorResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  AWSLambda_FileSystemConfigsListItem?: AWSLambda_FileSystemConfigsListItemResolvers<ContextType>;
  AWSLambda_ImageConfigResponse?: AWSLambda_ImageConfigResponseResolvers<ContextType>;
  AWSLambda_Error2?: AWSLambda_Error2Resolvers<ContextType>;
  AWSLambda_ImageConfig?: AWSLambda_ImageConfigResolvers<ContextType>;
  AWSLambda_LayersListItem?: AWSLambda_LayersListItemResolvers<ContextType>;
  AWSLambda_TracingConfig?: AWSLambda_TracingConfigResolvers<ContextType>;
  AWSLambda_VpcConfig?: AWSLambda_VpcConfigResolvers<ContextType>;
  aws_lambda_1Query?: aws_lambda_1QueryResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Github_AbortQueuedMigrationsPayload?: Github_AbortQueuedMigrationsPayloadResolvers<ContextType>;
  Github_AcceptEnterpriseAdministratorInvitationPayload?: Github_AcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType>;
  Github_AcceptTopicSuggestionPayload?: Github_AcceptTopicSuggestionPayloadResolvers<ContextType>;
  Github_Actor?: Github_ActorResolvers<ContextType>;
  Github_ActorLocation?: Github_ActorLocationResolvers<ContextType>;
  Github_AddAssigneesToAssignablePayload?: Github_AddAssigneesToAssignablePayloadResolvers<ContextType>;
  Github_AddCommentPayload?: Github_AddCommentPayloadResolvers<ContextType>;
  Github_AddDiscussionCommentPayload?: Github_AddDiscussionCommentPayloadResolvers<ContextType>;
  Github_AddDiscussionPollVotePayload?: Github_AddDiscussionPollVotePayloadResolvers<ContextType>;
  Github_AddEnterpriseOrganizationMemberPayload?: Github_AddEnterpriseOrganizationMemberPayloadResolvers<ContextType>;
  Github_AddEnterpriseSupportEntitlementPayload?: Github_AddEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  Github_AddLabelsToLabelablePayload?: Github_AddLabelsToLabelablePayloadResolvers<ContextType>;
  Github_AddProjectCardPayload?: Github_AddProjectCardPayloadResolvers<ContextType>;
  Github_AddProjectColumnPayload?: Github_AddProjectColumnPayloadResolvers<ContextType>;
  Github_AddProjectV2DraftIssuePayload?: Github_AddProjectV2DraftIssuePayloadResolvers<ContextType>;
  Github_AddProjectV2ItemByIdPayload?: Github_AddProjectV2ItemByIdPayloadResolvers<ContextType>;
  Github_AddPullRequestReviewCommentPayload?: Github_AddPullRequestReviewCommentPayloadResolvers<ContextType>;
  Github_AddPullRequestReviewPayload?: Github_AddPullRequestReviewPayloadResolvers<ContextType>;
  Github_AddPullRequestReviewThreadPayload?: Github_AddPullRequestReviewThreadPayloadResolvers<ContextType>;
  Github_AddReactionPayload?: Github_AddReactionPayloadResolvers<ContextType>;
  Github_AddStarPayload?: Github_AddStarPayloadResolvers<ContextType>;
  Github_AddUpvotePayload?: Github_AddUpvotePayloadResolvers<ContextType>;
  Github_AddVerifiableDomainPayload?: Github_AddVerifiableDomainPayloadResolvers<ContextType>;
  Github_AddedToProjectEvent?: Github_AddedToProjectEventResolvers<ContextType>;
  Github_AnnouncementBanner?: Github_AnnouncementBannerResolvers<ContextType>;
  Github_App?: Github_AppResolvers<ContextType>;
  Github_ApproveDeploymentsPayload?: Github_ApproveDeploymentsPayloadResolvers<ContextType>;
  Github_ApproveVerifiableDomainPayload?: Github_ApproveVerifiableDomainPayloadResolvers<ContextType>;
  Github_ArchiveProjectV2ItemPayload?: Github_ArchiveProjectV2ItemPayloadResolvers<ContextType>;
  Github_ArchiveRepositoryPayload?: Github_ArchiveRepositoryPayloadResolvers<ContextType>;
  Github_Assignable?: Github_AssignableResolvers<ContextType>;
  Github_AssignedEvent?: Github_AssignedEventResolvers<ContextType>;
  Github_Assignee?: Github_AssigneeResolvers<ContextType>;
  Github_AuditEntry?: Github_AuditEntryResolvers<ContextType>;
  Github_AuditEntryActor?: Github_AuditEntryActorResolvers<ContextType>;
  Github_AutoMergeDisabledEvent?: Github_AutoMergeDisabledEventResolvers<ContextType>;
  Github_AutoMergeEnabledEvent?: Github_AutoMergeEnabledEventResolvers<ContextType>;
  Github_AutoMergeRequest?: Github_AutoMergeRequestResolvers<ContextType>;
  Github_AutoRebaseEnabledEvent?: Github_AutoRebaseEnabledEventResolvers<ContextType>;
  Github_AutoSquashEnabledEvent?: Github_AutoSquashEnabledEventResolvers<ContextType>;
  Github_AutomaticBaseChangeFailedEvent?: Github_AutomaticBaseChangeFailedEventResolvers<ContextType>;
  Github_AutomaticBaseChangeSucceededEvent?: Github_AutomaticBaseChangeSucceededEventResolvers<ContextType>;
  Github_Base64String?: GraphQLScalarType;
  Github_BaseRefChangedEvent?: Github_BaseRefChangedEventResolvers<ContextType>;
  Github_BaseRefDeletedEvent?: Github_BaseRefDeletedEventResolvers<ContextType>;
  Github_BaseRefForcePushedEvent?: Github_BaseRefForcePushedEventResolvers<ContextType>;
  Github_Blame?: Github_BlameResolvers<ContextType>;
  Github_BlameRange?: Github_BlameRangeResolvers<ContextType>;
  Github_Blob?: Github_BlobResolvers<ContextType>;
  Github_Bot?: Github_BotResolvers<ContextType>;
  Github_BranchActorAllowanceActor?: Github_BranchActorAllowanceActorResolvers<ContextType>;
  Github_BranchProtectionRule?: Github_BranchProtectionRuleResolvers<ContextType>;
  Github_BranchProtectionRuleConflict?: Github_BranchProtectionRuleConflictResolvers<ContextType>;
  Github_BranchProtectionRuleConflictConnection?: Github_BranchProtectionRuleConflictConnectionResolvers<ContextType>;
  Github_BranchProtectionRuleConflictEdge?: Github_BranchProtectionRuleConflictEdgeResolvers<ContextType>;
  Github_BranchProtectionRuleConnection?: Github_BranchProtectionRuleConnectionResolvers<ContextType>;
  Github_BranchProtectionRuleEdge?: Github_BranchProtectionRuleEdgeResolvers<ContextType>;
  Github_BypassForcePushAllowance?: Github_BypassForcePushAllowanceResolvers<ContextType>;
  Github_BypassForcePushAllowanceConnection?: Github_BypassForcePushAllowanceConnectionResolvers<ContextType>;
  Github_BypassForcePushAllowanceEdge?: Github_BypassForcePushAllowanceEdgeResolvers<ContextType>;
  Github_BypassPullRequestAllowance?: Github_BypassPullRequestAllowanceResolvers<ContextType>;
  Github_BypassPullRequestAllowanceConnection?: Github_BypassPullRequestAllowanceConnectionResolvers<ContextType>;
  Github_BypassPullRequestAllowanceEdge?: Github_BypassPullRequestAllowanceEdgeResolvers<ContextType>;
  Github_CVSS?: Github_CVSSResolvers<ContextType>;
  Github_CWE?: Github_CWEResolvers<ContextType>;
  Github_CWEConnection?: Github_CWEConnectionResolvers<ContextType>;
  Github_CWEEdge?: Github_CWEEdgeResolvers<ContextType>;
  Github_CancelEnterpriseAdminInvitationPayload?: Github_CancelEnterpriseAdminInvitationPayloadResolvers<ContextType>;
  Github_CancelSponsorshipPayload?: Github_CancelSponsorshipPayloadResolvers<ContextType>;
  Github_ChangeUserStatusPayload?: Github_ChangeUserStatusPayloadResolvers<ContextType>;
  Github_CheckAnnotation?: Github_CheckAnnotationResolvers<ContextType>;
  Github_CheckAnnotationConnection?: Github_CheckAnnotationConnectionResolvers<ContextType>;
  Github_CheckAnnotationEdge?: Github_CheckAnnotationEdgeResolvers<ContextType>;
  Github_CheckAnnotationPosition?: Github_CheckAnnotationPositionResolvers<ContextType>;
  Github_CheckAnnotationSpan?: Github_CheckAnnotationSpanResolvers<ContextType>;
  Github_CheckRun?: Github_CheckRunResolvers<ContextType>;
  Github_CheckRunConnection?: Github_CheckRunConnectionResolvers<ContextType>;
  Github_CheckRunEdge?: Github_CheckRunEdgeResolvers<ContextType>;
  Github_CheckRunStateCount?: Github_CheckRunStateCountResolvers<ContextType>;
  Github_CheckStep?: Github_CheckStepResolvers<ContextType>;
  Github_CheckStepConnection?: Github_CheckStepConnectionResolvers<ContextType>;
  Github_CheckStepEdge?: Github_CheckStepEdgeResolvers<ContextType>;
  Github_CheckSuite?: Github_CheckSuiteResolvers<ContextType>;
  Github_CheckSuiteConnection?: Github_CheckSuiteConnectionResolvers<ContextType>;
  Github_CheckSuiteEdge?: Github_CheckSuiteEdgeResolvers<ContextType>;
  Github_Claimable?: Github_ClaimableResolvers<ContextType>;
  Github_ClearLabelsFromLabelablePayload?: Github_ClearLabelsFromLabelablePayloadResolvers<ContextType>;
  Github_ClearProjectV2ItemFieldValuePayload?: Github_ClearProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  Github_CloneProjectPayload?: Github_CloneProjectPayloadResolvers<ContextType>;
  Github_CloneTemplateRepositoryPayload?: Github_CloneTemplateRepositoryPayloadResolvers<ContextType>;
  Github_Closable?: Github_ClosableResolvers<ContextType>;
  Github_CloseIssuePayload?: Github_CloseIssuePayloadResolvers<ContextType>;
  Github_ClosePullRequestPayload?: Github_ClosePullRequestPayloadResolvers<ContextType>;
  Github_ClosedEvent?: Github_ClosedEventResolvers<ContextType>;
  Github_Closer?: Github_CloserResolvers<ContextType>;
  Github_CodeOfConduct?: Github_CodeOfConductResolvers<ContextType>;
  Github_Comment?: Github_CommentResolvers<ContextType>;
  Github_CommentDeletedEvent?: Github_CommentDeletedEventResolvers<ContextType>;
  Github_Commit?: Github_CommitResolvers<ContextType>;
  Github_CommitComment?: Github_CommitCommentResolvers<ContextType>;
  Github_CommitCommentConnection?: Github_CommitCommentConnectionResolvers<ContextType>;
  Github_CommitCommentEdge?: Github_CommitCommentEdgeResolvers<ContextType>;
  Github_CommitCommentThread?: Github_CommitCommentThreadResolvers<ContextType>;
  Github_CommitConnection?: Github_CommitConnectionResolvers<ContextType>;
  Github_CommitContributionsByRepository?: Github_CommitContributionsByRepositoryResolvers<ContextType>;
  Github_CommitEdge?: Github_CommitEdgeResolvers<ContextType>;
  Github_CommitHistoryConnection?: Github_CommitHistoryConnectionResolvers<ContextType>;
  Github_Comparison?: Github_ComparisonResolvers<ContextType>;
  Github_ComparisonCommitConnection?: Github_ComparisonCommitConnectionResolvers<ContextType>;
  Github_ConnectedEvent?: Github_ConnectedEventResolvers<ContextType>;
  Github_Contribution?: Github_ContributionResolvers<ContextType>;
  Github_ContributionCalendar?: Github_ContributionCalendarResolvers<ContextType>;
  Github_ContributionCalendarDay?: Github_ContributionCalendarDayResolvers<ContextType>;
  Github_ContributionCalendarMonth?: Github_ContributionCalendarMonthResolvers<ContextType>;
  Github_ContributionCalendarWeek?: Github_ContributionCalendarWeekResolvers<ContextType>;
  Github_ContributionsCollection?: Github_ContributionsCollectionResolvers<ContextType>;
  Github_ConvertProjectCardNoteToIssuePayload?: Github_ConvertProjectCardNoteToIssuePayloadResolvers<ContextType>;
  Github_ConvertPullRequestToDraftPayload?: Github_ConvertPullRequestToDraftPayloadResolvers<ContextType>;
  Github_ConvertToDraftEvent?: Github_ConvertToDraftEventResolvers<ContextType>;
  Github_ConvertedNoteToIssueEvent?: Github_ConvertedNoteToIssueEventResolvers<ContextType>;
  Github_ConvertedToDiscussionEvent?: Github_ConvertedToDiscussionEventResolvers<ContextType>;
  Github_CopyProjectV2Payload?: Github_CopyProjectV2PayloadResolvers<ContextType>;
  Github_CreateAttributionInvitationPayload?: Github_CreateAttributionInvitationPayloadResolvers<ContextType>;
  Github_CreateBranchProtectionRulePayload?: Github_CreateBranchProtectionRulePayloadResolvers<ContextType>;
  Github_CreateCheckRunPayload?: Github_CreateCheckRunPayloadResolvers<ContextType>;
  Github_CreateCheckSuitePayload?: Github_CreateCheckSuitePayloadResolvers<ContextType>;
  Github_CreateCommitOnBranchPayload?: Github_CreateCommitOnBranchPayloadResolvers<ContextType>;
  Github_CreateDeploymentPayload?: Github_CreateDeploymentPayloadResolvers<ContextType>;
  Github_CreateDeploymentStatusPayload?: Github_CreateDeploymentStatusPayloadResolvers<ContextType>;
  Github_CreateDiscussionPayload?: Github_CreateDiscussionPayloadResolvers<ContextType>;
  Github_CreateEnterpriseOrganizationPayload?: Github_CreateEnterpriseOrganizationPayloadResolvers<ContextType>;
  Github_CreateEnvironmentPayload?: Github_CreateEnvironmentPayloadResolvers<ContextType>;
  Github_CreateIpAllowListEntryPayload?: Github_CreateIpAllowListEntryPayloadResolvers<ContextType>;
  Github_CreateIssuePayload?: Github_CreateIssuePayloadResolvers<ContextType>;
  Github_CreateLabelPayload?: Github_CreateLabelPayloadResolvers<ContextType>;
  Github_CreateLinkedBranchPayload?: Github_CreateLinkedBranchPayloadResolvers<ContextType>;
  Github_CreateMigrationSourcePayload?: Github_CreateMigrationSourcePayloadResolvers<ContextType>;
  Github_CreateProjectPayload?: Github_CreateProjectPayloadResolvers<ContextType>;
  Github_CreateProjectV2Payload?: Github_CreateProjectV2PayloadResolvers<ContextType>;
  Github_CreatePullRequestPayload?: Github_CreatePullRequestPayloadResolvers<ContextType>;
  Github_CreateRefPayload?: Github_CreateRefPayloadResolvers<ContextType>;
  Github_CreateRepositoryPayload?: Github_CreateRepositoryPayloadResolvers<ContextType>;
  Github_CreateSponsorsListingPayload?: Github_CreateSponsorsListingPayloadResolvers<ContextType>;
  Github_CreateSponsorsTierPayload?: Github_CreateSponsorsTierPayloadResolvers<ContextType>;
  Github_CreateSponsorshipPayload?: Github_CreateSponsorshipPayloadResolvers<ContextType>;
  Github_CreateTeamDiscussionCommentPayload?: Github_CreateTeamDiscussionCommentPayloadResolvers<ContextType>;
  Github_CreateTeamDiscussionPayload?: Github_CreateTeamDiscussionPayloadResolvers<ContextType>;
  Github_CreatedCommitContribution?: Github_CreatedCommitContributionResolvers<ContextType>;
  Github_CreatedCommitContributionConnection?: Github_CreatedCommitContributionConnectionResolvers<ContextType>;
  Github_CreatedCommitContributionEdge?: Github_CreatedCommitContributionEdgeResolvers<ContextType>;
  Github_CreatedIssueContribution?: Github_CreatedIssueContributionResolvers<ContextType>;
  Github_CreatedIssueContributionConnection?: Github_CreatedIssueContributionConnectionResolvers<ContextType>;
  Github_CreatedIssueContributionEdge?: Github_CreatedIssueContributionEdgeResolvers<ContextType>;
  Github_CreatedIssueOrRestrictedContribution?: Github_CreatedIssueOrRestrictedContributionResolvers<ContextType>;
  Github_CreatedPullRequestContribution?: Github_CreatedPullRequestContributionResolvers<ContextType>;
  Github_CreatedPullRequestContributionConnection?: Github_CreatedPullRequestContributionConnectionResolvers<ContextType>;
  Github_CreatedPullRequestContributionEdge?: Github_CreatedPullRequestContributionEdgeResolvers<ContextType>;
  Github_CreatedPullRequestOrRestrictedContribution?: Github_CreatedPullRequestOrRestrictedContributionResolvers<ContextType>;
  Github_CreatedPullRequestReviewContribution?: Github_CreatedPullRequestReviewContributionResolvers<ContextType>;
  Github_CreatedPullRequestReviewContributionConnection?: Github_CreatedPullRequestReviewContributionConnectionResolvers<ContextType>;
  Github_CreatedPullRequestReviewContributionEdge?: Github_CreatedPullRequestReviewContributionEdgeResolvers<ContextType>;
  Github_CreatedRepositoryContribution?: Github_CreatedRepositoryContributionResolvers<ContextType>;
  Github_CreatedRepositoryContributionConnection?: Github_CreatedRepositoryContributionConnectionResolvers<ContextType>;
  Github_CreatedRepositoryContributionEdge?: Github_CreatedRepositoryContributionEdgeResolvers<ContextType>;
  Github_CreatedRepositoryOrRestrictedContribution?: Github_CreatedRepositoryOrRestrictedContributionResolvers<ContextType>;
  Github_CrossReferencedEvent?: Github_CrossReferencedEventResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  Github_DeclineTopicSuggestionPayload?: Github_DeclineTopicSuggestionPayloadResolvers<ContextType>;
  Github_Deletable?: Github_DeletableResolvers<ContextType>;
  Github_DeleteBranchProtectionRulePayload?: Github_DeleteBranchProtectionRulePayloadResolvers<ContextType>;
  Github_DeleteDeploymentPayload?: Github_DeleteDeploymentPayloadResolvers<ContextType>;
  Github_DeleteDiscussionCommentPayload?: Github_DeleteDiscussionCommentPayloadResolvers<ContextType>;
  Github_DeleteDiscussionPayload?: Github_DeleteDiscussionPayloadResolvers<ContextType>;
  Github_DeleteEnvironmentPayload?: Github_DeleteEnvironmentPayloadResolvers<ContextType>;
  Github_DeleteIpAllowListEntryPayload?: Github_DeleteIpAllowListEntryPayloadResolvers<ContextType>;
  Github_DeleteIssueCommentPayload?: Github_DeleteIssueCommentPayloadResolvers<ContextType>;
  Github_DeleteIssuePayload?: Github_DeleteIssuePayloadResolvers<ContextType>;
  Github_DeleteLabelPayload?: Github_DeleteLabelPayloadResolvers<ContextType>;
  Github_DeleteLinkedBranchPayload?: Github_DeleteLinkedBranchPayloadResolvers<ContextType>;
  Github_DeletePackageVersionPayload?: Github_DeletePackageVersionPayloadResolvers<ContextType>;
  Github_DeleteProjectCardPayload?: Github_DeleteProjectCardPayloadResolvers<ContextType>;
  Github_DeleteProjectColumnPayload?: Github_DeleteProjectColumnPayloadResolvers<ContextType>;
  Github_DeleteProjectPayload?: Github_DeleteProjectPayloadResolvers<ContextType>;
  Github_DeleteProjectV2ItemPayload?: Github_DeleteProjectV2ItemPayloadResolvers<ContextType>;
  Github_DeleteProjectV2Payload?: Github_DeleteProjectV2PayloadResolvers<ContextType>;
  Github_DeletePullRequestReviewCommentPayload?: Github_DeletePullRequestReviewCommentPayloadResolvers<ContextType>;
  Github_DeletePullRequestReviewPayload?: Github_DeletePullRequestReviewPayloadResolvers<ContextType>;
  Github_DeleteRefPayload?: Github_DeleteRefPayloadResolvers<ContextType>;
  Github_DeleteTeamDiscussionCommentPayload?: Github_DeleteTeamDiscussionCommentPayloadResolvers<ContextType>;
  Github_DeleteTeamDiscussionPayload?: Github_DeleteTeamDiscussionPayloadResolvers<ContextType>;
  Github_DeleteVerifiableDomainPayload?: Github_DeleteVerifiableDomainPayloadResolvers<ContextType>;
  Github_DemilestonedEvent?: Github_DemilestonedEventResolvers<ContextType>;
  Github_DependabotUpdate?: Github_DependabotUpdateResolvers<ContextType>;
  Github_DependabotUpdateError?: Github_DependabotUpdateErrorResolvers<ContextType>;
  Github_DependencyGraphDependency?: Github_DependencyGraphDependencyResolvers<ContextType>;
  Github_DependencyGraphDependencyConnection?: Github_DependencyGraphDependencyConnectionResolvers<ContextType>;
  Github_DependencyGraphDependencyEdge?: Github_DependencyGraphDependencyEdgeResolvers<ContextType>;
  Github_DependencyGraphManifest?: Github_DependencyGraphManifestResolvers<ContextType>;
  Github_DependencyGraphManifestConnection?: Github_DependencyGraphManifestConnectionResolvers<ContextType>;
  Github_DependencyGraphManifestEdge?: Github_DependencyGraphManifestEdgeResolvers<ContextType>;
  Github_DeployKey?: Github_DeployKeyResolvers<ContextType>;
  Github_DeployKeyConnection?: Github_DeployKeyConnectionResolvers<ContextType>;
  Github_DeployKeyEdge?: Github_DeployKeyEdgeResolvers<ContextType>;
  Github_DeployedEvent?: Github_DeployedEventResolvers<ContextType>;
  Github_Deployment?: Github_DeploymentResolvers<ContextType>;
  Github_DeploymentConnection?: Github_DeploymentConnectionResolvers<ContextType>;
  Github_DeploymentEdge?: Github_DeploymentEdgeResolvers<ContextType>;
  Github_DeploymentEnvironmentChangedEvent?: Github_DeploymentEnvironmentChangedEventResolvers<ContextType>;
  Github_DeploymentProtectionRule?: Github_DeploymentProtectionRuleResolvers<ContextType>;
  Github_DeploymentProtectionRuleConnection?: Github_DeploymentProtectionRuleConnectionResolvers<ContextType>;
  Github_DeploymentProtectionRuleEdge?: Github_DeploymentProtectionRuleEdgeResolvers<ContextType>;
  Github_DeploymentRequest?: Github_DeploymentRequestResolvers<ContextType>;
  Github_DeploymentRequestConnection?: Github_DeploymentRequestConnectionResolvers<ContextType>;
  Github_DeploymentRequestEdge?: Github_DeploymentRequestEdgeResolvers<ContextType>;
  Github_DeploymentReview?: Github_DeploymentReviewResolvers<ContextType>;
  Github_DeploymentReviewConnection?: Github_DeploymentReviewConnectionResolvers<ContextType>;
  Github_DeploymentReviewEdge?: Github_DeploymentReviewEdgeResolvers<ContextType>;
  Github_DeploymentReviewer?: Github_DeploymentReviewerResolvers<ContextType>;
  Github_DeploymentReviewerConnection?: Github_DeploymentReviewerConnectionResolvers<ContextType>;
  Github_DeploymentReviewerEdge?: Github_DeploymentReviewerEdgeResolvers<ContextType>;
  Github_DeploymentStatus?: Github_DeploymentStatusResolvers<ContextType>;
  Github_DeploymentStatusConnection?: Github_DeploymentStatusConnectionResolvers<ContextType>;
  Github_DeploymentStatusEdge?: Github_DeploymentStatusEdgeResolvers<ContextType>;
  Github_DisablePullRequestAutoMergePayload?: Github_DisablePullRequestAutoMergePayloadResolvers<ContextType>;
  Github_DisconnectedEvent?: Github_DisconnectedEventResolvers<ContextType>;
  Github_Discussion?: Github_DiscussionResolvers<ContextType>;
  Github_DiscussionCategory?: Github_DiscussionCategoryResolvers<ContextType>;
  Github_DiscussionCategoryConnection?: Github_DiscussionCategoryConnectionResolvers<ContextType>;
  Github_DiscussionCategoryEdge?: Github_DiscussionCategoryEdgeResolvers<ContextType>;
  Github_DiscussionComment?: Github_DiscussionCommentResolvers<ContextType>;
  Github_DiscussionCommentConnection?: Github_DiscussionCommentConnectionResolvers<ContextType>;
  Github_DiscussionCommentEdge?: Github_DiscussionCommentEdgeResolvers<ContextType>;
  Github_DiscussionConnection?: Github_DiscussionConnectionResolvers<ContextType>;
  Github_DiscussionEdge?: Github_DiscussionEdgeResolvers<ContextType>;
  Github_DiscussionPoll?: Github_DiscussionPollResolvers<ContextType>;
  Github_DiscussionPollOption?: Github_DiscussionPollOptionResolvers<ContextType>;
  Github_DiscussionPollOptionConnection?: Github_DiscussionPollOptionConnectionResolvers<ContextType>;
  Github_DiscussionPollOptionEdge?: Github_DiscussionPollOptionEdgeResolvers<ContextType>;
  Github_DismissPullRequestReviewPayload?: Github_DismissPullRequestReviewPayloadResolvers<ContextType>;
  Github_DismissRepositoryVulnerabilityAlertPayload?: Github_DismissRepositoryVulnerabilityAlertPayloadResolvers<ContextType>;
  Github_DraftIssue?: Github_DraftIssueResolvers<ContextType>;
  Github_EnablePullRequestAutoMergePayload?: Github_EnablePullRequestAutoMergePayloadResolvers<ContextType>;
  Github_Enterprise?: Github_EnterpriseResolvers<ContextType>;
  Github_EnterpriseAdministratorConnection?: Github_EnterpriseAdministratorConnectionResolvers<ContextType>;
  Github_EnterpriseAdministratorEdge?: Github_EnterpriseAdministratorEdgeResolvers<ContextType>;
  Github_EnterpriseAdministratorInvitation?: Github_EnterpriseAdministratorInvitationResolvers<ContextType>;
  Github_EnterpriseAdministratorInvitationConnection?: Github_EnterpriseAdministratorInvitationConnectionResolvers<ContextType>;
  Github_EnterpriseAdministratorInvitationEdge?: Github_EnterpriseAdministratorInvitationEdgeResolvers<ContextType>;
  Github_EnterpriseAuditEntryData?: Github_EnterpriseAuditEntryDataResolvers<ContextType>;
  Github_EnterpriseBillingInfo?: Github_EnterpriseBillingInfoResolvers<ContextType>;
  Github_EnterpriseFailedInvitationConnection?: Github_EnterpriseFailedInvitationConnectionResolvers<ContextType>;
  Github_EnterpriseFailedInvitationEdge?: Github_EnterpriseFailedInvitationEdgeResolvers<ContextType>;
  Github_EnterpriseIdentityProvider?: Github_EnterpriseIdentityProviderResolvers<ContextType>;
  Github_EnterpriseMember?: Github_EnterpriseMemberResolvers<ContextType>;
  Github_EnterpriseMemberConnection?: Github_EnterpriseMemberConnectionResolvers<ContextType>;
  Github_EnterpriseMemberEdge?: Github_EnterpriseMemberEdgeResolvers<ContextType>;
  Github_EnterpriseOrganizationMembershipConnection?: Github_EnterpriseOrganizationMembershipConnectionResolvers<ContextType>;
  Github_EnterpriseOrganizationMembershipEdge?: Github_EnterpriseOrganizationMembershipEdgeResolvers<ContextType>;
  Github_EnterpriseOutsideCollaboratorConnection?: Github_EnterpriseOutsideCollaboratorConnectionResolvers<ContextType>;
  Github_EnterpriseOutsideCollaboratorEdge?: Github_EnterpriseOutsideCollaboratorEdgeResolvers<ContextType>;
  Github_EnterpriseOwnerInfo?: Github_EnterpriseOwnerInfoResolvers<ContextType>;
  Github_EnterprisePendingMemberInvitationConnection?: Github_EnterprisePendingMemberInvitationConnectionResolvers<ContextType>;
  Github_EnterprisePendingMemberInvitationEdge?: Github_EnterprisePendingMemberInvitationEdgeResolvers<ContextType>;
  Github_EnterpriseRepositoryInfo?: Github_EnterpriseRepositoryInfoResolvers<ContextType>;
  Github_EnterpriseRepositoryInfoConnection?: Github_EnterpriseRepositoryInfoConnectionResolvers<ContextType>;
  Github_EnterpriseRepositoryInfoEdge?: Github_EnterpriseRepositoryInfoEdgeResolvers<ContextType>;
  Github_EnterpriseServerInstallation?: Github_EnterpriseServerInstallationResolvers<ContextType>;
  Github_EnterpriseServerInstallationConnection?: Github_EnterpriseServerInstallationConnectionResolvers<ContextType>;
  Github_EnterpriseServerInstallationEdge?: Github_EnterpriseServerInstallationEdgeResolvers<ContextType>;
  Github_EnterpriseServerUserAccount?: Github_EnterpriseServerUserAccountResolvers<ContextType>;
  Github_EnterpriseServerUserAccountConnection?: Github_EnterpriseServerUserAccountConnectionResolvers<ContextType>;
  Github_EnterpriseServerUserAccountEdge?: Github_EnterpriseServerUserAccountEdgeResolvers<ContextType>;
  Github_EnterpriseServerUserAccountEmail?: Github_EnterpriseServerUserAccountEmailResolvers<ContextType>;
  Github_EnterpriseServerUserAccountEmailConnection?: Github_EnterpriseServerUserAccountEmailConnectionResolvers<ContextType>;
  Github_EnterpriseServerUserAccountEmailEdge?: Github_EnterpriseServerUserAccountEmailEdgeResolvers<ContextType>;
  Github_EnterpriseServerUserAccountsUpload?: Github_EnterpriseServerUserAccountsUploadResolvers<ContextType>;
  Github_EnterpriseServerUserAccountsUploadConnection?: Github_EnterpriseServerUserAccountsUploadConnectionResolvers<ContextType>;
  Github_EnterpriseServerUserAccountsUploadEdge?: Github_EnterpriseServerUserAccountsUploadEdgeResolvers<ContextType>;
  Github_EnterpriseUserAccount?: Github_EnterpriseUserAccountResolvers<ContextType>;
  Github_Environment?: Github_EnvironmentResolvers<ContextType>;
  Github_EnvironmentConnection?: Github_EnvironmentConnectionResolvers<ContextType>;
  Github_EnvironmentEdge?: Github_EnvironmentEdgeResolvers<ContextType>;
  Github_ExternalIdentity?: Github_ExternalIdentityResolvers<ContextType>;
  Github_ExternalIdentityAttribute?: Github_ExternalIdentityAttributeResolvers<ContextType>;
  Github_ExternalIdentityConnection?: Github_ExternalIdentityConnectionResolvers<ContextType>;
  Github_ExternalIdentityEdge?: Github_ExternalIdentityEdgeResolvers<ContextType>;
  Github_ExternalIdentitySamlAttributes?: Github_ExternalIdentitySamlAttributesResolvers<ContextType>;
  Github_ExternalIdentityScimAttributes?: Github_ExternalIdentityScimAttributesResolvers<ContextType>;
  Github_FollowOrganizationPayload?: Github_FollowOrganizationPayloadResolvers<ContextType>;
  Github_FollowUserPayload?: Github_FollowUserPayloadResolvers<ContextType>;
  Github_FollowerConnection?: Github_FollowerConnectionResolvers<ContextType>;
  Github_FollowingConnection?: Github_FollowingConnectionResolvers<ContextType>;
  Github_FundingLink?: Github_FundingLinkResolvers<ContextType>;
  Github_GenericHovercardContext?: Github_GenericHovercardContextResolvers<ContextType>;
  Github_Gist?: Github_GistResolvers<ContextType>;
  Github_GistComment?: Github_GistCommentResolvers<ContextType>;
  Github_GistCommentConnection?: Github_GistCommentConnectionResolvers<ContextType>;
  Github_GistCommentEdge?: Github_GistCommentEdgeResolvers<ContextType>;
  Github_GistConnection?: Github_GistConnectionResolvers<ContextType>;
  Github_GistEdge?: Github_GistEdgeResolvers<ContextType>;
  Github_GistFile?: Github_GistFileResolvers<ContextType>;
  Github_GitActor?: Github_GitActorResolvers<ContextType>;
  Github_GitActorConnection?: Github_GitActorConnectionResolvers<ContextType>;
  Github_GitActorEdge?: Github_GitActorEdgeResolvers<ContextType>;
  Github_GitHubMetadata?: Github_GitHubMetadataResolvers<ContextType>;
  Github_GitObject?: Github_GitObjectResolvers<ContextType>;
  Github_GitObjectID?: GraphQLScalarType;
  Github_GitRefname?: GraphQLScalarType;
  Github_GitSSHRemote?: GraphQLScalarType;
  Github_GitSignature?: Github_GitSignatureResolvers<ContextType>;
  Github_GitTimestamp?: GraphQLScalarType;
  Github_GpgSignature?: Github_GpgSignatureResolvers<ContextType>;
  Github_GrantEnterpriseOrganizationsMigratorRolePayload?: Github_GrantEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  Github_GrantMigratorRolePayload?: Github_GrantMigratorRolePayloadResolvers<ContextType>;
  Github_HTML?: GraphQLScalarType;
  Github_HeadRefDeletedEvent?: Github_HeadRefDeletedEventResolvers<ContextType>;
  Github_HeadRefForcePushedEvent?: Github_HeadRefForcePushedEventResolvers<ContextType>;
  Github_HeadRefRestoredEvent?: Github_HeadRefRestoredEventResolvers<ContextType>;
  Github_Hovercard?: Github_HovercardResolvers<ContextType>;
  Github_HovercardContext?: Github_HovercardContextResolvers<ContextType>;
  Github_ImportProjectPayload?: Github_ImportProjectPayloadResolvers<ContextType>;
  Github_InviteEnterpriseAdminPayload?: Github_InviteEnterpriseAdminPayloadResolvers<ContextType>;
  Github_IpAllowListEntry?: Github_IpAllowListEntryResolvers<ContextType>;
  Github_IpAllowListEntryConnection?: Github_IpAllowListEntryConnectionResolvers<ContextType>;
  Github_IpAllowListEntryEdge?: Github_IpAllowListEntryEdgeResolvers<ContextType>;
  Github_IpAllowListOwner?: Github_IpAllowListOwnerResolvers<ContextType>;
  Github_Issue?: Github_IssueResolvers<ContextType>;
  Github_IssueComment?: Github_IssueCommentResolvers<ContextType>;
  Github_IssueCommentConnection?: Github_IssueCommentConnectionResolvers<ContextType>;
  Github_IssueCommentEdge?: Github_IssueCommentEdgeResolvers<ContextType>;
  Github_IssueConnection?: Github_IssueConnectionResolvers<ContextType>;
  Github_IssueContributionsByRepository?: Github_IssueContributionsByRepositoryResolvers<ContextType>;
  Github_IssueEdge?: Github_IssueEdgeResolvers<ContextType>;
  Github_IssueOrPullRequest?: Github_IssueOrPullRequestResolvers<ContextType>;
  Github_IssueTemplate?: Github_IssueTemplateResolvers<ContextType>;
  Github_IssueTimelineConnection?: Github_IssueTimelineConnectionResolvers<ContextType>;
  Github_IssueTimelineItem?: Github_IssueTimelineItemResolvers<ContextType>;
  Github_IssueTimelineItemEdge?: Github_IssueTimelineItemEdgeResolvers<ContextType>;
  Github_IssueTimelineItems?: Github_IssueTimelineItemsResolvers<ContextType>;
  Github_IssueTimelineItemsConnection?: Github_IssueTimelineItemsConnectionResolvers<ContextType>;
  Github_IssueTimelineItemsEdge?: Github_IssueTimelineItemsEdgeResolvers<ContextType>;
  Github_JoinedGitHubContribution?: Github_JoinedGitHubContributionResolvers<ContextType>;
  Github_Label?: Github_LabelResolvers<ContextType>;
  Github_LabelConnection?: Github_LabelConnectionResolvers<ContextType>;
  Github_LabelEdge?: Github_LabelEdgeResolvers<ContextType>;
  Github_Labelable?: Github_LabelableResolvers<ContextType>;
  Github_LabeledEvent?: Github_LabeledEventResolvers<ContextType>;
  Github_Language?: Github_LanguageResolvers<ContextType>;
  Github_LanguageConnection?: Github_LanguageConnectionResolvers<ContextType>;
  Github_LanguageEdge?: Github_LanguageEdgeResolvers<ContextType>;
  Github_License?: Github_LicenseResolvers<ContextType>;
  Github_LicenseRule?: Github_LicenseRuleResolvers<ContextType>;
  Github_LinkProjectV2ToRepositoryPayload?: Github_LinkProjectV2ToRepositoryPayloadResolvers<ContextType>;
  Github_LinkProjectV2ToTeamPayload?: Github_LinkProjectV2ToTeamPayloadResolvers<ContextType>;
  Github_LinkRepositoryToProjectPayload?: Github_LinkRepositoryToProjectPayloadResolvers<ContextType>;
  Github_LinkedBranch?: Github_LinkedBranchResolvers<ContextType>;
  Github_LinkedBranchConnection?: Github_LinkedBranchConnectionResolvers<ContextType>;
  Github_LinkedBranchEdge?: Github_LinkedBranchEdgeResolvers<ContextType>;
  Github_LockLockablePayload?: Github_LockLockablePayloadResolvers<ContextType>;
  Github_Lockable?: Github_LockableResolvers<ContextType>;
  Github_LockedEvent?: Github_LockedEventResolvers<ContextType>;
  Github_Mannequin?: Github_MannequinResolvers<ContextType>;
  Github_MannequinConnection?: Github_MannequinConnectionResolvers<ContextType>;
  Github_MannequinEdge?: Github_MannequinEdgeResolvers<ContextType>;
  Github_MarkDiscussionCommentAsAnswerPayload?: Github_MarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  Github_MarkFileAsViewedPayload?: Github_MarkFileAsViewedPayloadResolvers<ContextType>;
  Github_MarkPullRequestReadyForReviewPayload?: Github_MarkPullRequestReadyForReviewPayloadResolvers<ContextType>;
  Github_MarkedAsDuplicateEvent?: Github_MarkedAsDuplicateEventResolvers<ContextType>;
  Github_MarketplaceCategory?: Github_MarketplaceCategoryResolvers<ContextType>;
  Github_MarketplaceListing?: Github_MarketplaceListingResolvers<ContextType>;
  Github_MarketplaceListingConnection?: Github_MarketplaceListingConnectionResolvers<ContextType>;
  Github_MarketplaceListingEdge?: Github_MarketplaceListingEdgeResolvers<ContextType>;
  Github_MemberStatusable?: Github_MemberStatusableResolvers<ContextType>;
  Github_MembersCanDeleteReposClearAuditEntry?: Github_MembersCanDeleteReposClearAuditEntryResolvers<ContextType>;
  Github_MembersCanDeleteReposDisableAuditEntry?: Github_MembersCanDeleteReposDisableAuditEntryResolvers<ContextType>;
  Github_MembersCanDeleteReposEnableAuditEntry?: Github_MembersCanDeleteReposEnableAuditEntryResolvers<ContextType>;
  Github_MentionedEvent?: Github_MentionedEventResolvers<ContextType>;
  Github_MergeBranchPayload?: Github_MergeBranchPayloadResolvers<ContextType>;
  Github_MergePullRequestPayload?: Github_MergePullRequestPayloadResolvers<ContextType>;
  Github_MergedEvent?: Github_MergedEventResolvers<ContextType>;
  Github_Migration?: Github_MigrationResolvers<ContextType>;
  Github_MigrationSource?: Github_MigrationSourceResolvers<ContextType>;
  Github_Milestone?: Github_MilestoneResolvers<ContextType>;
  Github_MilestoneConnection?: Github_MilestoneConnectionResolvers<ContextType>;
  Github_MilestoneEdge?: Github_MilestoneEdgeResolvers<ContextType>;
  Github_MilestoneItem?: Github_MilestoneItemResolvers<ContextType>;
  Github_MilestonedEvent?: Github_MilestonedEventResolvers<ContextType>;
  Github_Minimizable?: Github_MinimizableResolvers<ContextType>;
  Github_MinimizeCommentPayload?: Github_MinimizeCommentPayloadResolvers<ContextType>;
  Github_MoveProjectCardPayload?: Github_MoveProjectCardPayloadResolvers<ContextType>;
  Github_MoveProjectColumnPayload?: Github_MoveProjectColumnPayloadResolvers<ContextType>;
  Github_MovedColumnsInProjectEvent?: Github_MovedColumnsInProjectEventResolvers<ContextType>;
  Github_Node?: Github_NodeResolvers<ContextType>;
  Github_OIDCProvider?: Github_OIDCProviderResolvers<ContextType>;
  Github_OauthApplicationAuditEntryData?: Github_OauthApplicationAuditEntryDataResolvers<ContextType>;
  Github_OauthApplicationCreateAuditEntry?: Github_OauthApplicationCreateAuditEntryResolvers<ContextType>;
  Github_OrgAddBillingManagerAuditEntry?: Github_OrgAddBillingManagerAuditEntryResolvers<ContextType>;
  Github_OrgAddMemberAuditEntry?: Github_OrgAddMemberAuditEntryResolvers<ContextType>;
  Github_OrgBlockUserAuditEntry?: Github_OrgBlockUserAuditEntryResolvers<ContextType>;
  Github_OrgConfigDisableCollaboratorsOnlyAuditEntry?: Github_OrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  Github_OrgConfigEnableCollaboratorsOnlyAuditEntry?: Github_OrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  Github_OrgCreateAuditEntry?: Github_OrgCreateAuditEntryResolvers<ContextType>;
  Github_OrgDisableOauthAppRestrictionsAuditEntry?: Github_OrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  Github_OrgDisableSamlAuditEntry?: Github_OrgDisableSamlAuditEntryResolvers<ContextType>;
  Github_OrgDisableTwoFactorRequirementAuditEntry?: Github_OrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  Github_OrgEnableOauthAppRestrictionsAuditEntry?: Github_OrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  Github_OrgEnableSamlAuditEntry?: Github_OrgEnableSamlAuditEntryResolvers<ContextType>;
  Github_OrgEnableTwoFactorRequirementAuditEntry?: Github_OrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  Github_OrgInviteMemberAuditEntry?: Github_OrgInviteMemberAuditEntryResolvers<ContextType>;
  Github_OrgInviteToBusinessAuditEntry?: Github_OrgInviteToBusinessAuditEntryResolvers<ContextType>;
  Github_OrgOauthAppAccessApprovedAuditEntry?: Github_OrgOauthAppAccessApprovedAuditEntryResolvers<ContextType>;
  Github_OrgOauthAppAccessDeniedAuditEntry?: Github_OrgOauthAppAccessDeniedAuditEntryResolvers<ContextType>;
  Github_OrgOauthAppAccessRequestedAuditEntry?: Github_OrgOauthAppAccessRequestedAuditEntryResolvers<ContextType>;
  Github_OrgRemoveBillingManagerAuditEntry?: Github_OrgRemoveBillingManagerAuditEntryResolvers<ContextType>;
  Github_OrgRemoveMemberAuditEntry?: Github_OrgRemoveMemberAuditEntryResolvers<ContextType>;
  Github_OrgRemoveOutsideCollaboratorAuditEntry?: Github_OrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType>;
  Github_OrgRestoreMemberAuditEntry?: Github_OrgRestoreMemberAuditEntryResolvers<ContextType>;
  Github_OrgRestoreMemberAuditEntryMembership?: Github_OrgRestoreMemberAuditEntryMembershipResolvers<ContextType>;
  Github_OrgRestoreMemberMembershipOrganizationAuditEntryData?: Github_OrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType>;
  Github_OrgRestoreMemberMembershipRepositoryAuditEntryData?: Github_OrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType>;
  Github_OrgRestoreMemberMembershipTeamAuditEntryData?: Github_OrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType>;
  Github_OrgUnblockUserAuditEntry?: Github_OrgUnblockUserAuditEntryResolvers<ContextType>;
  Github_OrgUpdateDefaultRepositoryPermissionAuditEntry?: Github_OrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType>;
  Github_OrgUpdateMemberAuditEntry?: Github_OrgUpdateMemberAuditEntryResolvers<ContextType>;
  Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry?: Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType>;
  Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry?: Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType>;
  Github_Organization?: Github_OrganizationResolvers<ContextType>;
  Github_OrganizationAuditEntry?: Github_OrganizationAuditEntryResolvers<ContextType>;
  Github_OrganizationAuditEntryConnection?: Github_OrganizationAuditEntryConnectionResolvers<ContextType>;
  Github_OrganizationAuditEntryData?: Github_OrganizationAuditEntryDataResolvers<ContextType>;
  Github_OrganizationAuditEntryEdge?: Github_OrganizationAuditEntryEdgeResolvers<ContextType>;
  Github_OrganizationConnection?: Github_OrganizationConnectionResolvers<ContextType>;
  Github_OrganizationEdge?: Github_OrganizationEdgeResolvers<ContextType>;
  Github_OrganizationEnterpriseOwnerConnection?: Github_OrganizationEnterpriseOwnerConnectionResolvers<ContextType>;
  Github_OrganizationEnterpriseOwnerEdge?: Github_OrganizationEnterpriseOwnerEdgeResolvers<ContextType>;
  Github_OrganizationIdentityProvider?: Github_OrganizationIdentityProviderResolvers<ContextType>;
  Github_OrganizationInvitation?: Github_OrganizationInvitationResolvers<ContextType>;
  Github_OrganizationInvitationConnection?: Github_OrganizationInvitationConnectionResolvers<ContextType>;
  Github_OrganizationInvitationEdge?: Github_OrganizationInvitationEdgeResolvers<ContextType>;
  Github_OrganizationMemberConnection?: Github_OrganizationMemberConnectionResolvers<ContextType>;
  Github_OrganizationMemberEdge?: Github_OrganizationMemberEdgeResolvers<ContextType>;
  Github_OrganizationMigration?: Github_OrganizationMigrationResolvers<ContextType>;
  Github_OrganizationOrUser?: Github_OrganizationOrUserResolvers<ContextType>;
  Github_OrganizationTeamsHovercardContext?: Github_OrganizationTeamsHovercardContextResolvers<ContextType>;
  Github_OrganizationsHovercardContext?: Github_OrganizationsHovercardContextResolvers<ContextType>;
  Github_Package?: Github_PackageResolvers<ContextType>;
  Github_PackageConnection?: Github_PackageConnectionResolvers<ContextType>;
  Github_PackageEdge?: Github_PackageEdgeResolvers<ContextType>;
  Github_PackageFile?: Github_PackageFileResolvers<ContextType>;
  Github_PackageFileConnection?: Github_PackageFileConnectionResolvers<ContextType>;
  Github_PackageFileEdge?: Github_PackageFileEdgeResolvers<ContextType>;
  Github_PackageOwner?: Github_PackageOwnerResolvers<ContextType>;
  Github_PackageStatistics?: Github_PackageStatisticsResolvers<ContextType>;
  Github_PackageTag?: Github_PackageTagResolvers<ContextType>;
  Github_PackageVersion?: Github_PackageVersionResolvers<ContextType>;
  Github_PackageVersionConnection?: Github_PackageVersionConnectionResolvers<ContextType>;
  Github_PackageVersionEdge?: Github_PackageVersionEdgeResolvers<ContextType>;
  Github_PackageVersionStatistics?: Github_PackageVersionStatisticsResolvers<ContextType>;
  Github_PageInfo?: Github_PageInfoResolvers<ContextType>;
  Github_PermissionGranter?: Github_PermissionGranterResolvers<ContextType>;
  Github_PermissionSource?: Github_PermissionSourceResolvers<ContextType>;
  Github_PinIssuePayload?: Github_PinIssuePayloadResolvers<ContextType>;
  Github_PinnableItem?: Github_PinnableItemResolvers<ContextType>;
  Github_PinnableItemConnection?: Github_PinnableItemConnectionResolvers<ContextType>;
  Github_PinnableItemEdge?: Github_PinnableItemEdgeResolvers<ContextType>;
  Github_PinnedDiscussion?: Github_PinnedDiscussionResolvers<ContextType>;
  Github_PinnedDiscussionConnection?: Github_PinnedDiscussionConnectionResolvers<ContextType>;
  Github_PinnedDiscussionEdge?: Github_PinnedDiscussionEdgeResolvers<ContextType>;
  Github_PinnedEvent?: Github_PinnedEventResolvers<ContextType>;
  Github_PinnedIssue?: Github_PinnedIssueResolvers<ContextType>;
  Github_PinnedIssueConnection?: Github_PinnedIssueConnectionResolvers<ContextType>;
  Github_PinnedIssueEdge?: Github_PinnedIssueEdgeResolvers<ContextType>;
  Github_PreciseDateTime?: GraphQLScalarType;
  Github_PrivateRepositoryForkingDisableAuditEntry?: Github_PrivateRepositoryForkingDisableAuditEntryResolvers<ContextType>;
  Github_PrivateRepositoryForkingEnableAuditEntry?: Github_PrivateRepositoryForkingEnableAuditEntryResolvers<ContextType>;
  Github_ProfileItemShowcase?: Github_ProfileItemShowcaseResolvers<ContextType>;
  Github_ProfileOwner?: Github_ProfileOwnerResolvers<ContextType>;
  Github_Project?: Github_ProjectResolvers<ContextType>;
  Github_ProjectCard?: Github_ProjectCardResolvers<ContextType>;
  Github_ProjectCardConnection?: Github_ProjectCardConnectionResolvers<ContextType>;
  Github_ProjectCardEdge?: Github_ProjectCardEdgeResolvers<ContextType>;
  Github_ProjectCardItem?: Github_ProjectCardItemResolvers<ContextType>;
  Github_ProjectColumn?: Github_ProjectColumnResolvers<ContextType>;
  Github_ProjectColumnConnection?: Github_ProjectColumnConnectionResolvers<ContextType>;
  Github_ProjectColumnEdge?: Github_ProjectColumnEdgeResolvers<ContextType>;
  Github_ProjectConnection?: Github_ProjectConnectionResolvers<ContextType>;
  Github_ProjectEdge?: Github_ProjectEdgeResolvers<ContextType>;
  Github_ProjectOwner?: Github_ProjectOwnerResolvers<ContextType>;
  Github_ProjectProgress?: Github_ProjectProgressResolvers<ContextType>;
  Github_ProjectV2?: Github_ProjectV2Resolvers<ContextType>;
  Github_ProjectV2Connection?: Github_ProjectV2ConnectionResolvers<ContextType>;
  Github_ProjectV2Edge?: Github_ProjectV2EdgeResolvers<ContextType>;
  Github_ProjectV2Field?: Github_ProjectV2FieldResolvers<ContextType>;
  Github_ProjectV2FieldCommon?: Github_ProjectV2FieldCommonResolvers<ContextType>;
  Github_ProjectV2FieldConfiguration?: Github_ProjectV2FieldConfigurationResolvers<ContextType>;
  Github_ProjectV2FieldConfigurationConnection?: Github_ProjectV2FieldConfigurationConnectionResolvers<ContextType>;
  Github_ProjectV2FieldConfigurationEdge?: Github_ProjectV2FieldConfigurationEdgeResolvers<ContextType>;
  Github_ProjectV2FieldConnection?: Github_ProjectV2FieldConnectionResolvers<ContextType>;
  Github_ProjectV2FieldEdge?: Github_ProjectV2FieldEdgeResolvers<ContextType>;
  Github_ProjectV2Item?: Github_ProjectV2ItemResolvers<ContextType>;
  Github_ProjectV2ItemConnection?: Github_ProjectV2ItemConnectionResolvers<ContextType>;
  Github_ProjectV2ItemContent?: Github_ProjectV2ItemContentResolvers<ContextType>;
  Github_ProjectV2ItemEdge?: Github_ProjectV2ItemEdgeResolvers<ContextType>;
  Github_ProjectV2ItemFieldDateValue?: Github_ProjectV2ItemFieldDateValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldIterationValue?: Github_ProjectV2ItemFieldIterationValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldLabelValue?: Github_ProjectV2ItemFieldLabelValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldMilestoneValue?: Github_ProjectV2ItemFieldMilestoneValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldNumberValue?: Github_ProjectV2ItemFieldNumberValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldPullRequestValue?: Github_ProjectV2ItemFieldPullRequestValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldRepositoryValue?: Github_ProjectV2ItemFieldRepositoryValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldReviewerValue?: Github_ProjectV2ItemFieldReviewerValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldSingleSelectValue?: Github_ProjectV2ItemFieldSingleSelectValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldTextValue?: Github_ProjectV2ItemFieldTextValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldUserValue?: Github_ProjectV2ItemFieldUserValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldValue?: Github_ProjectV2ItemFieldValueResolvers<ContextType>;
  Github_ProjectV2ItemFieldValueCommon?: Github_ProjectV2ItemFieldValueCommonResolvers<ContextType>;
  Github_ProjectV2ItemFieldValueConnection?: Github_ProjectV2ItemFieldValueConnectionResolvers<ContextType>;
  Github_ProjectV2ItemFieldValueEdge?: Github_ProjectV2ItemFieldValueEdgeResolvers<ContextType>;
  Github_ProjectV2IterationField?: Github_ProjectV2IterationFieldResolvers<ContextType>;
  Github_ProjectV2IterationFieldConfiguration?: Github_ProjectV2IterationFieldConfigurationResolvers<ContextType>;
  Github_ProjectV2IterationFieldIteration?: Github_ProjectV2IterationFieldIterationResolvers<ContextType>;
  Github_ProjectV2Owner?: Github_ProjectV2OwnerResolvers<ContextType>;
  Github_ProjectV2Recent?: Github_ProjectV2RecentResolvers<ContextType>;
  Github_ProjectV2SingleSelectField?: Github_ProjectV2SingleSelectFieldResolvers<ContextType>;
  Github_ProjectV2SingleSelectFieldOption?: Github_ProjectV2SingleSelectFieldOptionResolvers<ContextType>;
  Github_ProjectV2SortBy?: Github_ProjectV2SortByResolvers<ContextType>;
  Github_ProjectV2SortByConnection?: Github_ProjectV2SortByConnectionResolvers<ContextType>;
  Github_ProjectV2SortByEdge?: Github_ProjectV2SortByEdgeResolvers<ContextType>;
  Github_ProjectV2SortByField?: Github_ProjectV2SortByFieldResolvers<ContextType>;
  Github_ProjectV2SortByFieldConnection?: Github_ProjectV2SortByFieldConnectionResolvers<ContextType>;
  Github_ProjectV2SortByFieldEdge?: Github_ProjectV2SortByFieldEdgeResolvers<ContextType>;
  Github_ProjectV2View?: Github_ProjectV2ViewResolvers<ContextType>;
  Github_ProjectV2ViewConnection?: Github_ProjectV2ViewConnectionResolvers<ContextType>;
  Github_ProjectV2ViewEdge?: Github_ProjectV2ViewEdgeResolvers<ContextType>;
  Github_ProjectV2Workflow?: Github_ProjectV2WorkflowResolvers<ContextType>;
  Github_ProjectV2WorkflowConnection?: Github_ProjectV2WorkflowConnectionResolvers<ContextType>;
  Github_ProjectV2WorkflowEdge?: Github_ProjectV2WorkflowEdgeResolvers<ContextType>;
  Github_PublicKey?: Github_PublicKeyResolvers<ContextType>;
  Github_PublicKeyConnection?: Github_PublicKeyConnectionResolvers<ContextType>;
  Github_PublicKeyEdge?: Github_PublicKeyEdgeResolvers<ContextType>;
  Github_PublishSponsorsTierPayload?: Github_PublishSponsorsTierPayloadResolvers<ContextType>;
  Github_PullRequest?: Github_PullRequestResolvers<ContextType>;
  Github_PullRequestChangedFile?: Github_PullRequestChangedFileResolvers<ContextType>;
  Github_PullRequestChangedFileConnection?: Github_PullRequestChangedFileConnectionResolvers<ContextType>;
  Github_PullRequestChangedFileEdge?: Github_PullRequestChangedFileEdgeResolvers<ContextType>;
  Github_PullRequestCommit?: Github_PullRequestCommitResolvers<ContextType>;
  Github_PullRequestCommitCommentThread?: Github_PullRequestCommitCommentThreadResolvers<ContextType>;
  Github_PullRequestCommitConnection?: Github_PullRequestCommitConnectionResolvers<ContextType>;
  Github_PullRequestCommitEdge?: Github_PullRequestCommitEdgeResolvers<ContextType>;
  Github_PullRequestConnection?: Github_PullRequestConnectionResolvers<ContextType>;
  Github_PullRequestContributionsByRepository?: Github_PullRequestContributionsByRepositoryResolvers<ContextType>;
  Github_PullRequestEdge?: Github_PullRequestEdgeResolvers<ContextType>;
  Github_PullRequestReview?: Github_PullRequestReviewResolvers<ContextType>;
  Github_PullRequestReviewComment?: Github_PullRequestReviewCommentResolvers<ContextType>;
  Github_PullRequestReviewCommentConnection?: Github_PullRequestReviewCommentConnectionResolvers<ContextType>;
  Github_PullRequestReviewCommentEdge?: Github_PullRequestReviewCommentEdgeResolvers<ContextType>;
  Github_PullRequestReviewConnection?: Github_PullRequestReviewConnectionResolvers<ContextType>;
  Github_PullRequestReviewContributionsByRepository?: Github_PullRequestReviewContributionsByRepositoryResolvers<ContextType>;
  Github_PullRequestReviewEdge?: Github_PullRequestReviewEdgeResolvers<ContextType>;
  Github_PullRequestReviewThread?: Github_PullRequestReviewThreadResolvers<ContextType>;
  Github_PullRequestReviewThreadConnection?: Github_PullRequestReviewThreadConnectionResolvers<ContextType>;
  Github_PullRequestReviewThreadEdge?: Github_PullRequestReviewThreadEdgeResolvers<ContextType>;
  Github_PullRequestRevisionMarker?: Github_PullRequestRevisionMarkerResolvers<ContextType>;
  Github_PullRequestTemplate?: Github_PullRequestTemplateResolvers<ContextType>;
  Github_PullRequestThread?: Github_PullRequestThreadResolvers<ContextType>;
  Github_PullRequestTimelineConnection?: Github_PullRequestTimelineConnectionResolvers<ContextType>;
  Github_PullRequestTimelineItem?: Github_PullRequestTimelineItemResolvers<ContextType>;
  Github_PullRequestTimelineItemEdge?: Github_PullRequestTimelineItemEdgeResolvers<ContextType>;
  Github_PullRequestTimelineItems?: Github_PullRequestTimelineItemsResolvers<ContextType>;
  Github_PullRequestTimelineItemsConnection?: Github_PullRequestTimelineItemsConnectionResolvers<ContextType>;
  Github_PullRequestTimelineItemsEdge?: Github_PullRequestTimelineItemsEdgeResolvers<ContextType>;
  Github_Push?: Github_PushResolvers<ContextType>;
  Github_PushAllowance?: Github_PushAllowanceResolvers<ContextType>;
  Github_PushAllowanceActor?: Github_PushAllowanceActorResolvers<ContextType>;
  Github_PushAllowanceConnection?: Github_PushAllowanceConnectionResolvers<ContextType>;
  Github_PushAllowanceEdge?: Github_PushAllowanceEdgeResolvers<ContextType>;
  Github_RateLimit?: Github_RateLimitResolvers<ContextType>;
  Github_Reactable?: Github_ReactableResolvers<ContextType>;
  Github_ReactingUserConnection?: Github_ReactingUserConnectionResolvers<ContextType>;
  Github_ReactingUserEdge?: Github_ReactingUserEdgeResolvers<ContextType>;
  Github_Reaction?: Github_ReactionResolvers<ContextType>;
  Github_ReactionConnection?: Github_ReactionConnectionResolvers<ContextType>;
  Github_ReactionEdge?: Github_ReactionEdgeResolvers<ContextType>;
  Github_ReactionGroup?: Github_ReactionGroupResolvers<ContextType>;
  Github_Reactor?: Github_ReactorResolvers<ContextType>;
  Github_ReactorConnection?: Github_ReactorConnectionResolvers<ContextType>;
  Github_ReactorEdge?: Github_ReactorEdgeResolvers<ContextType>;
  Github_ReadyForReviewEvent?: Github_ReadyForReviewEventResolvers<ContextType>;
  Github_Ref?: Github_RefResolvers<ContextType>;
  Github_RefConnection?: Github_RefConnectionResolvers<ContextType>;
  Github_RefEdge?: Github_RefEdgeResolvers<ContextType>;
  Github_RefUpdateRule?: Github_RefUpdateRuleResolvers<ContextType>;
  Github_ReferencedEvent?: Github_ReferencedEventResolvers<ContextType>;
  Github_ReferencedSubject?: Github_ReferencedSubjectResolvers<ContextType>;
  Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload?: Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType>;
  Github_RegenerateVerifiableDomainTokenPayload?: Github_RegenerateVerifiableDomainTokenPayloadResolvers<ContextType>;
  Github_RejectDeploymentsPayload?: Github_RejectDeploymentsPayloadResolvers<ContextType>;
  Github_Release?: Github_ReleaseResolvers<ContextType>;
  Github_ReleaseAsset?: Github_ReleaseAssetResolvers<ContextType>;
  Github_ReleaseAssetConnection?: Github_ReleaseAssetConnectionResolvers<ContextType>;
  Github_ReleaseAssetEdge?: Github_ReleaseAssetEdgeResolvers<ContextType>;
  Github_ReleaseConnection?: Github_ReleaseConnectionResolvers<ContextType>;
  Github_ReleaseEdge?: Github_ReleaseEdgeResolvers<ContextType>;
  Github_RemoveAssigneesFromAssignablePayload?: Github_RemoveAssigneesFromAssignablePayloadResolvers<ContextType>;
  Github_RemoveEnterpriseAdminPayload?: Github_RemoveEnterpriseAdminPayloadResolvers<ContextType>;
  Github_RemoveEnterpriseIdentityProviderPayload?: Github_RemoveEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  Github_RemoveEnterpriseMemberPayload?: Github_RemoveEnterpriseMemberPayloadResolvers<ContextType>;
  Github_RemoveEnterpriseOrganizationPayload?: Github_RemoveEnterpriseOrganizationPayloadResolvers<ContextType>;
  Github_RemoveEnterpriseSupportEntitlementPayload?: Github_RemoveEnterpriseSupportEntitlementPayloadResolvers<ContextType>;
  Github_RemoveLabelsFromLabelablePayload?: Github_RemoveLabelsFromLabelablePayloadResolvers<ContextType>;
  Github_RemoveOutsideCollaboratorPayload?: Github_RemoveOutsideCollaboratorPayloadResolvers<ContextType>;
  Github_RemoveReactionPayload?: Github_RemoveReactionPayloadResolvers<ContextType>;
  Github_RemoveStarPayload?: Github_RemoveStarPayloadResolvers<ContextType>;
  Github_RemoveUpvotePayload?: Github_RemoveUpvotePayloadResolvers<ContextType>;
  Github_RemovedFromProjectEvent?: Github_RemovedFromProjectEventResolvers<ContextType>;
  Github_RenamedTitleEvent?: Github_RenamedTitleEventResolvers<ContextType>;
  Github_RenamedTitleSubject?: Github_RenamedTitleSubjectResolvers<ContextType>;
  Github_ReopenIssuePayload?: Github_ReopenIssuePayloadResolvers<ContextType>;
  Github_ReopenPullRequestPayload?: Github_ReopenPullRequestPayloadResolvers<ContextType>;
  Github_ReopenedEvent?: Github_ReopenedEventResolvers<ContextType>;
  Github_RepoAccessAuditEntry?: Github_RepoAccessAuditEntryResolvers<ContextType>;
  Github_RepoAddMemberAuditEntry?: Github_RepoAddMemberAuditEntryResolvers<ContextType>;
  Github_RepoAddTopicAuditEntry?: Github_RepoAddTopicAuditEntryResolvers<ContextType>;
  Github_RepoArchivedAuditEntry?: Github_RepoArchivedAuditEntryResolvers<ContextType>;
  Github_RepoChangeMergeSettingAuditEntry?: Github_RepoChangeMergeSettingAuditEntryResolvers<ContextType>;
  Github_RepoConfigDisableAnonymousGitAccessAuditEntry?: Github_RepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  Github_RepoConfigDisableCollaboratorsOnlyAuditEntry?: Github_RepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  Github_RepoConfigDisableContributorsOnlyAuditEntry?: Github_RepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType>;
  Github_RepoConfigDisableSockpuppetDisallowedAuditEntry?: Github_RepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  Github_RepoConfigEnableAnonymousGitAccessAuditEntry?: Github_RepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  Github_RepoConfigEnableCollaboratorsOnlyAuditEntry?: Github_RepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  Github_RepoConfigEnableContributorsOnlyAuditEntry?: Github_RepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType>;
  Github_RepoConfigEnableSockpuppetDisallowedAuditEntry?: Github_RepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  Github_RepoConfigLockAnonymousGitAccessAuditEntry?: Github_RepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  Github_RepoConfigUnlockAnonymousGitAccessAuditEntry?: Github_RepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  Github_RepoCreateAuditEntry?: Github_RepoCreateAuditEntryResolvers<ContextType>;
  Github_RepoDestroyAuditEntry?: Github_RepoDestroyAuditEntryResolvers<ContextType>;
  Github_RepoRemoveMemberAuditEntry?: Github_RepoRemoveMemberAuditEntryResolvers<ContextType>;
  Github_RepoRemoveTopicAuditEntry?: Github_RepoRemoveTopicAuditEntryResolvers<ContextType>;
  Github_Repository?: Github_RepositoryResolvers<ContextType>;
  Github_RepositoryAuditEntryData?: Github_RepositoryAuditEntryDataResolvers<ContextType>;
  Github_RepositoryCodeowners?: Github_RepositoryCodeownersResolvers<ContextType>;
  Github_RepositoryCodeownersError?: Github_RepositoryCodeownersErrorResolvers<ContextType>;
  Github_RepositoryCollaboratorConnection?: Github_RepositoryCollaboratorConnectionResolvers<ContextType>;
  Github_RepositoryCollaboratorEdge?: Github_RepositoryCollaboratorEdgeResolvers<ContextType>;
  Github_RepositoryConnection?: Github_RepositoryConnectionResolvers<ContextType>;
  Github_RepositoryContactLink?: Github_RepositoryContactLinkResolvers<ContextType>;
  Github_RepositoryDiscussionAuthor?: Github_RepositoryDiscussionAuthorResolvers<ContextType>;
  Github_RepositoryDiscussionCommentAuthor?: Github_RepositoryDiscussionCommentAuthorResolvers<ContextType>;
  Github_RepositoryEdge?: Github_RepositoryEdgeResolvers<ContextType>;
  Github_RepositoryInfo?: Github_RepositoryInfoResolvers<ContextType>;
  Github_RepositoryInteractionAbility?: Github_RepositoryInteractionAbilityResolvers<ContextType>;
  Github_RepositoryInvitation?: Github_RepositoryInvitationResolvers<ContextType>;
  Github_RepositoryInvitationConnection?: Github_RepositoryInvitationConnectionResolvers<ContextType>;
  Github_RepositoryInvitationEdge?: Github_RepositoryInvitationEdgeResolvers<ContextType>;
  Github_RepositoryMigration?: Github_RepositoryMigrationResolvers<ContextType>;
  Github_RepositoryMigrationConnection?: Github_RepositoryMigrationConnectionResolvers<ContextType>;
  Github_RepositoryMigrationEdge?: Github_RepositoryMigrationEdgeResolvers<ContextType>;
  Github_RepositoryNode?: Github_RepositoryNodeResolvers<ContextType>;
  Github_RepositoryOwner?: Github_RepositoryOwnerResolvers<ContextType>;
  Github_RepositoryTopic?: Github_RepositoryTopicResolvers<ContextType>;
  Github_RepositoryTopicConnection?: Github_RepositoryTopicConnectionResolvers<ContextType>;
  Github_RepositoryTopicEdge?: Github_RepositoryTopicEdgeResolvers<ContextType>;
  Github_RepositoryVisibilityChangeDisableAuditEntry?: Github_RepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType>;
  Github_RepositoryVisibilityChangeEnableAuditEntry?: Github_RepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType>;
  Github_RepositoryVulnerabilityAlert?: Github_RepositoryVulnerabilityAlertResolvers<ContextType>;
  Github_RepositoryVulnerabilityAlertConnection?: Github_RepositoryVulnerabilityAlertConnectionResolvers<ContextType>;
  Github_RepositoryVulnerabilityAlertEdge?: Github_RepositoryVulnerabilityAlertEdgeResolvers<ContextType>;
  Github_RequestReviewsPayload?: Github_RequestReviewsPayloadResolvers<ContextType>;
  Github_RequestedReviewer?: Github_RequestedReviewerResolvers<ContextType>;
  Github_RequestedReviewerConnection?: Github_RequestedReviewerConnectionResolvers<ContextType>;
  Github_RequestedReviewerEdge?: Github_RequestedReviewerEdgeResolvers<ContextType>;
  Github_RequirableByPullRequest?: Github_RequirableByPullRequestResolvers<ContextType>;
  Github_RequiredStatusCheckDescription?: Github_RequiredStatusCheckDescriptionResolvers<ContextType>;
  Github_RerequestCheckSuitePayload?: Github_RerequestCheckSuitePayloadResolvers<ContextType>;
  Github_ResolveReviewThreadPayload?: Github_ResolveReviewThreadPayloadResolvers<ContextType>;
  Github_RestrictedContribution?: Github_RestrictedContributionResolvers<ContextType>;
  Github_RetireSponsorsTierPayload?: Github_RetireSponsorsTierPayloadResolvers<ContextType>;
  Github_RevertPullRequestPayload?: Github_RevertPullRequestPayloadResolvers<ContextType>;
  Github_ReviewDismissalAllowance?: Github_ReviewDismissalAllowanceResolvers<ContextType>;
  Github_ReviewDismissalAllowanceActor?: Github_ReviewDismissalAllowanceActorResolvers<ContextType>;
  Github_ReviewDismissalAllowanceConnection?: Github_ReviewDismissalAllowanceConnectionResolvers<ContextType>;
  Github_ReviewDismissalAllowanceEdge?: Github_ReviewDismissalAllowanceEdgeResolvers<ContextType>;
  Github_ReviewDismissedEvent?: Github_ReviewDismissedEventResolvers<ContextType>;
  Github_ReviewRequest?: Github_ReviewRequestResolvers<ContextType>;
  Github_ReviewRequestConnection?: Github_ReviewRequestConnectionResolvers<ContextType>;
  Github_ReviewRequestEdge?: Github_ReviewRequestEdgeResolvers<ContextType>;
  Github_ReviewRequestRemovedEvent?: Github_ReviewRequestRemovedEventResolvers<ContextType>;
  Github_ReviewRequestedEvent?: Github_ReviewRequestedEventResolvers<ContextType>;
  Github_ReviewStatusHovercardContext?: Github_ReviewStatusHovercardContextResolvers<ContextType>;
  Github_RevokeEnterpriseOrganizationsMigratorRolePayload?: Github_RevokeEnterpriseOrganizationsMigratorRolePayloadResolvers<ContextType>;
  Github_RevokeMigratorRolePayload?: Github_RevokeMigratorRolePayloadResolvers<ContextType>;
  Github_SavedReply?: Github_SavedReplyResolvers<ContextType>;
  Github_SavedReplyConnection?: Github_SavedReplyConnectionResolvers<ContextType>;
  Github_SavedReplyEdge?: Github_SavedReplyEdgeResolvers<ContextType>;
  Github_SearchResultItem?: Github_SearchResultItemResolvers<ContextType>;
  Github_SearchResultItemConnection?: Github_SearchResultItemConnectionResolvers<ContextType>;
  Github_SearchResultItemEdge?: Github_SearchResultItemEdgeResolvers<ContextType>;
  Github_SecurityAdvisory?: Github_SecurityAdvisoryResolvers<ContextType>;
  Github_SecurityAdvisoryConnection?: Github_SecurityAdvisoryConnectionResolvers<ContextType>;
  Github_SecurityAdvisoryEdge?: Github_SecurityAdvisoryEdgeResolvers<ContextType>;
  Github_SecurityAdvisoryIdentifier?: Github_SecurityAdvisoryIdentifierResolvers<ContextType>;
  Github_SecurityAdvisoryPackage?: Github_SecurityAdvisoryPackageResolvers<ContextType>;
  Github_SecurityAdvisoryPackageVersion?: Github_SecurityAdvisoryPackageVersionResolvers<ContextType>;
  Github_SecurityAdvisoryReference?: Github_SecurityAdvisoryReferenceResolvers<ContextType>;
  Github_SecurityVulnerability?: Github_SecurityVulnerabilityResolvers<ContextType>;
  Github_SecurityVulnerabilityConnection?: Github_SecurityVulnerabilityConnectionResolvers<ContextType>;
  Github_SecurityVulnerabilityEdge?: Github_SecurityVulnerabilityEdgeResolvers<ContextType>;
  Github_SetEnterpriseIdentityProviderPayload?: Github_SetEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  Github_SetOrganizationInteractionLimitPayload?: Github_SetOrganizationInteractionLimitPayloadResolvers<ContextType>;
  Github_SetRepositoryInteractionLimitPayload?: Github_SetRepositoryInteractionLimitPayloadResolvers<ContextType>;
  Github_SetUserInteractionLimitPayload?: Github_SetUserInteractionLimitPayloadResolvers<ContextType>;
  Github_SmimeSignature?: Github_SmimeSignatureResolvers<ContextType>;
  Github_Sponsor?: Github_SponsorResolvers<ContextType>;
  Github_SponsorConnection?: Github_SponsorConnectionResolvers<ContextType>;
  Github_SponsorEdge?: Github_SponsorEdgeResolvers<ContextType>;
  Github_Sponsorable?: Github_SponsorableResolvers<ContextType>;
  Github_SponsorableItem?: Github_SponsorableItemResolvers<ContextType>;
  Github_SponsorableItemConnection?: Github_SponsorableItemConnectionResolvers<ContextType>;
  Github_SponsorableItemEdge?: Github_SponsorableItemEdgeResolvers<ContextType>;
  Github_SponsorsActivity?: Github_SponsorsActivityResolvers<ContextType>;
  Github_SponsorsActivityConnection?: Github_SponsorsActivityConnectionResolvers<ContextType>;
  Github_SponsorsActivityEdge?: Github_SponsorsActivityEdgeResolvers<ContextType>;
  Github_SponsorsGoal?: Github_SponsorsGoalResolvers<ContextType>;
  Github_SponsorsListing?: Github_SponsorsListingResolvers<ContextType>;
  Github_SponsorsListingFeatureableItem?: Github_SponsorsListingFeatureableItemResolvers<ContextType>;
  Github_SponsorsListingFeaturedItem?: Github_SponsorsListingFeaturedItemResolvers<ContextType>;
  Github_SponsorsTier?: Github_SponsorsTierResolvers<ContextType>;
  Github_SponsorsTierAdminInfo?: Github_SponsorsTierAdminInfoResolvers<ContextType>;
  Github_SponsorsTierConnection?: Github_SponsorsTierConnectionResolvers<ContextType>;
  Github_SponsorsTierEdge?: Github_SponsorsTierEdgeResolvers<ContextType>;
  Github_Sponsorship?: Github_SponsorshipResolvers<ContextType>;
  Github_SponsorshipConnection?: Github_SponsorshipConnectionResolvers<ContextType>;
  Github_SponsorshipEdge?: Github_SponsorshipEdgeResolvers<ContextType>;
  Github_SponsorshipNewsletter?: Github_SponsorshipNewsletterResolvers<ContextType>;
  Github_SponsorshipNewsletterConnection?: Github_SponsorshipNewsletterConnectionResolvers<ContextType>;
  Github_SponsorshipNewsletterEdge?: Github_SponsorshipNewsletterEdgeResolvers<ContextType>;
  Github_SshSignature?: Github_SshSignatureResolvers<ContextType>;
  Github_StargazerConnection?: Github_StargazerConnectionResolvers<ContextType>;
  Github_StargazerEdge?: Github_StargazerEdgeResolvers<ContextType>;
  Github_Starrable?: Github_StarrableResolvers<ContextType>;
  Github_StarredRepositoryConnection?: Github_StarredRepositoryConnectionResolvers<ContextType>;
  Github_StarredRepositoryEdge?: Github_StarredRepositoryEdgeResolvers<ContextType>;
  Github_StartOrganizationMigrationPayload?: Github_StartOrganizationMigrationPayloadResolvers<ContextType>;
  Github_StartRepositoryMigrationPayload?: Github_StartRepositoryMigrationPayloadResolvers<ContextType>;
  Github_Status?: Github_StatusResolvers<ContextType>;
  Github_StatusCheckRollup?: Github_StatusCheckRollupResolvers<ContextType>;
  Github_StatusCheckRollupContext?: Github_StatusCheckRollupContextResolvers<ContextType>;
  Github_StatusCheckRollupContextConnection?: Github_StatusCheckRollupContextConnectionResolvers<ContextType>;
  Github_StatusCheckRollupContextEdge?: Github_StatusCheckRollupContextEdgeResolvers<ContextType>;
  Github_StatusContext?: Github_StatusContextResolvers<ContextType>;
  Github_StatusContextStateCount?: Github_StatusContextStateCountResolvers<ContextType>;
  Github_StripeConnectAccount?: Github_StripeConnectAccountResolvers<ContextType>;
  Github_SubmitPullRequestReviewPayload?: Github_SubmitPullRequestReviewPayloadResolvers<ContextType>;
  Github_Submodule?: Github_SubmoduleResolvers<ContextType>;
  Github_SubmoduleConnection?: Github_SubmoduleConnectionResolvers<ContextType>;
  Github_SubmoduleEdge?: Github_SubmoduleEdgeResolvers<ContextType>;
  Github_Subscribable?: Github_SubscribableResolvers<ContextType>;
  Github_SubscribedEvent?: Github_SubscribedEventResolvers<ContextType>;
  Github_SuggestedReviewer?: Github_SuggestedReviewerResolvers<ContextType>;
  Github_Tag?: Github_TagResolvers<ContextType>;
  Github_Team?: Github_TeamResolvers<ContextType>;
  Github_TeamAddMemberAuditEntry?: Github_TeamAddMemberAuditEntryResolvers<ContextType>;
  Github_TeamAddRepositoryAuditEntry?: Github_TeamAddRepositoryAuditEntryResolvers<ContextType>;
  Github_TeamAuditEntryData?: Github_TeamAuditEntryDataResolvers<ContextType>;
  Github_TeamChangeParentTeamAuditEntry?: Github_TeamChangeParentTeamAuditEntryResolvers<ContextType>;
  Github_TeamConnection?: Github_TeamConnectionResolvers<ContextType>;
  Github_TeamDiscussion?: Github_TeamDiscussionResolvers<ContextType>;
  Github_TeamDiscussionComment?: Github_TeamDiscussionCommentResolvers<ContextType>;
  Github_TeamDiscussionCommentConnection?: Github_TeamDiscussionCommentConnectionResolvers<ContextType>;
  Github_TeamDiscussionCommentEdge?: Github_TeamDiscussionCommentEdgeResolvers<ContextType>;
  Github_TeamDiscussionConnection?: Github_TeamDiscussionConnectionResolvers<ContextType>;
  Github_TeamDiscussionEdge?: Github_TeamDiscussionEdgeResolvers<ContextType>;
  Github_TeamEdge?: Github_TeamEdgeResolvers<ContextType>;
  Github_TeamMemberConnection?: Github_TeamMemberConnectionResolvers<ContextType>;
  Github_TeamMemberEdge?: Github_TeamMemberEdgeResolvers<ContextType>;
  Github_TeamRemoveMemberAuditEntry?: Github_TeamRemoveMemberAuditEntryResolvers<ContextType>;
  Github_TeamRemoveRepositoryAuditEntry?: Github_TeamRemoveRepositoryAuditEntryResolvers<ContextType>;
  Github_TeamRepositoryConnection?: Github_TeamRepositoryConnectionResolvers<ContextType>;
  Github_TeamRepositoryEdge?: Github_TeamRepositoryEdgeResolvers<ContextType>;
  Github_TextMatch?: Github_TextMatchResolvers<ContextType>;
  Github_TextMatchHighlight?: Github_TextMatchHighlightResolvers<ContextType>;
  Github_Topic?: Github_TopicResolvers<ContextType>;
  Github_TopicAuditEntryData?: Github_TopicAuditEntryDataResolvers<ContextType>;
  Github_TransferEnterpriseOrganizationPayload?: Github_TransferEnterpriseOrganizationPayloadResolvers<ContextType>;
  Github_TransferIssuePayload?: Github_TransferIssuePayloadResolvers<ContextType>;
  Github_TransferredEvent?: Github_TransferredEventResolvers<ContextType>;
  Github_Tree?: Github_TreeResolvers<ContextType>;
  Github_TreeEntry?: Github_TreeEntryResolvers<ContextType>;
  Github_URI?: GraphQLScalarType;
  Github_UnarchiveProjectV2ItemPayload?: Github_UnarchiveProjectV2ItemPayloadResolvers<ContextType>;
  Github_UnarchiveRepositoryPayload?: Github_UnarchiveRepositoryPayloadResolvers<ContextType>;
  Github_UnassignedEvent?: Github_UnassignedEventResolvers<ContextType>;
  Github_UnfollowOrganizationPayload?: Github_UnfollowOrganizationPayloadResolvers<ContextType>;
  Github_UnfollowUserPayload?: Github_UnfollowUserPayloadResolvers<ContextType>;
  Github_UniformResourceLocatable?: Github_UniformResourceLocatableResolvers<ContextType>;
  Github_UnknownSignature?: Github_UnknownSignatureResolvers<ContextType>;
  Github_UnlabeledEvent?: Github_UnlabeledEventResolvers<ContextType>;
  Github_UnlinkProjectV2FromRepositoryPayload?: Github_UnlinkProjectV2FromRepositoryPayloadResolvers<ContextType>;
  Github_UnlinkProjectV2FromTeamPayload?: Github_UnlinkProjectV2FromTeamPayloadResolvers<ContextType>;
  Github_UnlinkRepositoryFromProjectPayload?: Github_UnlinkRepositoryFromProjectPayloadResolvers<ContextType>;
  Github_UnlockLockablePayload?: Github_UnlockLockablePayloadResolvers<ContextType>;
  Github_UnlockedEvent?: Github_UnlockedEventResolvers<ContextType>;
  Github_UnmarkDiscussionCommentAsAnswerPayload?: Github_UnmarkDiscussionCommentAsAnswerPayloadResolvers<ContextType>;
  Github_UnmarkFileAsViewedPayload?: Github_UnmarkFileAsViewedPayloadResolvers<ContextType>;
  Github_UnmarkIssueAsDuplicatePayload?: Github_UnmarkIssueAsDuplicatePayloadResolvers<ContextType>;
  Github_UnmarkedAsDuplicateEvent?: Github_UnmarkedAsDuplicateEventResolvers<ContextType>;
  Github_UnminimizeCommentPayload?: Github_UnminimizeCommentPayloadResolvers<ContextType>;
  Github_UnpinIssuePayload?: Github_UnpinIssuePayloadResolvers<ContextType>;
  Github_UnpinnedEvent?: Github_UnpinnedEventResolvers<ContextType>;
  Github_UnresolveReviewThreadPayload?: Github_UnresolveReviewThreadPayloadResolvers<ContextType>;
  Github_UnsubscribedEvent?: Github_UnsubscribedEventResolvers<ContextType>;
  Github_Updatable?: Github_UpdatableResolvers<ContextType>;
  Github_UpdatableComment?: Github_UpdatableCommentResolvers<ContextType>;
  Github_UpdateBranchProtectionRulePayload?: Github_UpdateBranchProtectionRulePayloadResolvers<ContextType>;
  Github_UpdateCheckRunPayload?: Github_UpdateCheckRunPayloadResolvers<ContextType>;
  Github_UpdateCheckSuitePreferencesPayload?: Github_UpdateCheckSuitePreferencesPayloadResolvers<ContextType>;
  Github_UpdateDiscussionCommentPayload?: Github_UpdateDiscussionCommentPayloadResolvers<ContextType>;
  Github_UpdateDiscussionPayload?: Github_UpdateDiscussionPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseAdministratorRolePayload?: Github_UpdateEnterpriseAdministratorRolePayloadResolvers<ContextType>;
  Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload?: Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload?: Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload?: Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload?: Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload?: Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload?: Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload?: Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload?: Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload?: Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload?: Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseOrganizationProjectsSettingPayload?: Github_UpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseOwnerOrganizationRolePayload?: Github_UpdateEnterpriseOwnerOrganizationRolePayloadResolvers<ContextType>;
  Github_UpdateEnterpriseProfilePayload?: Github_UpdateEnterpriseProfilePayloadResolvers<ContextType>;
  Github_UpdateEnterpriseRepositoryProjectsSettingPayload?: Github_UpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseTeamDiscussionsSettingPayload?: Github_UpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType>;
  Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload?: Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType>;
  Github_UpdateEnvironmentPayload?: Github_UpdateEnvironmentPayloadResolvers<ContextType>;
  Github_UpdateIpAllowListEnabledSettingPayload?: Github_UpdateIpAllowListEnabledSettingPayloadResolvers<ContextType>;
  Github_UpdateIpAllowListEntryPayload?: Github_UpdateIpAllowListEntryPayloadResolvers<ContextType>;
  Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload?: Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayloadResolvers<ContextType>;
  Github_UpdateIssueCommentPayload?: Github_UpdateIssueCommentPayloadResolvers<ContextType>;
  Github_UpdateIssuePayload?: Github_UpdateIssuePayloadResolvers<ContextType>;
  Github_UpdateLabelPayload?: Github_UpdateLabelPayloadResolvers<ContextType>;
  Github_UpdateNotificationRestrictionSettingPayload?: Github_UpdateNotificationRestrictionSettingPayloadResolvers<ContextType>;
  Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload?: Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  Github_UpdateOrganizationWebCommitSignoffSettingPayload?: Github_UpdateOrganizationWebCommitSignoffSettingPayloadResolvers<ContextType>;
  Github_UpdateProjectCardPayload?: Github_UpdateProjectCardPayloadResolvers<ContextType>;
  Github_UpdateProjectColumnPayload?: Github_UpdateProjectColumnPayloadResolvers<ContextType>;
  Github_UpdateProjectPayload?: Github_UpdateProjectPayloadResolvers<ContextType>;
  Github_UpdateProjectV2DraftIssuePayload?: Github_UpdateProjectV2DraftIssuePayloadResolvers<ContextType>;
  Github_UpdateProjectV2ItemFieldValuePayload?: Github_UpdateProjectV2ItemFieldValuePayloadResolvers<ContextType>;
  Github_UpdateProjectV2ItemPositionPayload?: Github_UpdateProjectV2ItemPositionPayloadResolvers<ContextType>;
  Github_UpdateProjectV2Payload?: Github_UpdateProjectV2PayloadResolvers<ContextType>;
  Github_UpdatePullRequestBranchPayload?: Github_UpdatePullRequestBranchPayloadResolvers<ContextType>;
  Github_UpdatePullRequestPayload?: Github_UpdatePullRequestPayloadResolvers<ContextType>;
  Github_UpdatePullRequestReviewCommentPayload?: Github_UpdatePullRequestReviewCommentPayloadResolvers<ContextType>;
  Github_UpdatePullRequestReviewPayload?: Github_UpdatePullRequestReviewPayloadResolvers<ContextType>;
  Github_UpdateRefPayload?: Github_UpdateRefPayloadResolvers<ContextType>;
  Github_UpdateRefsPayload?: Github_UpdateRefsPayloadResolvers<ContextType>;
  Github_UpdateRepositoryPayload?: Github_UpdateRepositoryPayloadResolvers<ContextType>;
  Github_UpdateRepositoryWebCommitSignoffSettingPayload?: Github_UpdateRepositoryWebCommitSignoffSettingPayloadResolvers<ContextType>;
  Github_UpdateSponsorshipPreferencesPayload?: Github_UpdateSponsorshipPreferencesPayloadResolvers<ContextType>;
  Github_UpdateSubscriptionPayload?: Github_UpdateSubscriptionPayloadResolvers<ContextType>;
  Github_UpdateTeamDiscussionCommentPayload?: Github_UpdateTeamDiscussionCommentPayloadResolvers<ContextType>;
  Github_UpdateTeamDiscussionPayload?: Github_UpdateTeamDiscussionPayloadResolvers<ContextType>;
  Github_UpdateTeamReviewAssignmentPayload?: Github_UpdateTeamReviewAssignmentPayloadResolvers<ContextType>;
  Github_UpdateTeamsRepositoryPayload?: Github_UpdateTeamsRepositoryPayloadResolvers<ContextType>;
  Github_UpdateTopicsPayload?: Github_UpdateTopicsPayloadResolvers<ContextType>;
  Github_User?: Github_UserResolvers<ContextType>;
  Github_UserBlockedEvent?: Github_UserBlockedEventResolvers<ContextType>;
  Github_UserConnection?: Github_UserConnectionResolvers<ContextType>;
  Github_UserContentEdit?: Github_UserContentEditResolvers<ContextType>;
  Github_UserContentEditConnection?: Github_UserContentEditConnectionResolvers<ContextType>;
  Github_UserContentEditEdge?: Github_UserContentEditEdgeResolvers<ContextType>;
  Github_UserEdge?: Github_UserEdgeResolvers<ContextType>;
  Github_UserEmailMetadata?: Github_UserEmailMetadataResolvers<ContextType>;
  Github_UserStatus?: Github_UserStatusResolvers<ContextType>;
  Github_UserStatusConnection?: Github_UserStatusConnectionResolvers<ContextType>;
  Github_UserStatusEdge?: Github_UserStatusEdgeResolvers<ContextType>;
  Github_VerifiableDomain?: Github_VerifiableDomainResolvers<ContextType>;
  Github_VerifiableDomainConnection?: Github_VerifiableDomainConnectionResolvers<ContextType>;
  Github_VerifiableDomainEdge?: Github_VerifiableDomainEdgeResolvers<ContextType>;
  Github_VerifiableDomainOwner?: Github_VerifiableDomainOwnerResolvers<ContextType>;
  Github_VerifyVerifiableDomainPayload?: Github_VerifyVerifiableDomainPayloadResolvers<ContextType>;
  Github_ViewerHovercardContext?: Github_ViewerHovercardContextResolvers<ContextType>;
  Github_Votable?: Github_VotableResolvers<ContextType>;
  Github_Workflow?: Github_WorkflowResolvers<ContextType>;
  Github_WorkflowRun?: Github_WorkflowRunResolvers<ContextType>;
  Github_WorkflowRunConnection?: Github_WorkflowRunConnectionResolvers<ContextType>;
  Github_WorkflowRunEdge?: Github_WorkflowRunEdgeResolvers<ContextType>;
  Github_X509Certificate?: GraphQLScalarType;
  github_1Query?: github_1QueryResolvers<ContextType>;
  github_1Mutation?: github_1MutationResolvers<ContextType>;
}>;


export type MeshContext = AwsLambdaTypes.Context & GithubTypes.Context & BaseMeshContext;


import { fileURLToPath } from '@graphql-mesh/utils';
const baseDir = pathModule.join(pathModule.dirname(fileURLToPath(import.meta.url)), '..');

const importFn: ImportFn = <T>(moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\').join('/').replace(baseDir + '/', '');
  switch(relativeModuleId) {
    default:
      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));
  }
};

const rootStore = new MeshStore('.mesh', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: "ts",
}), {
  readonly: true,
  validate: false
});

export function getMeshOptions() {
  console.warn('WARNING: These artifacts are built for development mode. Please run "mesh build" to build production artifacts');
  return findAndParseConfig({
    dir: baseDir,
    artifactsDir: ".mesh",
    configName: "mesh",
    additionalPackagePrefixes: [],
    initialLoggerPrefix: "  Mesh",
  });
}

export function createBuiltMeshHTTPHandler(): MeshHTTPHandler<MeshContext> {
  return createMeshHTTPHandler<MeshContext>({
    baseDir,
    getBuiltMesh: getBuiltMesh,
    rawServeConfig: {"playground":true},
  })
}

let meshInstance$: Promise<MeshInstance> | undefined;

export function getBuiltMesh(): Promise<MeshInstance> {
  if (meshInstance$ == null) {
    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {
      const id = mesh.pubsub.subscribe('destroy', () => {
        meshInstance$ = undefined;
        mesh.pubsub.unsubscribe(id);
      });
      return mesh;
    });
  }
  return meshInstance$;
}

export const execute: ExecuteMeshFn = (...args) => getBuiltMesh().then(({ execute }) => execute(...args));

export const subscribe: SubscribeMeshFn = (...args) => getBuiltMesh().then(({ subscribe }) => subscribe(...args));